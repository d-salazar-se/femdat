webpackJsonp([26],{

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"/home/ssalazar/Projects/vue-dashboard-metrics/node_modules/.cache/cache-loader\"}!./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/pages/Dashboard/Calendar/Calendar.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sweetalert2__ = __webpack_require__(\"./node_modules/sweetalert2/dist/sweetalert2.all.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sweetalert2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sweetalert2__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(\"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fullcalendar__ = __webpack_require__(\"./node_modules/fullcalendar/dist/fullcalendar.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fullcalendar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_fullcalendar__);\n//\n//\n//\n\n\n\nvar today = new Date();\nvar y = today.getFullYear();\nvar m = today.getMonth();\nvar d = today.getDate();\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      events: [{\n        title: 'All Day Event',\n        start: new Date(y, m, 1),\n        className: 'event-default'\n      }, {\n        id: 999,\n        title: 'Repeating Event',\n        start: new Date(y, m, d - 4, 6, 0),\n        allDay: false,\n        className: 'event-rose'\n      }, {\n        id: 999,\n        title: 'Repeating Event',\n        start: new Date(y, m, d + 3, 6, 0),\n        allDay: false,\n        className: 'event-rose'\n      }, {\n        title: 'Meeting',\n        start: new Date(y, m, d - 1, 10, 30),\n        allDay: false,\n        className: 'event-green'\n      }, {\n        title: 'Lunch',\n        start: new Date(y, m, d + 7, 12, 0),\n        end: new Date(y, m, d + 7, 14, 0),\n        allDay: false,\n        className: 'event-red'\n      }, {\n        title: 'Md-pro Launch',\n        start: new Date(y, m, d - 2, 12, 0),\n        allDay: true,\n        className: 'event-azure'\n      }, {\n        title: 'Birthday Party',\n        start: new Date(y, m, d + 1, 19, 0),\n        end: new Date(y, m, d + 1, 22, 30),\n        allDay: false,\n        className: 'event-azure'\n      }, {\n        title: 'Click for Creative Tim',\n        start: new Date(y, m, 21),\n        end: new Date(y, m, 22),\n        url: 'http://www.creative-tim.com/',\n        className: 'event-orange'\n      }, {\n        title: 'Click for Google',\n        start: new Date(y, m, 21),\n        end: new Date(y, m, 22),\n        url: 'http://www.creative-tim.com/',\n        className: 'event-orange'\n      }]\n    };\n  },\n  methods: {\n    initCalendar: function initCalendar($) {\n      var self = this;\n      var $calendar = $('#fullCalendar');\n      $calendar.fullCalendar({\n        header: {\n          left: 'title',\n          center: 'month,agendaWeek,agendaDay',\n          right: 'prev,next,today'\n        },\n        defaultDate: today,\n        selectable: true,\n        selectHelper: true,\n        views: {\n          month: {\n            // name of view\n            titleFormat: 'MMMM YYYY' // other view-specific options here\n\n          },\n          week: {\n            titleFormat: ' MMMM D YYYY'\n          },\n          day: {\n            titleFormat: 'D MMM, YYYY'\n          }\n        },\n        select: function select(start, end) {\n          // on select we show the Sweet Alert modal with an input\n          __WEBPACK_IMPORTED_MODULE_0_sweetalert2___default()({\n            title: 'Create an Event',\n            html: '<div class=\"form-group\">' + '<input class=\"form-control\" placeholder=\"Event Title\" id=\"input-field\">' + '</div>',\n            showCancelButton: true,\n            confirmButtonClass: 'btn btn-success',\n            cancelButtonClass: 'btn btn-danger',\n            buttonsStyling: false\n          }).then(function () {\n            var eventData;\n            var eventTitle = $('#input-field').val();\n\n            if (eventTitle) {\n              eventData = {\n                title: eventTitle,\n                start: start,\n                end: end\n              };\n              $calendar.fullCalendar('renderEvent', eventData, true); // stick? = true\n            }\n\n            $calendar.fullCalendar('unselect');\n          });\n        },\n        editable: true,\n        eventLimit: true,\n        // allow \"more\" link when too many events\n        // color classes: [ event-blue | event-azure | event-green | event-orange | event-red ]\n        events: self.events\n      });\n    }\n  },\n  mounted: function mounted() {\n    window.$ = window.jQuery = __WEBPACK_IMPORTED_MODULE_1_jquery___default.a;\n    this.initCalendar(__WEBPACK_IMPORTED_MODULE_1_jquery___default.a);\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCIvaG9tZS9zc2FsYXphci9Qcm9qZWN0cy92dWUtZGFzaGJvYXJkLW1ldHJpY3Mvbm9kZV9tb2R1bGVzLy5jYWNoZS9jYWNoZS1sb2FkZXJcIn0hLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vc3JjL3BhZ2VzL0Rhc2hib2FyZC9DYWxlbmRhci9DYWxlbmRhci52dWUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQ2FsZW5kYXIudnVlP2IxYWEiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwiZnVsbENhbGVuZGFyXCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgaW1wb3J0IHN3YWwgZnJvbSAnc3dlZXRhbGVydDInXG4gIGltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbiAgaW1wb3J0ICdmdWxsY2FsZW5kYXInXG5cbiAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKVxuICB2YXIgeSA9IHRvZGF5LmdldEZ1bGxZZWFyKClcbiAgdmFyIG0gPSB0b2RheS5nZXRNb250aCgpXG4gIHZhciBkID0gdG9kYXkuZ2V0RGF0ZSgpXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdBbGwgRGF5IEV2ZW50JyxcbiAgICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCAxKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2V2ZW50LWRlZmF1bHQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogOTk5LFxuICAgICAgICAgICAgdGl0bGU6ICdSZXBlYXRpbmcgRXZlbnQnLFxuICAgICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHksIG0sIGQgLSA0LCA2LCAwKSxcbiAgICAgICAgICAgIGFsbERheTogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdldmVudC1yb3NlJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDk5OSxcbiAgICAgICAgICAgIHRpdGxlOiAnUmVwZWF0aW5nIEV2ZW50JyxcbiAgICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCBkICsgMywgNiwgMCksXG4gICAgICAgICAgICBhbGxEYXk6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZXZlbnQtcm9zZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnTWVldGluZycsXG4gICAgICAgICAgICBzdGFydDogbmV3IERhdGUoeSwgbSwgZCAtIDEsIDEwLCAzMCksXG4gICAgICAgICAgICBhbGxEYXk6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZXZlbnQtZ3JlZW4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJ0x1bmNoJyxcbiAgICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCBkICsgNywgMTIsIDApLFxuICAgICAgICAgICAgZW5kOiBuZXcgRGF0ZSh5LCBtLCBkICsgNywgMTQsIDApLFxuICAgICAgICAgICAgYWxsRGF5OiBmYWxzZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2V2ZW50LXJlZCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnTWQtcHJvIExhdW5jaCcsXG4gICAgICAgICAgICBzdGFydDogbmV3IERhdGUoeSwgbSwgZCAtIDIsIDEyLCAwKSxcbiAgICAgICAgICAgIGFsbERheTogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2V2ZW50LWF6dXJlJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdCaXJ0aGRheSBQYXJ0eScsXG4gICAgICAgICAgICBzdGFydDogbmV3IERhdGUoeSwgbSwgZCArIDEsIDE5LCAwKSxcbiAgICAgICAgICAgIGVuZDogbmV3IERhdGUoeSwgbSwgZCArIDEsIDIyLCAzMCksXG4gICAgICAgICAgICBhbGxEYXk6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZXZlbnQtYXp1cmUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJ0NsaWNrIGZvciBDcmVhdGl2ZSBUaW0nLFxuICAgICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHksIG0sIDIxKSxcbiAgICAgICAgICAgIGVuZDogbmV3IERhdGUoeSwgbSwgMjIpLFxuICAgICAgICAgICAgdXJsOiAnaHR0cDovL3d3dy5jcmVhdGl2ZS10aW0uY29tLycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdldmVudC1vcmFuZ2UnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJ0NsaWNrIGZvciBHb29nbGUnLFxuICAgICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHksIG0sIDIxKSxcbiAgICAgICAgICAgIGVuZDogbmV3IERhdGUoeSwgbSwgMjIpLFxuICAgICAgICAgICAgdXJsOiAnaHR0cDovL3d3dy5jcmVhdGl2ZS10aW0uY29tLycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdldmVudC1vcmFuZ2UnXG4gICAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGluaXRDYWxlbmRhcigkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICB2YXIgJGNhbGVuZGFyID0gJCgnI2Z1bGxDYWxlbmRhcicpXG4gICAgICAgICRjYWxlbmRhci5mdWxsQ2FsZW5kYXIoe1xuICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgbGVmdDogJ3RpdGxlJyxcbiAgICAgICAgICAgIGNlbnRlcjogJ21vbnRoLGFnZW5kYVdlZWssYWdlbmRhRGF5JyxcbiAgICAgICAgICAgIHJpZ2h0OiAncHJldixuZXh0LHRvZGF5J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmYXVsdERhdGU6IHRvZGF5LFxuICAgICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgICAgc2VsZWN0SGVscGVyOiB0cnVlLFxuICAgICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICBtb250aDogeyAvLyBuYW1lIG9mIHZpZXdcbiAgICAgICAgICAgICAgdGl0bGVGb3JtYXQ6ICdNTU1NIFlZWVknXG4gICAgICAgICAgICAgIC8vIG90aGVyIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBoZXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgICB0aXRsZUZvcm1hdDogJyBNTU1NIEQgWVlZWSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXk6IHtcbiAgICAgICAgICAgICAgdGl0bGVGb3JtYXQ6ICdEIE1NTSwgWVlZWSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIC8vIG9uIHNlbGVjdCB3ZSBzaG93IHRoZSBTd2VldCBBbGVydCBtb2RhbCB3aXRoIGFuIGlucHV0XG4gICAgICAgICAgICBzd2FsKHtcbiAgICAgICAgICAgICAgdGl0bGU6ICdDcmVhdGUgYW4gRXZlbnQnLFxuICAgICAgICAgICAgICBodG1sOiAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcbiAgICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbFwiIHBsYWNlaG9sZGVyPVwiRXZlbnQgVGl0bGVcIiBpZD1cImlucHV0LWZpZWxkXCI+JyArXG4gICAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgICBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgICBjb25maXJtQnV0dG9uQ2xhc3M6ICdidG4gYnRuLXN1Y2Nlc3MnLFxuICAgICAgICAgICAgICBjYW5jZWxCdXR0b25DbGFzczogJ2J0biBidG4tZGFuZ2VyJyxcbiAgICAgICAgICAgICAgYnV0dG9uc1N0eWxpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YVxuICAgICAgICAgICAgICB2YXIgZXZlbnRUaXRsZSA9ICQoJyNpbnB1dC1maWVsZCcpLnZhbCgpXG4gICAgICAgICAgICAgIGlmIChldmVudFRpdGxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgdGl0bGU6IGV2ZW50VGl0bGUsXG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkY2FsZW5kYXIuZnVsbENhbGVuZGFyKCdyZW5kZXJFdmVudCcsIGV2ZW50RGF0YSwgdHJ1ZSkgLy8gc3RpY2s/ID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRjYWxlbmRhci5mdWxsQ2FsZW5kYXIoJ3Vuc2VsZWN0JylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBldmVudExpbWl0OiB0cnVlLCAvLyBhbGxvdyBcIm1vcmVcIiBsaW5rIHdoZW4gdG9vIG1hbnkgZXZlbnRzXG5cbiAgICAgICAgICAvLyBjb2xvciBjbGFzc2VzOiBbIGV2ZW50LWJsdWUgfCBldmVudC1henVyZSB8IGV2ZW50LWdyZWVuIHwgZXZlbnQtb3JhbmdlIHwgZXZlbnQtcmVkIF1cbiAgICAgICAgICBldmVudHM6IHNlbGYuZXZlbnRzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgd2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gJFxuICAgICAgdGhpcy5pbml0Q2FsZW5kYXIoJClcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuICAjZnVsbENhbGVuZGFyIHtcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcbiAgfVxuXG4gIC5lbC1sb2FkaW5nLXNwaW5uZXIgLnBhdGgge1xuICAgIHN0cm9rZTogIzY2NjE1QiAhaW1wb3J0YW50O1xuICB9XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIENhbGVuZGFyLnZ1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFJQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBdERBO0FBOERBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFEQTs7QUFJQTtBQURBO0FBUkE7QUFZQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFsREE7QUFvREE7QUF4REE7QUEwREE7QUFDQTtBQUNBO0FBQ0E7QUE5SEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"/home/ssalazar/Projects/vue-dashboard-metrics/node_modules/.cache/cache-loader\"}!./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?{\"sourceMap\":false,\"minimize\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\"optionsId\":\"0\",\"vue\":true,\"scoped\":false,\"sourceMap\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue":
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(\"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n#fullCalendar {\\n  min-height: 300px;\\n}\\n.el-loading-spinner .path {\\n  stroke: #66615B !important;\\n}\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjpmYWxzZSxcIm1pbmltaXplXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcIm9wdGlvbnNJZFwiOlwiMFwiLFwidnVlXCI6dHJ1ZSxcInNjb3BlZFwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlP2ZmNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4jZnVsbENhbGVuZGFyIHtcXG4gIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbn1cXG4uZWwtbG9hZGluZy1zcGlubmVyIC5wYXRoIHtcXG4gIHN0cm9rZTogIzY2NjE1QiAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3tcInNvdXJjZU1hcFwiOmZhbHNlLFwibWluaW1pemVcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wib3B0aW9uc0lkXCI6XCIwXCIsXCJ2dWVcIjp0cnVlLFwic2NvcGVkXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3tcInNvdXJjZU1hcFwiOmZhbHNlLFwibWluaW1pemVcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1wib3B0aW9uc0lkXCI6XCIwXCIsXCJ2dWVcIjp0cnVlLFwic2NvcGVkXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMjYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?{\"sourceMap\":false,\"minimize\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\"optionsId\":\"0\",\"vue\":true,\"scoped\":false,\"sourceMap\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\n");

/***/ }),

/***/ "./node_modules/fullcalendar/dist/fullcalendar.js":
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FullCalendar v3.9.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(\"./node_modules/moment/moment.js\"), __webpack_require__(\"./node_modules/jquery/dist/jquery.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"moment\", \"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FullCalendar\"] = factory(require(\"moment\"), require(\"jquery\"));\n\telse\n\t\troot[\"FullCalendar\"] = factory(root[\"moment\"], root[\"jQuery\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 236);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports) {\n\n/*\r\nderived from:\r\nhttps://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js\r\n\nonly include the helpers we need, to keep down filesize\r\n*/\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b)\r\n        if (b.hasOwnProperty(p))\r\n            d[p] = b[p]; };\r\nexports.__extends = function (d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\n/* FullCalendar-specific DOM Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\r\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\r\nfunction compensateScroll(rowEls, scrollbarWidths) {\r\n    if (scrollbarWidths.left) {\r\n        rowEls.css({\r\n            'border-left-width': 1,\r\n            'margin-left': scrollbarWidths.left - 1\r\n        });\r\n    }\r\n    if (scrollbarWidths.right) {\r\n        rowEls.css({\r\n            'border-right-width': 1,\r\n            'margin-right': scrollbarWidths.right - 1\r\n        });\r\n    }\r\n}\r\nexports.compensateScroll = compensateScroll;\r\n// Undoes compensateScroll and restores all borders/margins\r\nfunction uncompensateScroll(rowEls) {\r\n    rowEls.css({\r\n        'margin-left': '',\r\n        'margin-right': '',\r\n        'border-left-width': '',\r\n        'border-right-width': ''\r\n    });\r\n}\r\nexports.uncompensateScroll = uncompensateScroll;\r\n// Make the mouse cursor express that an event is not allowed in the current area\r\nfunction disableCursor() {\r\n    $('body').addClass('fc-not-allowed');\r\n}\r\nexports.disableCursor = disableCursor;\r\n// Returns the mouse cursor to its original look\r\nfunction enableCursor() {\r\n    $('body').removeClass('fc-not-allowed');\r\n}\r\nexports.enableCursor = enableCursor;\r\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\r\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\r\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and\r\n// reduces the available height.\r\nfunction distributeHeight(els, availableHeight, shouldRedistribute) {\r\n    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\r\n    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\r\n    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\r\n    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\r\n    var flexEls = []; // elements that are allowed to expand. array of DOM nodes\r\n    var flexOffsets = []; // amount of vertical space it takes up\r\n    var flexHeights = []; // actual css height\r\n    var usedHeight = 0;\r\n    undistributeHeight(els); // give all elements their natural height\r\n    // find elements that are below the recommended height (expandable).\r\n    // important to query for heights in a single first pass (to avoid reflow oscillation).\r\n    els.each(function (i, el) {\r\n        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\r\n        var naturalOffset = $(el).outerHeight(true);\r\n        if (naturalOffset < minOffset) {\r\n            flexEls.push(el);\r\n            flexOffsets.push(naturalOffset);\r\n            flexHeights.push($(el).height());\r\n        }\r\n        else {\r\n            // this element stretches past recommended height (non-expandable). mark the space as occupied.\r\n            usedHeight += naturalOffset;\r\n        }\r\n    });\r\n    // readjust the recommended height to only consider the height available to non-maxed-out rows.\r\n    if (shouldRedistribute) {\r\n        availableHeight -= usedHeight;\r\n        minOffset1 = Math.floor(availableHeight / flexEls.length);\r\n        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\r\n    }\r\n    // assign heights to all expandable elements\r\n    $(flexEls).each(function (i, el) {\r\n        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\r\n        var naturalOffset = flexOffsets[i];\r\n        var naturalHeight = flexHeights[i];\r\n        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\r\n        if (naturalOffset < minOffset) {\r\n            $(el).height(newHeight);\r\n        }\r\n    });\r\n}\r\nexports.distributeHeight = distributeHeight;\r\n// Undoes distrubuteHeight, restoring all els to their natural height\r\nfunction undistributeHeight(els) {\r\n    els.height('');\r\n}\r\nexports.undistributeHeight = undistributeHeight;\r\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\r\n// cells to be that width.\r\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\r\nfunction matchCellWidths(els) {\r\n    var maxInnerWidth = 0;\r\n    els.find('> *').each(function (i, innerEl) {\r\n        var innerWidth = $(innerEl).outerWidth();\r\n        if (innerWidth > maxInnerWidth) {\r\n            maxInnerWidth = innerWidth;\r\n        }\r\n    });\r\n    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\r\n    els.width(maxInnerWidth);\r\n    return maxInnerWidth;\r\n}\r\nexports.matchCellWidths = matchCellWidths;\r\n// Given one element that resides inside another,\r\n// Subtracts the height of the inner element from the outer element.\r\nfunction subtractInnerElHeight(outerEl, innerEl) {\r\n    var both = outerEl.add(innerEl);\r\n    var diff;\r\n    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\r\n    both.css({\r\n        position: 'relative',\r\n        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\r\n    });\r\n    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\r\n    both.css({ position: '', left: '' }); // undo hack\r\n    return diff;\r\n}\r\nexports.subtractInnerElHeight = subtractInnerElHeight;\r\n/* Element Geom Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\r\nfunction getScrollParent(el) {\r\n    var position = el.css('position');\r\n    var scrollParent = el.parents().filter(function () {\r\n        var parent = $(this);\r\n        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));\r\n    }).eq(0);\r\n    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\r\n}\r\nexports.getScrollParent = getScrollParent;\r\n// Queries the outer bounding area of a jQuery element.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getOuterRect(el, origin) {\r\n    var offset = el.offset();\r\n    var left = offset.left - (origin ? origin.left : 0);\r\n    var top = offset.top - (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el.outerWidth(),\r\n        top: top,\r\n        bottom: top + el.outerHeight()\r\n    };\r\n}\r\nexports.getOuterRect = getOuterRect;\r\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\n// WARNING: given element can't have borders\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getClientRect(el, origin) {\r\n    var offset = el.offset();\r\n    var scrollbarWidths = getScrollbarWidths(el);\r\n    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\r\n    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el[0].clientWidth,\r\n        top: top,\r\n        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\r\n    };\r\n}\r\nexports.getClientRect = getClientRect;\r\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getContentRect(el, origin) {\r\n    var offset = el.offset(); // just outside of border, margin not included\r\n    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\r\n        (origin ? origin.left : 0);\r\n    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\r\n        (origin ? origin.top : 0);\r\n    return {\r\n        left: left,\r\n        right: left + el.width(),\r\n        top: top,\r\n        bottom: top + el.height()\r\n    };\r\n}\r\nexports.getContentRect = getContentRect;\r\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\r\n// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getScrollbarWidths(el) {\r\n    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\r\n    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;\r\n    var widths;\r\n    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\r\n    bottomWidth = sanitizeScrollbarWidth(bottomWidth);\r\n    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\r\n    if (getIsLeftRtlScrollbars() && el.css('direction') === 'rtl') {\r\n        widths.left = leftRightWidth;\r\n    }\r\n    else {\r\n        widths.right = leftRightWidth;\r\n    }\r\n    return widths;\r\n}\r\nexports.getScrollbarWidths = getScrollbarWidths;\r\n// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\r\n// retina displays, rounding, and IE11. Massage them into a usable value.\r\nfunction sanitizeScrollbarWidth(width) {\r\n    width = Math.max(0, width); // no negatives\r\n    width = Math.round(width);\r\n    return width;\r\n}\r\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\r\nvar _isLeftRtlScrollbars = null;\r\nfunction getIsLeftRtlScrollbars() {\r\n    if (_isLeftRtlScrollbars === null) {\r\n        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\r\n    }\r\n    return _isLeftRtlScrollbars;\r\n}\r\nfunction computeIsLeftRtlScrollbars() {\r\n    var el = $('<div><div/></div>')\r\n        .css({\r\n        position: 'absolute',\r\n        top: -1000,\r\n        left: 0,\r\n        border: 0,\r\n        padding: 0,\r\n        overflow: 'scroll',\r\n        direction: 'rtl'\r\n    })\r\n        .appendTo('body');\r\n    var innerEl = el.children();\r\n    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\r\n    el.remove();\r\n    return res;\r\n}\r\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\r\n// If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\r\nfunction getCssFloat(el, prop) {\r\n    return parseFloat(el.css(prop)) || 0;\r\n}\r\n/* Mouse / Touch Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\r\nfunction isPrimaryMouseButton(ev) {\r\n    return ev.which === 1 && !ev.ctrlKey;\r\n}\r\nexports.isPrimaryMouseButton = isPrimaryMouseButton;\r\nfunction getEvX(ev) {\r\n    var touches = ev.originalEvent.touches;\r\n    // on mobile FF, pageX for touch events is present, but incorrect,\r\n    // so, look at touch coordinates first.\r\n    if (touches && touches.length) {\r\n        return touches[0].pageX;\r\n    }\r\n    return ev.pageX;\r\n}\r\nexports.getEvX = getEvX;\r\nfunction getEvY(ev) {\r\n    var touches = ev.originalEvent.touches;\r\n    // on mobile FF, pageX for touch events is present, but incorrect,\r\n    // so, look at touch coordinates first.\r\n    if (touches && touches.length) {\r\n        return touches[0].pageY;\r\n    }\r\n    return ev.pageY;\r\n}\r\nexports.getEvY = getEvY;\r\nfunction getEvIsTouch(ev) {\r\n    return /^touch/.test(ev.type);\r\n}\r\nexports.getEvIsTouch = getEvIsTouch;\r\nfunction preventSelection(el) {\r\n    el.addClass('fc-unselectable')\r\n        .on('selectstart', preventDefault);\r\n}\r\nexports.preventSelection = preventSelection;\r\nfunction allowSelection(el) {\r\n    el.removeClass('fc-unselectable')\r\n        .off('selectstart', preventDefault);\r\n}\r\nexports.allowSelection = allowSelection;\r\n// Stops a mouse/touch event from doing it's native browser action\r\nfunction preventDefault(ev) {\r\n    ev.preventDefault();\r\n}\r\nexports.preventDefault = preventDefault;\r\n/* General Geometry Utils\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\r\nfunction intersectRects(rect1, rect2) {\r\n    var res = {\r\n        left: Math.max(rect1.left, rect2.left),\r\n        right: Math.min(rect1.right, rect2.right),\r\n        top: Math.max(rect1.top, rect2.top),\r\n        bottom: Math.min(rect1.bottom, rect2.bottom)\r\n    };\r\n    if (res.left < res.right && res.top < res.bottom) {\r\n        return res;\r\n    }\r\n    return false;\r\n}\r\nexports.intersectRects = intersectRects;\r\n// Returns a new point that will have been moved to reside within the given rectangle\r\nfunction constrainPoint(point, rect) {\r\n    return {\r\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\r\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\r\n    };\r\n}\r\nexports.constrainPoint = constrainPoint;\r\n// Returns a point that is the center of the given rectangle\r\nfunction getRectCenter(rect) {\r\n    return {\r\n        left: (rect.left + rect.right) / 2,\r\n        top: (rect.top + rect.bottom) / 2\r\n    };\r\n}\r\nexports.getRectCenter = getRectCenter;\r\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\r\nfunction diffPoints(point1, point2) {\r\n    return {\r\n        left: point1.left - point2.left,\r\n        top: point1.top - point2.top\r\n    };\r\n}\r\nexports.diffPoints = diffPoints;\r\n/* Object Ordering by Field\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nfunction parseFieldSpecs(input) {\r\n    var specs = [];\r\n    var tokens = [];\r\n    var i;\r\n    var token;\r\n    if (typeof input === 'string') {\r\n        tokens = input.split(/\\s*,\\s*/);\r\n    }\r\n    else if (typeof input === 'function') {\r\n        tokens = [input];\r\n    }\r\n    else if ($.isArray(input)) {\r\n        tokens = input;\r\n    }\r\n    for (i = 0; i < tokens.length; i++) {\r\n        token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            specs.push(token.charAt(0) === '-' ?\r\n                { field: token.substring(1), order: -1 } :\r\n                { field: token, order: 1 });\r\n        }\r\n        else if (typeof token === 'function') {\r\n            specs.push({ func: token });\r\n        }\r\n    }\r\n    return specs;\r\n}\r\nexports.parseFieldSpecs = parseFieldSpecs;\r\nfunction compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {\r\n    var i;\r\n    var cmp;\r\n    for (i = 0; i < fieldSpecs.length; i++) {\r\n        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);\r\n        if (cmp) {\r\n            return cmp;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nexports.compareByFieldSpecs = compareByFieldSpecs;\r\nfunction compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {\r\n    if (fieldSpec.func) {\r\n        return fieldSpec.func(obj1, obj2);\r\n    }\r\n    var val1 = obj1[fieldSpec.field];\r\n    var val2 = obj2[fieldSpec.field];\r\n    if (val1 == null && obj1fallback) {\r\n        val1 = obj1fallback[fieldSpec.field];\r\n    }\r\n    if (val2 == null && obj2fallback) {\r\n        val2 = obj2fallback[fieldSpec.field];\r\n    }\r\n    return flexibleCompare(val1, val2) * (fieldSpec.order || 1);\r\n}\r\nexports.compareByFieldSpec = compareByFieldSpec;\r\nfunction flexibleCompare(a, b) {\r\n    if (!a && !b) {\r\n        return 0;\r\n    }\r\n    if (b == null) {\r\n        return -1;\r\n    }\r\n    if (a == null) {\r\n        return 1;\r\n    }\r\n    if ($.type(a) === 'string' || $.type(b) === 'string') {\r\n        return String(a).localeCompare(String(b));\r\n    }\r\n    return a - b;\r\n}\r\nexports.flexibleCompare = flexibleCompare;\r\n/* Date Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nexports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\r\nexports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending\r\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\r\n// Moments will have their timezones normalized.\r\nfunction diffDayTime(a, b) {\r\n    return moment.duration({\r\n        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\r\n        ms: a.time() - b.time() // time-of-day from day start. disregards timezone\r\n    });\r\n}\r\nexports.diffDayTime = diffDayTime;\r\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\r\nfunction diffDay(a, b) {\r\n    return moment.duration({\r\n        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\r\n    });\r\n}\r\nexports.diffDay = diffDay;\r\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\r\nfunction diffByUnit(a, b, unit) {\r\n    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true\r\n    unit);\r\n}\r\nexports.diffByUnit = diffByUnit;\r\n// Computes the unit name of the largest whole-unit period of time.\r\n// For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\r\n// Accepts start/end, a range object, or an original duration object.\r\nfunction computeGreatestUnit(start, end) {\r\n    var i;\r\n    var unit;\r\n    var val;\r\n    for (i = 0; i < exports.unitsDesc.length; i++) {\r\n        unit = exports.unitsDesc[i];\r\n        val = computeRangeAs(unit, start, end);\r\n        if (val >= 1 && isInt(val)) {\r\n            break;\r\n        }\r\n    }\r\n    return unit; // will be \"milliseconds\" if nothing else matches\r\n}\r\nexports.computeGreatestUnit = computeGreatestUnit;\r\n// like computeGreatestUnit, but has special abilities to interpret the source input for clues\r\nfunction computeDurationGreatestUnit(duration, durationInput) {\r\n    var unit = computeGreatestUnit(duration);\r\n    // prevent days:7 from being interpreted as a week\r\n    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\r\n        unit = 'day';\r\n    }\r\n    return unit;\r\n}\r\nexports.computeDurationGreatestUnit = computeDurationGreatestUnit;\r\n// Computes the number of units (like \"hours\") in the given range.\r\n// Range can be a {start,end} object, separate start/end args, or a Duration.\r\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\r\n// of month-diffing logic (which tends to vary from version to version).\r\nfunction computeRangeAs(unit, start, end) {\r\n    if (end != null) {\r\n        return end.diff(start, unit, true);\r\n    }\r\n    else if (moment.isDuration(start)) {\r\n        return start.as(unit);\r\n    }\r\n    else {\r\n        return start.end.diff(start.start, unit, true);\r\n    }\r\n}\r\n// Intelligently divides a range (specified by a start/end params) by a duration\r\nfunction divideRangeByDuration(start, end, dur) {\r\n    var months;\r\n    if (durationHasTime(dur)) {\r\n        return (end - start) / dur;\r\n    }\r\n    months = dur.asMonths();\r\n    if (Math.abs(months) >= 1 && isInt(months)) {\r\n        return end.diff(start, 'months', true) / months;\r\n    }\r\n    return end.diff(start, 'days', true) / dur.asDays();\r\n}\r\nexports.divideRangeByDuration = divideRangeByDuration;\r\n// Intelligently divides one duration by another\r\nfunction divideDurationByDuration(dur1, dur2) {\r\n    var months1;\r\n    var months2;\r\n    if (durationHasTime(dur1) || durationHasTime(dur2)) {\r\n        return dur1 / dur2;\r\n    }\r\n    months1 = dur1.asMonths();\r\n    months2 = dur2.asMonths();\r\n    if (Math.abs(months1) >= 1 && isInt(months1) &&\r\n        Math.abs(months2) >= 1 && isInt(months2)) {\r\n        return months1 / months2;\r\n    }\r\n    return dur1.asDays() / dur2.asDays();\r\n}\r\nexports.divideDurationByDuration = divideDurationByDuration;\r\n// Intelligently multiplies a duration by a number\r\nfunction multiplyDuration(dur, n) {\r\n    var months;\r\n    if (durationHasTime(dur)) {\r\n        return moment.duration(dur * n);\r\n    }\r\n    months = dur.asMonths();\r\n    if (Math.abs(months) >= 1 && isInt(months)) {\r\n        return moment.duration({ months: months * n });\r\n    }\r\n    return moment.duration({ days: dur.asDays() * n });\r\n}\r\nexports.multiplyDuration = multiplyDuration;\r\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\r\nfunction durationHasTime(dur) {\r\n    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\r\n}\r\nexports.durationHasTime = durationHasTime;\r\nfunction isNativeDate(input) {\r\n    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\r\n}\r\nexports.isNativeDate = isNativeDate;\r\n// Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\r\nfunction isTimeString(str) {\r\n    return typeof str === 'string' &&\r\n        /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\r\n}\r\nexports.isTimeString = isTimeString;\r\n/* Logging and Debug\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nfunction log() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var console = window.console;\r\n    if (console && console.log) {\r\n        return console.log.apply(console, args);\r\n    }\r\n}\r\nexports.log = log;\r\nfunction warn() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var console = window.console;\r\n    if (console && console.warn) {\r\n        return console.warn.apply(console, args);\r\n    }\r\n    else {\r\n        return log.apply(null, args);\r\n    }\r\n}\r\nexports.warn = warn;\r\n/* General Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar hasOwnPropMethod = {}.hasOwnProperty;\r\n// Merges an array of objects into a single object.\r\n// The second argument allows for an array of property names who's object values will be merged together.\r\nfunction mergeProps(propObjs, complexProps) {\r\n    var dest = {};\r\n    var i;\r\n    var name;\r\n    var complexObjs;\r\n    var j;\r\n    var val;\r\n    var props;\r\n    if (complexProps) {\r\n        for (i = 0; i < complexProps.length; i++) {\r\n            name = complexProps[i];\r\n            complexObjs = [];\r\n            // collect the trailing object values, stopping when a non-object is discovered\r\n            for (j = propObjs.length - 1; j >= 0; j--) {\r\n                val = propObjs[j][name];\r\n                if (typeof val === 'object') {\r\n                    complexObjs.unshift(val);\r\n                }\r\n                else if (val !== undefined) {\r\n                    dest[name] = val; // if there were no objects, this value will be used\r\n                    break;\r\n                }\r\n            }\r\n            // if the trailing values were objects, use the merged value\r\n            if (complexObjs.length) {\r\n                dest[name] = mergeProps(complexObjs);\r\n            }\r\n        }\r\n    }\r\n    // copy values into the destination, going from last to first\r\n    for (i = propObjs.length - 1; i >= 0; i--) {\r\n        props = propObjs[i];\r\n        for (name in props) {\r\n            if (!(name in dest)) {\r\n                dest[name] = props[name];\r\n            }\r\n        }\r\n    }\r\n    return dest;\r\n}\r\nexports.mergeProps = mergeProps;\r\nfunction copyOwnProps(src, dest) {\r\n    for (var name_1 in src) {\r\n        if (hasOwnProp(src, name_1)) {\r\n            dest[name_1] = src[name_1];\r\n        }\r\n    }\r\n}\r\nexports.copyOwnProps = copyOwnProps;\r\nfunction hasOwnProp(obj, name) {\r\n    return hasOwnPropMethod.call(obj, name);\r\n}\r\nexports.hasOwnProp = hasOwnProp;\r\nfunction applyAll(functions, thisObj, args) {\r\n    if ($.isFunction(functions)) {\r\n        functions = [functions];\r\n    }\r\n    if (functions) {\r\n        var i = void 0;\r\n        var ret = void 0;\r\n        for (i = 0; i < functions.length; i++) {\r\n            ret = functions[i].apply(thisObj, args) || ret;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nexports.applyAll = applyAll;\r\nfunction removeMatching(array, testFunc) {\r\n    var removeCnt = 0;\r\n    var i = 0;\r\n    while (i < array.length) {\r\n        if (testFunc(array[i])) {\r\n            array.splice(i, 1);\r\n            removeCnt++;\r\n        }\r\n        else {\r\n            i++;\r\n        }\r\n    }\r\n    return removeCnt;\r\n}\r\nexports.removeMatching = removeMatching;\r\nfunction removeExact(array, exactVal) {\r\n    var removeCnt = 0;\r\n    var i = 0;\r\n    while (i < array.length) {\r\n        if (array[i] === exactVal) {\r\n            array.splice(i, 1);\r\n            removeCnt++;\r\n        }\r\n        else {\r\n            i++;\r\n        }\r\n    }\r\n    return removeCnt;\r\n}\r\nexports.removeExact = removeExact;\r\nfunction isArraysEqual(a0, a1) {\r\n    var len = a0.length;\r\n    var i;\r\n    if (len == null || len !== a1.length) {\r\n        return false;\r\n    }\r\n    for (i = 0; i < len; i++) {\r\n        if (a0[i] !== a1[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isArraysEqual = isArraysEqual;\r\nfunction firstDefined() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < args.length; i++) {\r\n        if (args[i] !== undefined) {\r\n            return args[i];\r\n        }\r\n    }\r\n}\r\nexports.firstDefined = firstDefined;\r\nfunction htmlEscape(s) {\r\n    return (s + '').replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/'/g, '&#039;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/\\n/g, '<br />');\r\n}\r\nexports.htmlEscape = htmlEscape;\r\nfunction stripHtmlEntities(text) {\r\n    return text.replace(/&.*?;/g, '');\r\n}\r\nexports.stripHtmlEntities = stripHtmlEntities;\r\n// Given a hash of CSS properties, returns a string of CSS.\r\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\r\nfunction cssToStr(cssProps) {\r\n    var statements = [];\r\n    $.each(cssProps, function (name, val) {\r\n        if (val != null) {\r\n            statements.push(name + ':' + val);\r\n        }\r\n    });\r\n    return statements.join(';');\r\n}\r\nexports.cssToStr = cssToStr;\r\n// Given an object hash of HTML attribute names to values,\r\n// generates a string that can be injected between < > in HTML\r\nfunction attrsToStr(attrs) {\r\n    var parts = [];\r\n    $.each(attrs, function (name, val) {\r\n        if (val != null) {\r\n            parts.push(name + '=\"' + htmlEscape(val) + '\"');\r\n        }\r\n    });\r\n    return parts.join(' ');\r\n}\r\nexports.attrsToStr = attrsToStr;\r\nfunction capitaliseFirstLetter(str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\nexports.capitaliseFirstLetter = capitaliseFirstLetter;\r\nfunction compareNumbers(a, b) {\r\n    return a - b;\r\n}\r\nexports.compareNumbers = compareNumbers;\r\nfunction isInt(n) {\r\n    return n % 1 === 0;\r\n}\r\nexports.isInt = isInt;\r\n// Returns a method bound to the given object context.\r\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\r\n// different contexts as identical when binding/unbinding events.\r\nfunction proxy(obj, methodName) {\r\n    var method = obj[methodName];\r\n    return function () {\r\n        return method.apply(obj, arguments);\r\n    };\r\n}\r\nexports.proxy = proxy;\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\r\nfunction debounce(func, wait, immediate) {\r\n    if (immediate === void 0) { immediate = false; }\r\n    var timeout;\r\n    var args;\r\n    var context;\r\n    var timestamp;\r\n    var result;\r\n    var later = function () {\r\n        var last = +new Date() - timestamp;\r\n        if (last < wait) {\r\n            timeout = setTimeout(later, wait - last);\r\n        }\r\n        else {\r\n            timeout = null;\r\n            if (!immediate) {\r\n                result = func.apply(context, args);\r\n                context = args = null;\r\n            }\r\n        }\r\n    };\r\n    return function () {\r\n        context = this;\r\n        args = arguments;\r\n        timestamp = +new Date();\r\n        var callNow = immediate && !timeout;\r\n        if (!timeout) {\r\n            timeout = setTimeout(later, wait);\r\n        }\r\n        if (callNow) {\r\n            result = func.apply(context, args);\r\n            context = args = null;\r\n        }\r\n        return result;\r\n    };\r\n}\r\nexports.debounce = debounce;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar UnzonedRange = /** @class */ (function () {\r\n    function UnzonedRange(startInput, endInput) {\r\n        // TODO: move these into footprint.\r\n        // Especially, doesn't make sense for null startMs/endMs.\r\n        this.isStart = true;\r\n        this.isEnd = true;\r\n        if (moment.isMoment(startInput)) {\r\n            startInput = startInput.clone().stripZone();\r\n        }\r\n        if (moment.isMoment(endInput)) {\r\n            endInput = endInput.clone().stripZone();\r\n        }\r\n        if (startInput) {\r\n            this.startMs = startInput.valueOf();\r\n        }\r\n        if (endInput) {\r\n            this.endMs = endInput.valueOf();\r\n        }\r\n    }\r\n    /*\r\n    SIDEEFFECT: will mutate eventRanges.\r\n    Will return a new array result.\r\n    Only works for non-open-ended ranges.\r\n    */\r\n    UnzonedRange.invertRanges = function (ranges, constraintRange) {\r\n        var invertedRanges = [];\r\n        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range\r\n        var i;\r\n        var dateRange;\r\n        // ranges need to be in order. required for our date-walking algorithm\r\n        ranges.sort(compareUnzonedRanges);\r\n        for (i = 0; i < ranges.length; i++) {\r\n            dateRange = ranges[i];\r\n            // add the span of time before the event (if there is any)\r\n            if (dateRange.startMs > startMs) {\r\n                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));\r\n            }\r\n            if (dateRange.endMs > startMs) {\r\n                startMs = dateRange.endMs;\r\n            }\r\n        }\r\n        // add the span of time after the last event (if there is any)\r\n        if (startMs < constraintRange.endMs) {\r\n            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));\r\n        }\r\n        return invertedRanges;\r\n    };\r\n    UnzonedRange.prototype.intersect = function (otherRange) {\r\n        var startMs = this.startMs;\r\n        var endMs = this.endMs;\r\n        var newRange = null;\r\n        if (otherRange.startMs != null) {\r\n            if (startMs == null) {\r\n                startMs = otherRange.startMs;\r\n            }\r\n            else {\r\n                startMs = Math.max(startMs, otherRange.startMs);\r\n            }\r\n        }\r\n        if (otherRange.endMs != null) {\r\n            if (endMs == null) {\r\n                endMs = otherRange.endMs;\r\n            }\r\n            else {\r\n                endMs = Math.min(endMs, otherRange.endMs);\r\n            }\r\n        }\r\n        if (startMs == null || endMs == null || startMs < endMs) {\r\n            newRange = new UnzonedRange(startMs, endMs);\r\n            newRange.isStart = this.isStart && startMs === this.startMs;\r\n            newRange.isEnd = this.isEnd && endMs === this.endMs;\r\n        }\r\n        return newRange;\r\n    };\r\n    UnzonedRange.prototype.intersectsWith = function (otherRange) {\r\n        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&\r\n            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);\r\n    };\r\n    UnzonedRange.prototype.containsRange = function (innerRange) {\r\n        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&\r\n            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));\r\n    };\r\n    // `date` can be a moment, a Date, or a millisecond time.\r\n    UnzonedRange.prototype.containsDate = function (date) {\r\n        var ms = date.valueOf();\r\n        return (this.startMs == null || ms >= this.startMs) &&\r\n            (this.endMs == null || ms < this.endMs);\r\n    };\r\n    // If the given date is not within the given range, move it inside.\r\n    // (If it's past the end, make it one millisecond before the end).\r\n    // `date` can be a moment, a Date, or a millisecond time.\r\n    // Returns a MS-time.\r\n    UnzonedRange.prototype.constrainDate = function (date) {\r\n        var ms = date.valueOf();\r\n        if (this.startMs != null && ms < this.startMs) {\r\n            ms = this.startMs;\r\n        }\r\n        if (this.endMs != null && ms >= this.endMs) {\r\n            ms = this.endMs - 1;\r\n        }\r\n        return ms;\r\n    };\r\n    UnzonedRange.prototype.equals = function (otherRange) {\r\n        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;\r\n    };\r\n    UnzonedRange.prototype.clone = function () {\r\n        var range = new UnzonedRange(this.startMs, this.endMs);\r\n        range.isStart = this.isStart;\r\n        range.isEnd = this.isEnd;\r\n        return range;\r\n    };\r\n    // Returns an ambig-zoned moment from startMs.\r\n    // BEWARE: returned moment is not localized.\r\n    // Formatting and start-of-week will be default.\r\n    UnzonedRange.prototype.getStart = function () {\r\n        if (this.startMs != null) {\r\n            return moment_ext_1.default.utc(this.startMs).stripZone();\r\n        }\r\n        return null;\r\n    };\r\n    // Returns an ambig-zoned moment from startMs.\r\n    // BEWARE: returned moment is not localized.\r\n    // Formatting and start-of-week will be default.\r\n    UnzonedRange.prototype.getEnd = function () {\r\n        if (this.endMs != null) {\r\n            return moment_ext_1.default.utc(this.endMs).stripZone();\r\n        }\r\n        return null;\r\n    };\r\n    UnzonedRange.prototype.as = function (unit) {\r\n        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);\r\n    };\r\n    return UnzonedRange;\r\n}());\r\nexports.default = UnzonedRange;\r\n/*\r\nOnly works for non-open-ended ranges.\r\n*/\r\nfunction compareUnzonedRanges(range1, range2) {\r\n    return range1.startMs - range2.startMs; // earlier ranges go first\r\n}\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar ParsableModelMixin_1 = __webpack_require__(208);\r\nvar Class_1 = __webpack_require__(33);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar EventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventSource, _super);\r\n    // can we do away with calendar? at least for the abstract?\r\n    // useful for buildEventDef\r\n    function EventSource(calendar) {\r\n        var _this = _super.call(this) || this;\r\n        _this.calendar = calendar;\r\n        _this.className = [];\r\n        _this.uid = String(EventSource.uuid++);\r\n        return _this;\r\n    }\r\n    /*\r\n    rawInput can be any data type!\r\n    */\r\n    EventSource.parse = function (rawInput, calendar) {\r\n        var source = new this(calendar);\r\n        if (typeof rawInput === 'object') {\r\n            if (source.applyProps(rawInput)) {\r\n                return source;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    EventSource.normalizeId = function (id) {\r\n        if (id) {\r\n            return String(id);\r\n        }\r\n        return null;\r\n    };\r\n    EventSource.prototype.fetch = function (start, end, timezone) {\r\n        // subclasses must implement. must return a promise.\r\n    };\r\n    EventSource.prototype.removeEventDefsById = function (eventDefId) {\r\n        // optional for subclasses to implement\r\n    };\r\n    EventSource.prototype.removeAllEventDefs = function () {\r\n        // optional for subclasses to implement\r\n    };\r\n    /*\r\n    For compairing/matching\r\n    */\r\n    EventSource.prototype.getPrimitive = function (otherSource) {\r\n        // subclasses must implement\r\n    };\r\n    EventSource.prototype.parseEventDefs = function (rawEventDefs) {\r\n        var i;\r\n        var eventDef;\r\n        var eventDefs = [];\r\n        for (i = 0; i < rawEventDefs.length; i++) {\r\n            eventDef = this.parseEventDef(rawEventDefs[i]);\r\n            if (eventDef) {\r\n                eventDefs.push(eventDef);\r\n            }\r\n        }\r\n        return eventDefs;\r\n    };\r\n    EventSource.prototype.parseEventDef = function (rawInput) {\r\n        var calendarTransform = this.calendar.opt('eventDataTransform');\r\n        var sourceTransform = this.eventDataTransform;\r\n        if (calendarTransform) {\r\n            rawInput = calendarTransform(rawInput, this.calendar);\r\n        }\r\n        if (sourceTransform) {\r\n            rawInput = sourceTransform(rawInput, this.calendar);\r\n        }\r\n        return EventDefParser_1.default.parse(rawInput, this);\r\n    };\r\n    EventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        if (rawProps.id != null) {\r\n            this.id = EventSource.normalizeId(rawProps.id);\r\n        }\r\n        // TODO: converge with EventDef\r\n        if ($.isArray(rawProps.className)) {\r\n            this.className = rawProps.className;\r\n        }\r\n        else if (typeof rawProps.className === 'string') {\r\n            this.className = rawProps.className.split(/\\s+/);\r\n        }\r\n        return true;\r\n    };\r\n    EventSource.uuid = 0;\r\n    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\r\n    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\r\n    return EventSource;\r\n}(Class_1.default));\r\nexports.default = EventSource;\r\nParsableModelMixin_1.default.mixInto(EventSource);\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nEventSource.defineStandardProps({\r\n    // manually process...\r\n    id: false,\r\n    className: false,\r\n    // automatically transfer...\r\n    color: true,\r\n    backgroundColor: true,\r\n    borderColor: true,\r\n    textColor: true,\r\n    editable: true,\r\n    startEditable: true,\r\n    durationEditable: true,\r\n    rendering: true,\r\n    overlap: true,\r\n    constraint: true,\r\n    allDayDefault: true,\r\n    eventDataTransform: true\r\n});\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUtility methods for easily listening to events on another object,\r\nand more importantly, easily unlistening from them.\r\n\nUSAGE:\r\n  import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'\r\nin class:\r\n  listenTo: ListenerInterface['listenTo']\r\n  stopListeningTo: ListenerInterface['stopListeningTo']\r\nafter class:\r\n  ListenerMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar guid = 0;\r\nvar ListenerMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListenerMixin, _super);\r\n    function ListenerMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\r\n    The `callback` will be called with the `this` context of the object that .listenTo is being called on.\r\n    Can be called:\r\n      .listenTo(other, eventName, callback)\r\n    OR\r\n      .listenTo(other, {\r\n        eventName1: callback1,\r\n        eventName2: callback2\r\n      })\r\n    */\r\n    ListenerMixin.prototype.listenTo = function (other, arg, callback) {\r\n        if (typeof arg === 'object') {\r\n            for (var eventName in arg) {\r\n                if (arg.hasOwnProperty(eventName)) {\r\n                    this.listenTo(other, eventName, arg[eventName]);\r\n                }\r\n            }\r\n        }\r\n        else if (typeof arg === 'string') {\r\n            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\r\n            $.proxy(callback, this) // always use `this` context\r\n            // the usually-undesired jQuery guid behavior doesn't matter,\r\n            // because we always unbind via namespace\r\n            );\r\n        }\r\n    };\r\n    /*\r\n    Causes the current object to stop listening to events on the `other` object.\r\n    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.\r\n    */\r\n    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {\r\n        other.off((eventName || '') + '.' + this.getListenerNamespace());\r\n    };\r\n    /*\r\n    Returns a string, unique to this object, to be used for event namespacing\r\n    */\r\n    ListenerMixin.prototype.getListenerNamespace = function () {\r\n        if (this.listenerId == null) {\r\n            this.listenerId = guid++;\r\n        }\r\n        return '_listener' + this.listenerId;\r\n    };\r\n    return ListenerMixin;\r\n}(Mixin_1.default));\r\nexports.default = ListenerMixin;\r\n\n\n/***/ }),\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\r\nvar ambigTimeOrZoneRegex = /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\r\nvar newMomentProto = moment.fn; // where we will attach our new methods\r\nexports.newMomentProto = newMomentProto;\r\nvar oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\r\nexports.oldMomentProto = oldMomentProto;\r\n// tell momentjs to transfer these properties upon clone\r\nvar momentProperties = moment.momentProperties;\r\nmomentProperties.push('_fullCalendar');\r\nmomentProperties.push('_ambigTime');\r\nmomentProperties.push('_ambigZone');\r\n/*\r\nCall this if you want Moment's original format method to be used\r\n*/\r\nfunction oldMomentFormat(mom, formatStr) {\r\n    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\r\n}\r\nexports.oldMomentFormat = oldMomentFormat;\r\n// Creating\r\n// -------------------------------------------------------------------------------------------------\r\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\r\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\r\n// it will function as a clone (and retain the zone of the moment). Anything else will\r\n// result in a moment in the local zone.\r\nvar momentExt = function () {\r\n    return makeMoment(arguments);\r\n};\r\nexports.default = momentExt;\r\n// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.\r\nmomentExt.utc = function () {\r\n    var mom = makeMoment(arguments, true);\r\n    // Force it into UTC because makeMoment doesn't guarantee it\r\n    // (if given a pre-existing moment for example)\r\n    if (mom.hasTime()) {\r\n        mom.utc();\r\n    }\r\n    return mom;\r\n};\r\n// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.\r\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\r\nmomentExt.parseZone = function () {\r\n    return makeMoment(arguments, true, true);\r\n};\r\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\r\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\r\n// Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\r\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\r\n//    parseZone - if there is zone information, should we force the zone of the moment?\r\nfunction makeMoment(args, parseAsUTC, parseZone) {\r\n    if (parseAsUTC === void 0) { parseAsUTC = false; }\r\n    if (parseZone === void 0) { parseZone = false; }\r\n    var input = args[0];\r\n    var isSingleString = args.length === 1 && typeof input === 'string';\r\n    var isAmbigTime;\r\n    var isAmbigZone;\r\n    var ambigMatch;\r\n    var mom;\r\n    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {\r\n        mom = moment.apply(null, args);\r\n    }\r\n    else {\r\n        isAmbigTime = false;\r\n        isAmbigZone = false;\r\n        if (isSingleString) {\r\n            if (ambigDateOfMonthRegex.test(input)) {\r\n                // accept strings like '2014-05', but convert to the first of the month\r\n                input += '-01';\r\n                args = [input]; // for when we pass it on to moment's constructor\r\n                isAmbigTime = true;\r\n                isAmbigZone = true;\r\n            }\r\n            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\r\n                isAmbigTime = !ambigMatch[5]; // no time part?\r\n                isAmbigZone = true;\r\n            }\r\n        }\r\n        else if ($.isArray(input)) {\r\n            // arrays have no timezone information, so assume ambiguous zone\r\n            isAmbigZone = true;\r\n        }\r\n        // otherwise, probably a string with a format\r\n        if (parseAsUTC || isAmbigTime) {\r\n            mom = moment.utc.apply(moment, args);\r\n        }\r\n        else {\r\n            mom = moment.apply(null, args);\r\n        }\r\n        if (isAmbigTime) {\r\n            mom._ambigTime = true;\r\n            mom._ambigZone = true; // ambiguous time always means ambiguous zone\r\n        }\r\n        else if (parseZone) {\r\n            if (isAmbigZone) {\r\n                mom._ambigZone = true;\r\n            }\r\n            else if (isSingleString) {\r\n                mom.utcOffset(input); // if not a valid zone, will assign UTC\r\n            }\r\n        }\r\n    }\r\n    mom._fullCalendar = true; // flag for extended functionality\r\n    return mom;\r\n}\r\n// Week Number\r\n// -------------------------------------------------------------------------------------------------\r\n// Returns the week number, considering the locale's custom week number calcuation\r\n// `weeks` is an alias for `week`\r\nnewMomentProto.week = newMomentProto.weeks = function (input) {\r\n    var weekCalc = this._locale._fullCalendar_weekCalc;\r\n    if (input == null && typeof weekCalc === 'function') {\r\n        return weekCalc(this);\r\n    }\r\n    else if (weekCalc === 'ISO') {\r\n        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\r\n    }\r\n    return oldMomentProto.week.apply(this, arguments); // local getter/setter\r\n};\r\n// Time-of-day\r\n// -------------------------------------------------------------------------------------------------\r\n// GETTER\r\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\r\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\r\n//\r\n// SETTER\r\n// You can supply a Duration, a Moment, or a Duration-like argument.\r\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\r\nnewMomentProto.time = function (time) {\r\n    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\r\n    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\r\n    if (!this._fullCalendar) {\r\n        return oldMomentProto.time.apply(this, arguments);\r\n    }\r\n    if (time == null) {\r\n        return moment.duration({\r\n            hours: this.hours(),\r\n            minutes: this.minutes(),\r\n            seconds: this.seconds(),\r\n            milliseconds: this.milliseconds()\r\n        });\r\n    }\r\n    else {\r\n        this._ambigTime = false; // mark that the moment now has a time\r\n        if (!moment.isDuration(time) && !moment.isMoment(time)) {\r\n            time = moment.duration(time);\r\n        }\r\n        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\r\n        // Only for Duration times, not Moment times.\r\n        var dayHours = 0;\r\n        if (moment.isDuration(time)) {\r\n            dayHours = Math.floor(time.asDays()) * 24;\r\n        }\r\n        // We need to set the individual fields.\r\n        // Can't use startOf('day') then add duration. In case of DST at start of day.\r\n        return this.hours(dayHours + time.hours())\r\n            .minutes(time.minutes())\r\n            .seconds(time.seconds())\r\n            .milliseconds(time.milliseconds());\r\n    }\r\n};\r\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\r\n// but preserving its YMD. A moment with a stripped time will display no time\r\n// nor timezone offset when .format() is called.\r\nnewMomentProto.stripTime = function () {\r\n    if (!this._ambigTime) {\r\n        this.utc(true); // keepLocalTime=true (for keeping *date* value)\r\n        // set time to zero\r\n        this.set({\r\n            hours: 0,\r\n            minutes: 0,\r\n            seconds: 0,\r\n            ms: 0\r\n        });\r\n        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n        // which clears all ambig flags.\r\n        this._ambigTime = true;\r\n        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\r\n    }\r\n    return this; // for chaining\r\n};\r\n// Returns if the moment has a non-ambiguous time (boolean)\r\nnewMomentProto.hasTime = function () {\r\n    return !this._ambigTime;\r\n};\r\n// Timezone\r\n// -------------------------------------------------------------------------------------------------\r\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\r\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\r\n// timezone offset when .format() is called.\r\nnewMomentProto.stripZone = function () {\r\n    var wasAmbigTime;\r\n    if (!this._ambigZone) {\r\n        wasAmbigTime = this._ambigTime;\r\n        this.utc(true); // keepLocalTime=true (for keeping date and time values)\r\n        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\r\n        this._ambigTime = wasAmbigTime || false;\r\n        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n        // which clears the ambig flags.\r\n        this._ambigZone = true;\r\n    }\r\n    return this; // for chaining\r\n};\r\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\r\nnewMomentProto.hasZone = function () {\r\n    return !this._ambigZone;\r\n};\r\n// implicitly marks a zone\r\nnewMomentProto.local = function (keepLocalTime) {\r\n    // for when converting from ambiguously-zoned to local,\r\n    // keep the time values when converting from UTC -> local\r\n    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\r\n    // ensure non-ambiguous\r\n    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\r\n    this._ambigTime = false;\r\n    this._ambigZone = false;\r\n    return this; // for chaining\r\n};\r\n// implicitly marks a zone\r\nnewMomentProto.utc = function (keepLocalTime) {\r\n    oldMomentProto.utc.call(this, keepLocalTime);\r\n    // ensure non-ambiguous\r\n    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\r\n    this._ambigTime = false;\r\n    this._ambigZone = false;\r\n    return this;\r\n};\r\n// implicitly marks a zone (will probably get called upon .utc() and .local())\r\nnewMomentProto.utcOffset = function (tzo) {\r\n    if (tzo != null) {\r\n        // these assignments needs to happen before the original zone method is called.\r\n        // I forget why, something to do with a browser crash.\r\n        this._ambigTime = false;\r\n        this._ambigZone = false;\r\n    }\r\n    return oldMomentProto.utcOffset.apply(this, arguments);\r\n};\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUSAGE:\r\n  import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'\r\nin class:\r\n  on: EmitterInterface['on']\r\n  one: EmitterInterface['one']\r\n  off: EmitterInterface['off']\r\n  trigger: EmitterInterface['trigger']\r\n  triggerWith: EmitterInterface['triggerWith']\r\n  hasHandlers: EmitterInterface['hasHandlers']\r\nafter class:\r\n  EmitterMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar EmitterMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EmitterMixin, _super);\r\n    function EmitterMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // jQuery-ification via $(this) allows a non-DOM object to have\r\n    // the same event handling capabilities (including namespaces).\r\n    EmitterMixin.prototype.on = function (types, handler) {\r\n        $(this).on(types, this._prepareIntercept(handler));\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.one = function (types, handler) {\r\n        $(this).one(types, this._prepareIntercept(handler));\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype._prepareIntercept = function (handler) {\r\n        // handlers are always called with an \"event\" object as their first param.\r\n        // sneak the `this` context and arguments into the extra parameter object\r\n        // and forward them on to the original handler.\r\n        var intercept = function (ev, extra) {\r\n            return handler.apply(extra.context || this, extra.args || []);\r\n        };\r\n        // mimick jQuery's internal \"proxy\" system (risky, I know)\r\n        // causing all functions with the same .guid to appear to be the same.\r\n        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\r\n        // this is needed for calling .off with the original non-intercept handler.\r\n        if (!handler.guid) {\r\n            handler.guid = $.guid++;\r\n        }\r\n        intercept.guid = handler.guid;\r\n        return intercept;\r\n    };\r\n    EmitterMixin.prototype.off = function (types, handler) {\r\n        $(this).off(types, handler);\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.trigger = function (types) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        // pass in \"extra\" info to the intercept\r\n        $(this).triggerHandler(types, { args: args });\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.triggerWith = function (types, context, args) {\r\n        // `triggerHandler` is less reliant on the DOM compared to `trigger`.\r\n        // pass in \"extra\" info to the intercept.\r\n        $(this).triggerHandler(types, { context: context, args: args });\r\n        return this; // for chaining\r\n    };\r\n    EmitterMixin.prototype.hasHandlers = function (type) {\r\n        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/\r\n        return hash && hash[type] && hash[type].length > 0;\r\n    };\r\n    return EmitterMixin;\r\n}(Mixin_1.default));\r\nexports.default = EmitterMixin;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar ComponentFootprint = /** @class */ (function () {\r\n    function ComponentFootprint(unzonedRange, isAllDay) {\r\n        this.isAllDay = false; // component can choose to ignore this\r\n        this.unzonedRange = unzonedRange;\r\n        this.isAllDay = isAllDay;\r\n    }\r\n    /*\r\n    Only works for non-open-ended ranges.\r\n    */\r\n    ComponentFootprint.prototype.toLegacy = function (calendar) {\r\n        return {\r\n            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),\r\n            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)\r\n        };\r\n    };\r\n    return ComponentFootprint;\r\n}());\r\nexports.default = ComponentFootprint;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventInstance_1 = __webpack_require__(209);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar SingleEventDef = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SingleEventDef, _super);\r\n    function SingleEventDef() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    Will receive start/end params, but will be ignored.\r\n    */\r\n    SingleEventDef.prototype.buildInstances = function () {\r\n        return [this.buildInstance()];\r\n    };\r\n    SingleEventDef.prototype.buildInstance = function () {\r\n        return new EventInstance_1.default(this, // definition\r\n        this.dateProfile);\r\n    };\r\n    SingleEventDef.prototype.isAllDay = function () {\r\n        return this.dateProfile.isAllDay();\r\n    };\r\n    SingleEventDef.prototype.clone = function () {\r\n        var def = _super.prototype.clone.call(this);\r\n        def.dateProfile = this.dateProfile;\r\n        return def;\r\n    };\r\n    SingleEventDef.prototype.rezone = function () {\r\n        var calendar = this.source.calendar;\r\n        var dateProfile = this.dateProfile;\r\n        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);\r\n    };\r\n    /*\r\n    NOTE: if super-method fails, should still attempt to apply\r\n    */\r\n    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure\r\n        if (dateProfile) {\r\n            this.dateProfile = dateProfile;\r\n            // make sure `date` shows up in the legacy event objects as-is\r\n            if (rawProps.date != null) {\r\n                this.miscProps.date = rawProps.date;\r\n            }\r\n            return superSuccess;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    return SingleEventDef;\r\n}(EventDef_1.default));\r\nexports.default = SingleEventDef;\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nSingleEventDef.defineStandardProps({\r\n    start: false,\r\n    date: false,\r\n    end: false,\r\n    allDay: false\r\n});\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Mixin = /** @class */ (function () {\r\n    function Mixin() {\r\n    }\r\n    Mixin.mixInto = function (destClass) {\r\n        var _this = this;\r\n        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\r\n            if (!destClass.prototype[name]) {\r\n                destClass.prototype[name] = _this.prototype[name];\r\n            }\r\n        });\r\n    };\r\n    /*\r\n    will override existing methods\r\n    TODO: remove! not used anymore\r\n    */\r\n    Mixin.mixOver = function (destClass) {\r\n        var _this = this;\r\n        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {\r\n            destClass.prototype[name] = _this.prototype[name];\r\n        });\r\n    };\r\n    return Mixin;\r\n}());\r\nexports.default = Mixin;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Interaction = /** @class */ (function () {\r\n    function Interaction(component) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n    }\r\n    Interaction.prototype.opt = function (name) {\r\n        return this.view.opt(name);\r\n    };\r\n    Interaction.prototype.end = function () {\r\n        // subclasses can implement\r\n    };\r\n    return Interaction;\r\n}());\r\nexports.default = Interaction;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.version = '3.9.0';\r\n// When introducing internal API incompatibilities (where fullcalendar plugins would break),\r\n// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\r\n// and the below integer should be incremented.\r\nexports.internalApiVersion = 12;\r\nvar util_1 = __webpack_require__(4);\r\nexports.applyAll = util_1.applyAll;\r\nexports.debounce = util_1.debounce;\r\nexports.isInt = util_1.isInt;\r\nexports.htmlEscape = util_1.htmlEscape;\r\nexports.cssToStr = util_1.cssToStr;\r\nexports.proxy = util_1.proxy;\r\nexports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;\r\nexports.getOuterRect = util_1.getOuterRect;\r\nexports.getClientRect = util_1.getClientRect;\r\nexports.getContentRect = util_1.getContentRect;\r\nexports.getScrollbarWidths = util_1.getScrollbarWidths;\r\nexports.preventDefault = util_1.preventDefault;\r\nexports.parseFieldSpecs = util_1.parseFieldSpecs;\r\nexports.compareByFieldSpecs = util_1.compareByFieldSpecs;\r\nexports.compareByFieldSpec = util_1.compareByFieldSpec;\r\nexports.flexibleCompare = util_1.flexibleCompare;\r\nexports.computeGreatestUnit = util_1.computeGreatestUnit;\r\nexports.divideRangeByDuration = util_1.divideRangeByDuration;\r\nexports.divideDurationByDuration = util_1.divideDurationByDuration;\r\nexports.multiplyDuration = util_1.multiplyDuration;\r\nexports.durationHasTime = util_1.durationHasTime;\r\nexports.log = util_1.log;\r\nexports.warn = util_1.warn;\r\nexports.removeExact = util_1.removeExact;\r\nexports.intersectRects = util_1.intersectRects;\r\nvar date_formatting_1 = __webpack_require__(47);\r\nexports.formatDate = date_formatting_1.formatDate;\r\nexports.formatRange = date_formatting_1.formatRange;\r\nexports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;\r\nvar locale_1 = __webpack_require__(31);\r\nexports.datepickerLocale = locale_1.datepickerLocale;\r\nexports.locale = locale_1.locale;\r\nvar moment_ext_1 = __webpack_require__(10);\r\nexports.moment = moment_ext_1.default;\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nexports.EmitterMixin = EmitterMixin_1.default;\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nexports.ListenerMixin = ListenerMixin_1.default;\r\nvar Model_1 = __webpack_require__(48);\r\nexports.Model = Model_1.default;\r\nvar Constraints_1 = __webpack_require__(207);\r\nexports.Constraints = Constraints_1.default;\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nexports.UnzonedRange = UnzonedRange_1.default;\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nexports.ComponentFootprint = ComponentFootprint_1.default;\r\nvar BusinessHourGenerator_1 = __webpack_require__(212);\r\nexports.BusinessHourGenerator = BusinessHourGenerator_1.default;\r\nvar EventDef_1 = __webpack_require__(34);\r\nexports.EventDef = EventDef_1.default;\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nexports.EventDefMutation = EventDefMutation_1.default;\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nexports.EventSourceParser = EventSourceParser_1.default;\r\nvar EventSource_1 = __webpack_require__(6);\r\nexports.EventSource = EventSource_1.default;\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nexports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem;\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nexports.EventInstanceGroup = EventInstanceGroup_1.default;\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nexports.ArrayEventSource = ArrayEventSource_1.default;\r\nvar FuncEventSource_1 = __webpack_require__(215);\r\nexports.FuncEventSource = FuncEventSource_1.default;\r\nvar JsonFeedEventSource_1 = __webpack_require__(216);\r\nexports.JsonFeedEventSource = JsonFeedEventSource_1.default;\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nexports.EventFootprint = EventFootprint_1.default;\r\nvar Class_1 = __webpack_require__(33);\r\nexports.Class = Class_1.default;\r\nvar Mixin_1 = __webpack_require__(14);\r\nexports.Mixin = Mixin_1.default;\r\nvar CoordCache_1 = __webpack_require__(53);\r\nexports.CoordCache = CoordCache_1.default;\r\nvar DragListener_1 = __webpack_require__(54);\r\nexports.DragListener = DragListener_1.default;\r\nvar Promise_1 = __webpack_require__(20);\r\nexports.Promise = Promise_1.default;\r\nvar TaskQueue_1 = __webpack_require__(217);\r\nexports.TaskQueue = TaskQueue_1.default;\r\nvar RenderQueue_1 = __webpack_require__(218);\r\nexports.RenderQueue = RenderQueue_1.default;\r\nvar Scroller_1 = __webpack_require__(39);\r\nexports.Scroller = Scroller_1.default;\r\nvar Theme_1 = __webpack_require__(19);\r\nexports.Theme = Theme_1.default;\r\nvar DateComponent_1 = __webpack_require__(219);\r\nexports.DateComponent = DateComponent_1.default;\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nexports.InteractiveDateComponent = InteractiveDateComponent_1.default;\r\nvar Calendar_1 = __webpack_require__(220);\r\nexports.Calendar = Calendar_1.default;\r\nvar View_1 = __webpack_require__(41);\r\nexports.View = View_1.default;\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nexports.defineView = ViewRegistry_1.defineView;\r\nexports.getViewConfig = ViewRegistry_1.getViewConfig;\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nexports.DayTableMixin = DayTableMixin_1.default;\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nexports.BusinessHourRenderer = BusinessHourRenderer_1.default;\r\nvar EventRenderer_1 = __webpack_require__(42);\r\nexports.EventRenderer = EventRenderer_1.default;\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nexports.FillRenderer = FillRenderer_1.default;\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nexports.HelperRenderer = HelperRenderer_1.default;\r\nvar ExternalDropping_1 = __webpack_require__(222);\r\nexports.ExternalDropping = ExternalDropping_1.default;\r\nvar EventResizing_1 = __webpack_require__(223);\r\nexports.EventResizing = EventResizing_1.default;\r\nvar EventPointing_1 = __webpack_require__(59);\r\nexports.EventPointing = EventPointing_1.default;\r\nvar EventDragging_1 = __webpack_require__(224);\r\nexports.EventDragging = EventDragging_1.default;\r\nvar DateSelecting_1 = __webpack_require__(225);\r\nexports.DateSelecting = DateSelecting_1.default;\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nexports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;\r\nvar AgendaView_1 = __webpack_require__(226);\r\nexports.AgendaView = AgendaView_1.default;\r\nvar TimeGrid_1 = __webpack_require__(227);\r\nexports.TimeGrid = TimeGrid_1.default;\r\nvar DayGrid_1 = __webpack_require__(61);\r\nexports.DayGrid = DayGrid_1.default;\r\nvar BasicView_1 = __webpack_require__(62);\r\nexports.BasicView = BasicView_1.default;\r\nvar MonthView_1 = __webpack_require__(229);\r\nexports.MonthView = MonthView_1.default;\r\nvar ListView_1 = __webpack_require__(230);\r\nexports.ListView = ListView_1.default;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar EventDateProfile = /** @class */ (function () {\r\n    function EventDateProfile(start, end, calendar) {\r\n        this.start = start;\r\n        this.end = end || null;\r\n        this.unzonedRange = this.buildUnzonedRange(calendar);\r\n    }\r\n    /*\r\n    Needs an EventSource object\r\n    */\r\n    EventDateProfile.parse = function (rawProps, source) {\r\n        var startInput = rawProps.start || rawProps.date;\r\n        var endInput = rawProps.end;\r\n        if (!startInput) {\r\n            return false;\r\n        }\r\n        var calendar = source.calendar;\r\n        var start = calendar.moment(startInput);\r\n        var end = endInput ? calendar.moment(endInput) : null;\r\n        var forcedAllDay = rawProps.allDay;\r\n        var forceEventDuration = calendar.opt('forceEventDuration');\r\n        if (!start.isValid()) {\r\n            return false;\r\n        }\r\n        if (end && (!end.isValid() || !end.isAfter(start))) {\r\n            end = null;\r\n        }\r\n        if (forcedAllDay == null) {\r\n            forcedAllDay = source.allDayDefault;\r\n            if (forcedAllDay == null) {\r\n                forcedAllDay = calendar.opt('allDayDefault');\r\n            }\r\n        }\r\n        if (forcedAllDay === true) {\r\n            start.stripTime();\r\n            if (end) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        else if (forcedAllDay === false) {\r\n            if (!start.hasTime()) {\r\n                start.time(0);\r\n            }\r\n            if (end && !end.hasTime()) {\r\n                end.time(0);\r\n            }\r\n        }\r\n        if (!end && forceEventDuration) {\r\n            end = calendar.getDefaultEventEnd(!start.hasTime(), start);\r\n        }\r\n        return new EventDateProfile(start, end, calendar);\r\n    };\r\n    EventDateProfile.isStandardProp = function (propName) {\r\n        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';\r\n    };\r\n    EventDateProfile.prototype.isAllDay = function () {\r\n        return !(this.start.hasTime() || (this.end && this.end.hasTime()));\r\n    };\r\n    /*\r\n    Needs a Calendar object\r\n    */\r\n    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {\r\n        var startMs = this.start.clone().stripZone().valueOf();\r\n        var endMs = this.getEnd(calendar).stripZone().valueOf();\r\n        return new UnzonedRange_1.default(startMs, endMs);\r\n    };\r\n    /*\r\n    Needs a Calendar object\r\n    */\r\n    EventDateProfile.prototype.getEnd = function (calendar) {\r\n        return this.end ?\r\n            this.end.clone() :\r\n            // derive the end from the start and allDay. compute allDay if necessary\r\n            calendar.getDefaultEventEnd(this.isAllDay(), this.start);\r\n    };\r\n    return EventDateProfile;\r\n}());\r\nexports.default = EventDateProfile;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar util_1 = __webpack_require__(35);\r\nvar EventRange_1 = __webpack_require__(211);\r\n/*\r\nIt's expected that there will be at least one EventInstance,\r\nOR that an explicitEventDef is assigned.\r\n*/\r\nvar EventInstanceGroup = /** @class */ (function () {\r\n    function EventInstanceGroup(eventInstances) {\r\n        this.eventInstances = eventInstances || [];\r\n    }\r\n    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {\r\n        if (constraintRange) {\r\n            return this.sliceNormalRenderRanges(constraintRange);\r\n        }\r\n        else {\r\n            return this.eventInstances.map(util_1.eventInstanceToEventRange);\r\n        }\r\n    };\r\n    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {\r\n        if (this.isInverse()) {\r\n            return this.sliceInverseRenderRanges(constraintRange);\r\n        }\r\n        else {\r\n            return this.sliceNormalRenderRanges(constraintRange);\r\n        }\r\n    };\r\n    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {\r\n        var eventInstances = this.eventInstances;\r\n        var i;\r\n        var eventInstance;\r\n        var slicedRange;\r\n        var slicedEventRanges = [];\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            eventInstance = eventInstances[i];\r\n            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);\r\n            if (slicedRange) {\r\n                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));\r\n            }\r\n        }\r\n        return slicedEventRanges;\r\n    };\r\n    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {\r\n        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);\r\n        var ownerDef = this.getEventDef();\r\n        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);\r\n        return unzonedRanges.map(function (unzonedRange) {\r\n            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance\r\n        });\r\n    };\r\n    EventInstanceGroup.prototype.isInverse = function () {\r\n        return this.getEventDef().hasInverseRendering();\r\n    };\r\n    EventInstanceGroup.prototype.getEventDef = function () {\r\n        return this.explicitEventDef || this.eventInstances[0].def;\r\n    };\r\n    return EventInstanceGroup;\r\n}());\r\nexports.default = EventInstanceGroup;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar Theme = /** @class */ (function () {\r\n    function Theme(optionsManager) {\r\n        this.optionsManager = optionsManager;\r\n        this.processIconOverride();\r\n    }\r\n    Theme.prototype.processIconOverride = function () {\r\n        if (this.iconOverrideOption) {\r\n            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));\r\n        }\r\n    };\r\n    Theme.prototype.setIconOverride = function (iconOverrideHash) {\r\n        var iconClassesCopy;\r\n        var buttonName;\r\n        if ($.isPlainObject(iconOverrideHash)) {\r\n            iconClassesCopy = $.extend({}, this.iconClasses);\r\n            for (buttonName in iconOverrideHash) {\r\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\r\n            }\r\n            this.iconClasses = iconClassesCopy;\r\n        }\r\n        else if (iconOverrideHash === false) {\r\n            this.iconClasses = {};\r\n        }\r\n    };\r\n    Theme.prototype.applyIconOverridePrefix = function (className) {\r\n        var prefix = this.iconOverridePrefix;\r\n        if (prefix && className.indexOf(prefix) !== 0) {\r\n            className = prefix + className;\r\n        }\r\n        return className;\r\n    };\r\n    Theme.prototype.getClass = function (key) {\r\n        return this.classes[key] || '';\r\n    };\r\n    Theme.prototype.getIconClass = function (buttonName) {\r\n        var className = this.iconClasses[buttonName];\r\n        if (className) {\r\n            return this.baseIconClass + ' ' + className;\r\n        }\r\n        return '';\r\n    };\r\n    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\r\n        var className;\r\n        if (this.iconOverrideCustomButtonOption) {\r\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\r\n            if (className) {\r\n                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n    return Theme;\r\n}());\r\nexports.default = Theme;\r\nTheme.prototype.classes = {};\r\nTheme.prototype.iconClasses = {};\r\nTheme.prototype.baseIconClass = '';\r\nTheme.prototype.iconOverridePrefix = '';\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar PromiseStub = {\r\n    construct: function (executor) {\r\n        var deferred = $.Deferred();\r\n        var promise = deferred.promise();\r\n        if (typeof executor === 'function') {\r\n            executor(function (val) {\r\n                deferred.resolve(val);\r\n                attachImmediatelyResolvingThen(promise, val);\r\n            }, function () {\r\n                deferred.reject();\r\n                attachImmediatelyRejectingThen(promise);\r\n            });\r\n        }\r\n        return promise;\r\n    },\r\n    resolve: function (val) {\r\n        var deferred = $.Deferred().resolve(val);\r\n        var promise = deferred.promise();\r\n        attachImmediatelyResolvingThen(promise, val);\r\n        return promise;\r\n    },\r\n    reject: function () {\r\n        var deferred = $.Deferred().reject();\r\n        var promise = deferred.promise();\r\n        attachImmediatelyRejectingThen(promise);\r\n        return promise;\r\n    }\r\n};\r\nexports.default = PromiseStub;\r\nfunction attachImmediatelyResolvingThen(promise, val) {\r\n    promise.then = function (onResolve) {\r\n        if (typeof onResolve === 'function') {\r\n            return PromiseStub.resolve(onResolve(val));\r\n        }\r\n        return promise;\r\n    };\r\n}\r\nfunction attachImmediatelyRejectingThen(promise) {\r\n    promise.then = function (onResolve, onReject) {\r\n        if (typeof onReject === 'function') {\r\n            onReject();\r\n        }\r\n        return promise;\r\n    };\r\n}\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar exportHooks = __webpack_require__(16);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nexportHooks.touchMouseIgnoreWait = 500;\r\nvar globalEmitter = null;\r\nvar neededCount = 0;\r\n/*\r\nListens to document and window-level user-interaction events, like touch events and mouse events,\r\nand fires these events as-is to whoever is observing a GlobalEmitter.\r\nBest when used as a singleton via GlobalEmitter.get()\r\n\nNormalizes mouse/touch events. For examples:\r\n- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\r\n- compensates for various buggy scenarios where a touchend does not fire\r\n*/\r\nvar GlobalEmitter = /** @class */ (function () {\r\n    function GlobalEmitter() {\r\n        this.isTouching = false;\r\n        this.mouseIgnoreDepth = 0;\r\n    }\r\n    // gets the singleton\r\n    GlobalEmitter.get = function () {\r\n        if (!globalEmitter) {\r\n            globalEmitter = new GlobalEmitter();\r\n            globalEmitter.bind();\r\n        }\r\n        return globalEmitter;\r\n    };\r\n    // called when an object knows it will need a GlobalEmitter in the near future.\r\n    GlobalEmitter.needed = function () {\r\n        GlobalEmitter.get(); // ensures globalEmitter\r\n        neededCount++;\r\n    };\r\n    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\r\n    GlobalEmitter.unneeded = function () {\r\n        neededCount--;\r\n        if (!neededCount) {\r\n            globalEmitter.unbind();\r\n            globalEmitter = null;\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.bind = function () {\r\n        var _this = this;\r\n        this.listenTo($(document), {\r\n            touchstart: this.handleTouchStart,\r\n            touchcancel: this.handleTouchCancel,\r\n            touchend: this.handleTouchEnd,\r\n            mousedown: this.handleMouseDown,\r\n            mousemove: this.handleMouseMove,\r\n            mouseup: this.handleMouseUp,\r\n            click: this.handleClick,\r\n            selectstart: this.handleSelectStart,\r\n            contextmenu: this.handleContextMenu\r\n        });\r\n        // because we need to call preventDefault\r\n        // because https://www.chromestatus.com/features/5093566007214080\r\n        // TODO: investigate performance because this is a global handler\r\n        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {\r\n            _this.handleTouchMove($.Event(ev));\r\n        }, { passive: false } // allows preventDefault()\r\n        );\r\n        // attach a handler to get called when ANY scroll action happens on the page.\r\n        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\r\n        // http://stackoverflow.com/a/32954565/96342\r\n        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {\r\n            _this.handleScroll($.Event(ev));\r\n        }, true // useCapture\r\n        );\r\n    };\r\n    GlobalEmitter.prototype.unbind = function () {\r\n        this.stopListeningTo($(document));\r\n        window.removeEventListener('touchmove', this.handleTouchMoveProxy);\r\n        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture\r\n        );\r\n    };\r\n    // Touch Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleTouchStart = function (ev) {\r\n        // if a previous touch interaction never ended with a touchend, then implicitly end it,\r\n        // but since a new touch interaction is about to begin, don't start the mouse ignore period.\r\n        this.stopTouch(ev, true); // skipMouseIgnore=true\r\n        this.isTouching = true;\r\n        this.trigger('touchstart', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleTouchMove = function (ev) {\r\n        if (this.isTouching) {\r\n            this.trigger('touchmove', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleTouchCancel = function (ev) {\r\n        if (this.isTouching) {\r\n            this.trigger('touchcancel', ev);\r\n            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\r\n            // If touchend fires later, it won't have any effect b/c isTouching will be false.\r\n            this.stopTouch(ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleTouchEnd = function (ev) {\r\n        this.stopTouch(ev);\r\n    };\r\n    // Mouse Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleMouseDown = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mousedown', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleMouseMove = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mousemove', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleMouseUp = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('mouseup', ev);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.handleClick = function (ev) {\r\n        if (!this.shouldIgnoreMouse()) {\r\n            this.trigger('click', ev);\r\n        }\r\n    };\r\n    // Misc Handlers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.handleSelectStart = function (ev) {\r\n        this.trigger('selectstart', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleContextMenu = function (ev) {\r\n        this.trigger('contextmenu', ev);\r\n    };\r\n    GlobalEmitter.prototype.handleScroll = function (ev) {\r\n        this.trigger('scroll', ev);\r\n    };\r\n    // Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {\r\n        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }\r\n        if (this.isTouching) {\r\n            this.isTouching = false;\r\n            this.trigger('touchend', ev);\r\n            if (!skipMouseIgnore) {\r\n                this.startTouchMouseIgnore();\r\n            }\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.startTouchMouseIgnore = function () {\r\n        var _this = this;\r\n        var wait = exportHooks.touchMouseIgnoreWait;\r\n        if (wait) {\r\n            this.mouseIgnoreDepth++;\r\n            setTimeout(function () {\r\n                _this.mouseIgnoreDepth--;\r\n            }, wait);\r\n        }\r\n    };\r\n    GlobalEmitter.prototype.shouldIgnoreMouse = function () {\r\n        return this.isTouching || Boolean(this.mouseIgnoreDepth);\r\n    };\r\n    return GlobalEmitter;\r\n}());\r\nexports.default = GlobalEmitter;\r\nListenerMixin_1.default.mixInto(GlobalEmitter);\r\nEmitterMixin_1.default.mixInto(GlobalEmitter);\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar exportHooks = __webpack_require__(16);\r\nexports.viewHash = {};\r\nexportHooks.views = exports.viewHash;\r\nfunction defineView(viewName, viewConfig) {\r\n    exports.viewHash[viewName] = viewConfig;\r\n}\r\nexports.defineView = defineView;\r\nfunction getViewConfig(viewName) {\r\n    return exports.viewHash[viewName];\r\n}\r\nexports.getViewConfig = getViewConfig;\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar DragListener_1 = __webpack_require__(54);\r\n/* Tracks mouse movements over a component and raises events about which hit the mouse is over.\r\n------------------------------------------------------------------------------------------------------------------------\r\noptions:\r\n- subjectEl\r\n- subjectCenter\r\n*/\r\nvar HitDragListener = /** @class */ (function (_super) {\r\n    tslib_1.__extends(HitDragListener, _super);\r\n    function HitDragListener(component, options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.component = component;\r\n        return _this;\r\n    }\r\n    // Called when drag listening starts (but a real drag has not necessarily began).\r\n    // ev might be undefined if dragging was started manually.\r\n    HitDragListener.prototype.handleInteractionStart = function (ev) {\r\n        var subjectEl = this.subjectEl;\r\n        var subjectRect;\r\n        var origPoint;\r\n        var point;\r\n        this.component.hitsNeeded();\r\n        this.computeScrollBounds(); // for autoscroll\r\n        if (ev) {\r\n            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };\r\n            point = origPoint;\r\n            // constrain the point to bounds of the element being dragged\r\n            if (subjectEl) {\r\n                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well\r\n                point = util_1.constrainPoint(point, subjectRect);\r\n            }\r\n            this.origHit = this.queryHit(point.left, point.top);\r\n            // treat the center of the subject as the collision point?\r\n            if (subjectEl && this.options.subjectCenter) {\r\n                // only consider the area the subject overlaps the hit. best for large subjects.\r\n                // TODO: skip this if hit didn't supply left/right/top/bottom\r\n                if (this.origHit) {\r\n                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||\r\n                        subjectRect; // in case there is no intersection\r\n                }\r\n                point = util_1.getRectCenter(subjectRect);\r\n            }\r\n            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint\r\n        }\r\n        else {\r\n            this.origHit = null;\r\n            this.coordAdjust = null;\r\n        }\r\n        // call the super-method. do it after origHit has been computed\r\n        _super.prototype.handleInteractionStart.call(this, ev);\r\n    };\r\n    // Called when the actual drag has started\r\n    HitDragListener.prototype.handleDragStart = function (ev) {\r\n        var hit;\r\n        _super.prototype.handleDragStart.call(this, ev);\r\n        // might be different from this.origHit if the min-distance is large\r\n        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\r\n        // report the initial hit the mouse is over\r\n        // especially important if no min-distance and drag starts immediately\r\n        if (hit) {\r\n            this.handleHitOver(hit);\r\n        }\r\n    };\r\n    // Called when the drag moves\r\n    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {\r\n        var hit;\r\n        _super.prototype.handleDrag.call(this, dx, dy, ev);\r\n        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));\r\n        if (!isHitsEqual(hit, this.hit)) {\r\n            if (this.hit) {\r\n                this.handleHitOut();\r\n            }\r\n            if (hit) {\r\n                this.handleHitOver(hit);\r\n            }\r\n        }\r\n    };\r\n    // Called when dragging has been stopped\r\n    HitDragListener.prototype.handleDragEnd = function (ev) {\r\n        this.handleHitDone();\r\n        _super.prototype.handleDragEnd.call(this, ev);\r\n    };\r\n    // Called when a the mouse has just moved over a new hit\r\n    HitDragListener.prototype.handleHitOver = function (hit) {\r\n        var isOrig = isHitsEqual(hit, this.origHit);\r\n        this.hit = hit;\r\n        this.trigger('hitOver', this.hit, isOrig, this.origHit);\r\n    };\r\n    // Called when the mouse has just moved out of a hit\r\n    HitDragListener.prototype.handleHitOut = function () {\r\n        if (this.hit) {\r\n            this.trigger('hitOut', this.hit);\r\n            this.handleHitDone();\r\n            this.hit = null;\r\n        }\r\n    };\r\n    // Called after a hitOut. Also called before a dragStop\r\n    HitDragListener.prototype.handleHitDone = function () {\r\n        if (this.hit) {\r\n            this.trigger('hitDone', this.hit);\r\n        }\r\n    };\r\n    // Called when the interaction ends, whether there was a real drag or not\r\n    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\r\n        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);\r\n        this.origHit = null;\r\n        this.hit = null;\r\n        this.component.hitsNotNeeded();\r\n    };\r\n    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n    HitDragListener.prototype.handleScrollEnd = function () {\r\n        _super.prototype.handleScrollEnd.call(this);\r\n        // hits' absolute positions will be in new places after a user's scroll.\r\n        // HACK for recomputing.\r\n        if (this.isDragging) {\r\n            this.component.releaseHits();\r\n            this.component.prepareHits();\r\n        }\r\n    };\r\n    // Gets the hit underneath the coordinates for the given mouse event\r\n    HitDragListener.prototype.queryHit = function (left, top) {\r\n        if (this.coordAdjust) {\r\n            left += this.coordAdjust.left;\r\n            top += this.coordAdjust.top;\r\n        }\r\n        return this.component.queryHit(left, top);\r\n    };\r\n    return HitDragListener;\r\n}(DragListener_1.default));\r\nexports.default = HitDragListener;\r\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\r\n// Two null values will be considered equal, as two \"out of the component\" states are the same.\r\nfunction isHitsEqual(hit0, hit1) {\r\n    if (!hit0 && !hit1) {\r\n        return true;\r\n    }\r\n    if (hit0 && hit1) {\r\n        return hit0.component === hit1.component &&\r\n            isHitPropsWithin(hit0, hit1) &&\r\n            isHitPropsWithin(hit1, hit0); // ensures all props are identical\r\n    }\r\n    return false;\r\n}\r\n// Returns true if all of subHit's non-standard properties are within superHit\r\nfunction isHitPropsWithin(subHit, superHit) {\r\n    for (var propName in subHit) {\r\n        if (!/^(component|left|right|top|bottom)$/.test(propName)) {\r\n            if (subHit[propName] !== superHit[propName]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n/***/ }),\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar exportHooks = __webpack_require__(16);\r\nvar options_1 = __webpack_require__(32);\r\nvar util_1 = __webpack_require__(4);\r\nexports.localeOptionHash = {};\r\nexportHooks.locales = exports.localeOptionHash;\r\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\r\n// configs, so make sure there are English fallbacks for these in the defaults file.\r\nvar dpComputableOptions = {\r\n    buttonText: function (dpOptions) {\r\n        return {\r\n            // the translations sometimes wrongly contain HTML entities\r\n            prev: util_1.stripHtmlEntities(dpOptions.prevText),\r\n            next: util_1.stripHtmlEntities(dpOptions.nextText),\r\n            today: util_1.stripHtmlEntities(dpOptions.currentText)\r\n        };\r\n    },\r\n    // Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\r\n    monthYearFormat: function (dpOptions) {\r\n        return dpOptions.showMonthAfterYear ?\r\n            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\r\n            'MMMM YYYY[' + dpOptions.yearSuffix + ']';\r\n    }\r\n};\r\nvar momComputableOptions = {\r\n    // Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\r\n    dayOfMonthFormat: function (momOptions, fcOptions) {\r\n        var format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\r\n        // strip the year off the edge, as well as other misc non-whitespace chars\r\n        format = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\r\n        if (fcOptions.isRTL) {\r\n            format += ' ddd'; // for RTL, add day-of-week to end\r\n        }\r\n        else {\r\n            format = 'ddd ' + format; // for LTR, add day-of-week to beginning\r\n        }\r\n        return format;\r\n    },\r\n    // Produces format strings like \"h:mma\" -> \"6:00pm\"\r\n    mediumTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\r\n    smallTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '(:mm)')\r\n            .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\r\n    extraSmallTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '(:mm)')\r\n            .replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\r\n    hourFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(':mm', '')\r\n            .replace(/(\\Wmm)$/, '') // like above, but for foreign locales\r\n            .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n    },\r\n    // Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\r\n    noMeridiemTimeFormat: function (momOptions) {\r\n        return momOptions.longDateFormat('LT')\r\n            .replace(/\\s*a$/i, ''); // remove trailing AM/PM\r\n    }\r\n};\r\n// options that should be computed off live calendar options (considers override options)\r\n// TODO: best place for this? related to locale?\r\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\r\nvar instanceComputableOptions = {\r\n    // Produces format strings for results like \"Mo 16\"\r\n    smallDayDateFormat: function (options) {\r\n        return options.isRTL ?\r\n            'D dd' :\r\n            'dd D';\r\n    },\r\n    // Produces format strings for results like \"Wk 5\"\r\n    weekFormat: function (options) {\r\n        return options.isRTL ?\r\n            'w[ ' + options.weekNumberTitle + ']' :\r\n            '[' + options.weekNumberTitle + ' ]w';\r\n    },\r\n    // Produces format strings for results like \"Wk5\"\r\n    smallWeekFormat: function (options) {\r\n        return options.isRTL ?\r\n            'w[' + options.weekNumberTitle + ']' :\r\n            '[' + options.weekNumberTitle + ']w';\r\n    }\r\n};\r\n// TODO: make these computable properties in optionsManager\r\nfunction populateInstanceComputableOptions(options) {\r\n    $.each(instanceComputableOptions, function (name, func) {\r\n        if (options[name] == null) {\r\n            options[name] = func(options);\r\n        }\r\n    });\r\n}\r\nexports.populateInstanceComputableOptions = populateInstanceComputableOptions;\r\n// Initialize jQuery UI datepicker translations while using some of the translations\r\n// Will set this as the default locales for datepicker.\r\nfunction datepickerLocale(localeCode, dpLocaleCode, dpOptions) {\r\n    // get the FullCalendar internal option hash for this locale. create if necessary\r\n    var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\r\n    // transfer some simple options from datepicker to fc\r\n    fcOptions.isRTL = dpOptions.isRTL;\r\n    fcOptions.weekNumberTitle = dpOptions.weekHeader;\r\n    // compute some more complex options from datepicker\r\n    $.each(dpComputableOptions, function (name, func) {\r\n        fcOptions[name] = func(dpOptions);\r\n    });\r\n    var jqDatePicker = $.datepicker;\r\n    // is jQuery UI Datepicker is on the page?\r\n    if (jqDatePicker) {\r\n        // Register the locale data.\r\n        // FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\r\n        // does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\r\n        // Make an alias so the locale can be referenced either way.\r\n        jqDatePicker.regional[dpLocaleCode] =\r\n            jqDatePicker.regional[localeCode] = // alias\r\n                dpOptions;\r\n        // Alias 'en' to the default locale data. Do this every time.\r\n        jqDatePicker.regional.en = jqDatePicker.regional[''];\r\n        // Set as Datepicker's global defaults.\r\n        jqDatePicker.setDefaults(dpOptions);\r\n    }\r\n}\r\nexports.datepickerLocale = datepickerLocale;\r\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\r\nfunction locale(localeCode, newFcOptions) {\r\n    var fcOptions;\r\n    var momOptions;\r\n    // get the FullCalendar internal option hash for this locale. create if necessary\r\n    fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});\r\n    // provided new options for this locales? merge them in\r\n    if (newFcOptions) {\r\n        fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);\r\n    }\r\n    // compute locale options that weren't defined.\r\n    // always do this. newFcOptions can be undefined when initializing from i18n file,\r\n    // so no way to tell if this is an initialization or a default-setting.\r\n    momOptions = getMomentLocaleData(localeCode); // will fall back to en\r\n    $.each(momComputableOptions, function (name, func) {\r\n        if (fcOptions[name] == null) {\r\n            fcOptions[name] = (func)(momOptions, fcOptions);\r\n        }\r\n    });\r\n    // set it as the default locale for FullCalendar\r\n    options_1.globalDefaults.locale = localeCode;\r\n}\r\nexports.locale = locale;\r\n// Returns moment's internal locale data. If doesn't exist, returns English.\r\nfunction getMomentLocaleData(localeCode) {\r\n    return moment.localeData(localeCode) || moment.localeData('en');\r\n}\r\nexports.getMomentLocaleData = getMomentLocaleData;\r\n// Initialize English by forcing computation of moment-derived options.\r\n// Also, sets it as the default.\r\nlocale('en', options_1.englishDefaults);\r\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nexports.globalDefaults = {\r\n    titleRangeSeparator: ' \\u2013 ',\r\n    monthYearFormat: 'MMMM YYYY',\r\n    defaultTimedEventDuration: '02:00:00',\r\n    defaultAllDayEventDuration: { days: 1 },\r\n    forceEventDuration: false,\r\n    nextDayThreshold: '09:00:00',\r\n    // display\r\n    columnHeader: true,\r\n    defaultView: 'month',\r\n    aspectRatio: 1.35,\r\n    header: {\r\n        left: 'title',\r\n        center: '',\r\n        right: 'today prev,next'\r\n    },\r\n    weekends: true,\r\n    weekNumbers: false,\r\n    weekNumberTitle: 'W',\r\n    weekNumberCalculation: 'local',\r\n    // editable: false,\r\n    // nowIndicator: false,\r\n    scrollTime: '06:00:00',\r\n    minTime: '00:00:00',\r\n    maxTime: '24:00:00',\r\n    showNonCurrentDates: true,\r\n    // event ajax\r\n    lazyFetching: true,\r\n    startParam: 'start',\r\n    endParam: 'end',\r\n    timezoneParam: 'timezone',\r\n    timezone: false,\r\n    // allDayDefault: undefined,\r\n    // locale\r\n    locale: null,\r\n    isRTL: false,\r\n    buttonText: {\r\n        prev: 'prev',\r\n        next: 'next',\r\n        prevYear: 'prev year',\r\n        nextYear: 'next year',\r\n        year: 'year',\r\n        today: 'today',\r\n        month: 'month',\r\n        week: 'week',\r\n        day: 'day'\r\n    },\r\n    // buttonIcons: null,\r\n    allDayText: 'all-day',\r\n    // allows setting a min-height to the event segment to prevent short events overlapping each other\r\n    agendaEventMinHeight: 0,\r\n    // jquery-ui theming\r\n    theme: false,\r\n    // themeButtonIcons: null,\r\n    // eventResizableFromStart: false,\r\n    dragOpacity: .75,\r\n    dragRevertDuration: 500,\r\n    dragScroll: true,\r\n    // selectable: false,\r\n    unselectAuto: true,\r\n    // selectMinDistance: 0,\r\n    dropAccept: '*',\r\n    eventOrder: 'title',\r\n    // eventRenderWait: null,\r\n    eventLimit: false,\r\n    eventLimitText: 'more',\r\n    eventLimitClick: 'popover',\r\n    dayPopoverFormat: 'LL',\r\n    handleWindowResize: true,\r\n    windowResizeDelay: 100,\r\n    longPressDelay: 1000\r\n};\r\nexports.englishDefaults = {\r\n    dayPopoverFormat: 'dddd, MMMM D'\r\n};\r\nexports.rtlDefaults = {\r\n    header: {\r\n        left: 'next,prev today',\r\n        center: '',\r\n        right: 'title'\r\n    },\r\n    buttonIcons: {\r\n        prev: 'right-single-arrow',\r\n        next: 'left-single-arrow',\r\n        prevYear: 'right-double-arrow',\r\n        nextYear: 'left-double-arrow'\r\n    },\r\n    themeButtonIcons: {\r\n        prev: 'circle-triangle-e',\r\n        next: 'circle-triangle-w',\r\n        nextYear: 'seek-prev',\r\n        prevYear: 'seek-next'\r\n    }\r\n};\r\nvar complexOptions = [\r\n    'header',\r\n    'footer',\r\n    'buttonText',\r\n    'buttonIcons',\r\n    'themeButtonIcons'\r\n];\r\n// Merges an array of option objects into a single object\r\nfunction mergeOptions(optionObjs) {\r\n    return util_1.mergeProps(optionObjs, complexOptions);\r\n}\r\nexports.mergeOptions = mergeOptions;\r\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\n// Class that all other classes will inherit from\r\nvar Class = /** @class */ (function () {\r\n    function Class() {\r\n    }\r\n    // Called on a class to create a subclass.\r\n    // LIMITATION: cannot provide a constructor!\r\n    Class.extend = function (members) {\r\n        var SubClass = /** @class */ (function (_super) {\r\n            tslib_1.__extends(SubClass, _super);\r\n            function SubClass() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            return SubClass;\r\n        }(this));\r\n        util_1.copyOwnProps(members, SubClass.prototype);\r\n        return SubClass;\r\n    };\r\n    // Adds new member variables/methods to the class's prototype.\r\n    // Can be called with another class, or a plain object hash containing new members.\r\n    Class.mixin = function (members) {\r\n        util_1.copyOwnProps(members, this.prototype);\r\n    };\r\n    return Class;\r\n}());\r\nexports.default = Class;\r\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar ParsableModelMixin_1 = __webpack_require__(208);\r\nvar EventDef = /** @class */ (function () {\r\n    function EventDef(source) {\r\n        this.source = source;\r\n        this.className = [];\r\n        this.miscProps = {};\r\n    }\r\n    EventDef.parse = function (rawInput, source) {\r\n        var def = new this(source);\r\n        if (def.applyProps(rawInput)) {\r\n            return def;\r\n        }\r\n        return false;\r\n    };\r\n    EventDef.normalizeId = function (id) {\r\n        return String(id);\r\n    };\r\n    EventDef.generateId = function () {\r\n        return '_fc' + (EventDef.uuid++);\r\n    };\r\n    EventDef.prototype.clone = function () {\r\n        var copy = new this.constructor(this.source);\r\n        copy.id = this.id;\r\n        copy.rawId = this.rawId;\r\n        copy.uid = this.uid; // not really unique anymore :(\r\n        EventDef.copyVerbatimStandardProps(this, copy);\r\n        copy.className = this.className.slice(); // copy\r\n        copy.miscProps = $.extend({}, this.miscProps);\r\n        return copy;\r\n    };\r\n    EventDef.prototype.hasInverseRendering = function () {\r\n        return this.getRendering() === 'inverse-background';\r\n    };\r\n    EventDef.prototype.hasBgRendering = function () {\r\n        var rendering = this.getRendering();\r\n        return rendering === 'inverse-background' || rendering === 'background';\r\n    };\r\n    EventDef.prototype.getRendering = function () {\r\n        if (this.rendering != null) {\r\n            return this.rendering;\r\n        }\r\n        return this.source.rendering;\r\n    };\r\n    EventDef.prototype.getConstraint = function () {\r\n        if (this.constraint != null) {\r\n            return this.constraint;\r\n        }\r\n        if (this.source.constraint != null) {\r\n            return this.source.constraint;\r\n        }\r\n        return this.source.calendar.opt('eventConstraint'); // what about View option?\r\n    };\r\n    EventDef.prototype.getOverlap = function () {\r\n        if (this.overlap != null) {\r\n            return this.overlap;\r\n        }\r\n        if (this.source.overlap != null) {\r\n            return this.source.overlap;\r\n        }\r\n        return this.source.calendar.opt('eventOverlap'); // what about View option?\r\n    };\r\n    EventDef.prototype.isStartExplicitlyEditable = function () {\r\n        if (this.startEditable != null) {\r\n            return this.startEditable;\r\n        }\r\n        return this.source.startEditable;\r\n    };\r\n    EventDef.prototype.isDurationExplicitlyEditable = function () {\r\n        if (this.durationEditable != null) {\r\n            return this.durationEditable;\r\n        }\r\n        return this.source.durationEditable;\r\n    };\r\n    EventDef.prototype.isExplicitlyEditable = function () {\r\n        if (this.editable != null) {\r\n            return this.editable;\r\n        }\r\n        return this.source.editable;\r\n    };\r\n    EventDef.prototype.toLegacy = function () {\r\n        var obj = $.extend({}, this.miscProps);\r\n        obj._id = this.uid;\r\n        obj.source = this.source;\r\n        obj.className = this.className.slice(); // copy\r\n        obj.allDay = this.isAllDay();\r\n        if (this.rawId != null) {\r\n            obj.id = this.rawId;\r\n        }\r\n        EventDef.copyVerbatimStandardProps(this, obj);\r\n        return obj;\r\n    };\r\n    EventDef.prototype.applyManualStandardProps = function (rawProps) {\r\n        if (rawProps.id != null) {\r\n            this.id = EventDef.normalizeId((this.rawId = rawProps.id));\r\n        }\r\n        else {\r\n            this.id = EventDef.generateId();\r\n        }\r\n        if (rawProps._id != null) {\r\n            this.uid = String(rawProps._id);\r\n        }\r\n        else {\r\n            this.uid = EventDef.generateId();\r\n        }\r\n        // TODO: converge with EventSource\r\n        if ($.isArray(rawProps.className)) {\r\n            this.className = rawProps.className;\r\n        }\r\n        if (typeof rawProps.className === 'string') {\r\n            this.className = rawProps.className.split(/\\s+/);\r\n        }\r\n        return true;\r\n    };\r\n    EventDef.prototype.applyMiscProps = function (rawProps) {\r\n        $.extend(this.miscProps, rawProps);\r\n    };\r\n    EventDef.uuid = 0;\r\n    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;\r\n    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;\r\n    return EventDef;\r\n}());\r\nexports.default = EventDef;\r\nParsableModelMixin_1.default.mixInto(EventDef);\r\nEventDef.defineStandardProps({\r\n    // not automatically assigned (`false`)\r\n    _id: false,\r\n    id: false,\r\n    className: false,\r\n    source: false,\r\n    // automatically assigned (`true`)\r\n    title: true,\r\n    url: true,\r\n    rendering: true,\r\n    constraint: true,\r\n    overlap: true,\r\n    editable: true,\r\n    startEditable: true,\r\n    durationEditable: true,\r\n    color: true,\r\n    backgroundColor: true,\r\n    borderColor: true,\r\n    textColor: true\r\n});\r\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventRange_1 = __webpack_require__(211);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nfunction eventDefsToEventInstances(eventDefs, unzonedRange) {\r\n    var eventInstances = [];\r\n    var i;\r\n    for (i = 0; i < eventDefs.length; i++) {\r\n        eventInstances.push.apply(eventInstances, // append\r\n        eventDefs[i].buildInstances(unzonedRange));\r\n    }\r\n    return eventInstances;\r\n}\r\nexports.eventDefsToEventInstances = eventDefsToEventInstances;\r\nfunction eventInstanceToEventRange(eventInstance) {\r\n    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);\r\n}\r\nexports.eventInstanceToEventRange = eventInstanceToEventRange;\r\nfunction eventRangeToEventFootprint(eventRange) {\r\n    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist\r\n    );\r\n}\r\nexports.eventRangeToEventFootprint = eventRangeToEventFootprint;\r\nfunction eventInstanceToUnzonedRange(eventInstance) {\r\n    return eventInstance.dateProfile.unzonedRange;\r\n}\r\nexports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;\r\nfunction eventFootprintToComponentFootprint(eventFootprint) {\r\n    return eventFootprint.componentFootprint;\r\n}\r\nexports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;\r\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventFootprint = /** @class */ (function () {\r\n    function EventFootprint(componentFootprint, eventDef, eventInstance) {\r\n        this.componentFootprint = componentFootprint;\r\n        this.eventDef = eventDef;\r\n        if (eventInstance) {\r\n            this.eventInstance = eventInstance;\r\n        }\r\n    }\r\n    EventFootprint.prototype.getEventLegacy = function () {\r\n        return (this.eventInstance || this.eventDef).toLegacy();\r\n    };\r\n    return EventFootprint;\r\n}());\r\nexports.default = EventFootprint;\r\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventDefMutation = /** @class */ (function () {\r\n    function EventDefMutation() {\r\n    }\r\n    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {\r\n        var eventDef = eventInstance.def;\r\n        var dateProps = {};\r\n        var standardProps = {};\r\n        var miscProps = {};\r\n        var verbatimStandardProps = {};\r\n        var eventDefId = null;\r\n        var className = null;\r\n        var propName;\r\n        var dateProfile;\r\n        var dateMutation;\r\n        var defMutation;\r\n        for (propName in rawProps) {\r\n            if (EventDateProfile_1.default.isStandardProp(propName)) {\r\n                dateProps[propName] = rawProps[propName];\r\n            }\r\n            else if (eventDef.isStandardProp(propName)) {\r\n                standardProps[propName] = rawProps[propName];\r\n            }\r\n            else if (eventDef.miscProps[propName] !== rawProps[propName]) {\r\n                miscProps[propName] = rawProps[propName];\r\n            }\r\n        }\r\n        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);\r\n        if (dateProfile) {\r\n            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);\r\n        }\r\n        if (standardProps.id !== eventDef.id) {\r\n            eventDefId = standardProps.id; // only apply if there's a change\r\n        }\r\n        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {\r\n            className = standardProps.className; // only apply if there's a change\r\n        }\r\n        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src\r\n        verbatimStandardProps // dest\r\n        );\r\n        defMutation = new EventDefMutation();\r\n        defMutation.eventDefId = eventDefId;\r\n        defMutation.className = className;\r\n        defMutation.verbatimStandardProps = verbatimStandardProps;\r\n        defMutation.miscProps = miscProps;\r\n        if (dateMutation) {\r\n            defMutation.dateMutation = dateMutation;\r\n        }\r\n        return defMutation;\r\n    };\r\n    /*\r\n    eventDef assumed to be a SingleEventDef.\r\n    returns an undo function.\r\n    */\r\n    EventDefMutation.prototype.mutateSingle = function (eventDef) {\r\n        var origDateProfile;\r\n        if (this.dateMutation) {\r\n            origDateProfile = eventDef.dateProfile;\r\n            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);\r\n        }\r\n        // can't undo\r\n        // TODO: more DRY with EventDef::applyManualStandardProps\r\n        if (this.eventDefId != null) {\r\n            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));\r\n        }\r\n        // can't undo\r\n        // TODO: more DRY with EventDef::applyManualStandardProps\r\n        if (this.className) {\r\n            eventDef.className = this.className;\r\n        }\r\n        // can't undo\r\n        if (this.verbatimStandardProps) {\r\n            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src\r\n            eventDef // dest\r\n            );\r\n        }\r\n        // can't undo\r\n        if (this.miscProps) {\r\n            eventDef.applyMiscProps(this.miscProps);\r\n        }\r\n        if (origDateProfile) {\r\n            return function () {\r\n                eventDef.dateProfile = origDateProfile;\r\n            };\r\n        }\r\n        else {\r\n            return function () { };\r\n        }\r\n    };\r\n    EventDefMutation.prototype.setDateMutation = function (dateMutation) {\r\n        if (dateMutation && !dateMutation.isEmpty()) {\r\n            this.dateMutation = dateMutation;\r\n        }\r\n        else {\r\n            this.dateMutation = null;\r\n        }\r\n    };\r\n    EventDefMutation.prototype.isEmpty = function () {\r\n        return !this.dateMutation;\r\n    };\r\n    return EventDefMutation;\r\n}());\r\nexports.default = EventDefMutation;\r\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = {\r\n    sourceClasses: [],\r\n    registerClass: function (EventSourceClass) {\r\n        this.sourceClasses.unshift(EventSourceClass); // give highest priority\r\n    },\r\n    parse: function (rawInput, calendar) {\r\n        var sourceClasses = this.sourceClasses;\r\n        var i;\r\n        var eventSource;\r\n        for (i = 0; i < sourceClasses.length; i++) {\r\n            eventSource = sourceClasses[i].parse(rawInput, calendar);\r\n            if (eventSource) {\r\n                return eventSource;\r\n            }\r\n        }\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Class_1 = __webpack_require__(33);\r\n/*\r\nEmbodies a div that has potential scrollbars\r\n*/\r\nvar Scroller = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Scroller, _super);\r\n    function Scroller(options) {\r\n        var _this = _super.call(this) || this;\r\n        options = options || {};\r\n        _this.overflowX = options.overflowX || options.overflow || 'auto';\r\n        _this.overflowY = options.overflowY || options.overflow || 'auto';\r\n        return _this;\r\n    }\r\n    Scroller.prototype.render = function () {\r\n        this.el = this.renderEl();\r\n        this.applyOverflow();\r\n    };\r\n    Scroller.prototype.renderEl = function () {\r\n        return (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\r\n    };\r\n    // sets to natural height, unlocks overflow\r\n    Scroller.prototype.clear = function () {\r\n        this.setHeight('auto');\r\n        this.applyOverflow();\r\n    };\r\n    Scroller.prototype.destroy = function () {\r\n        this.el.remove();\r\n    };\r\n    // Overflow\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Scroller.prototype.applyOverflow = function () {\r\n        this.scrollEl.css({\r\n            'overflow-x': this.overflowX,\r\n            'overflow-y': this.overflowY\r\n        });\r\n    };\r\n    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\r\n    // Useful for preserving scrollbar widths regardless of future resizes.\r\n    // Can pass in scrollbarWidths for optimization.\r\n    Scroller.prototype.lockOverflow = function (scrollbarWidths) {\r\n        var overflowX = this.overflowX;\r\n        var overflowY = this.overflowY;\r\n        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\r\n        if (overflowX === 'auto') {\r\n            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\r\n                // OR scrolling pane with massless scrollbars?\r\n                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';\r\n        }\r\n        if (overflowY === 'auto') {\r\n            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\r\n                // OR scrolling pane with massless scrollbars?\r\n                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';\r\n        }\r\n        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\r\n    };\r\n    // Getters / Setters\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Scroller.prototype.setHeight = function (height) {\r\n        this.scrollEl.height(height);\r\n    };\r\n    Scroller.prototype.getScrollTop = function () {\r\n        return this.scrollEl.scrollTop();\r\n    };\r\n    Scroller.prototype.setScrollTop = function (top) {\r\n        this.scrollEl.scrollTop(top);\r\n    };\r\n    Scroller.prototype.getClientWidth = function () {\r\n        return this.scrollEl[0].clientWidth;\r\n    };\r\n    Scroller.prototype.getClientHeight = function () {\r\n        return this.scrollEl[0].clientHeight;\r\n    };\r\n    Scroller.prototype.getScrollbarWidths = function () {\r\n        return util_1.getScrollbarWidths(this.scrollEl);\r\n    };\r\n    return Scroller;\r\n}(Class_1.default));\r\nexports.default = Scroller;\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar DateComponent_1 = __webpack_require__(219);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar InteractiveDateComponent = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InteractiveDateComponent, _super);\r\n    function InteractiveDateComponent(_view, _options) {\r\n        var _this = _super.call(this, _view, _options) || this;\r\n        // self-config, overridable by subclasses\r\n        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?\r\n        if (_this.dateSelectingClass) {\r\n            _this.dateClicking = new _this.dateClickingClass(_this);\r\n        }\r\n        if (_this.dateSelectingClass) {\r\n            _this.dateSelecting = new _this.dateSelectingClass(_this);\r\n        }\r\n        if (_this.eventPointingClass) {\r\n            _this.eventPointing = new _this.eventPointingClass(_this);\r\n        }\r\n        if (_this.eventDraggingClass && _this.eventPointing) {\r\n            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);\r\n        }\r\n        if (_this.eventResizingClass && _this.eventPointing) {\r\n            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);\r\n        }\r\n        if (_this.externalDroppingClass) {\r\n            _this.externalDropping = new _this.externalDroppingClass(_this);\r\n        }\r\n        return _this;\r\n    }\r\n    // Sets the container element that the view should render inside of, does global DOM-related initializations,\r\n    // and renders all the non-date-related content inside.\r\n    InteractiveDateComponent.prototype.setElement = function (el) {\r\n        _super.prototype.setElement.call(this, el);\r\n        if (this.dateClicking) {\r\n            this.dateClicking.bindToEl(el);\r\n        }\r\n        if (this.dateSelecting) {\r\n            this.dateSelecting.bindToEl(el);\r\n        }\r\n        this.bindAllSegHandlersToEl(el);\r\n    };\r\n    InteractiveDateComponent.prototype.removeElement = function () {\r\n        this.endInteractions();\r\n        _super.prototype.removeElement.call(this);\r\n    };\r\n    InteractiveDateComponent.prototype.executeEventUnrender = function () {\r\n        this.endInteractions();\r\n        _super.prototype.executeEventUnrender.call(this);\r\n    };\r\n    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {\r\n        _super.prototype.bindGlobalHandlers.call(this);\r\n        if (this.externalDropping) {\r\n            this.externalDropping.bindToDocument();\r\n        }\r\n    };\r\n    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {\r\n        _super.prototype.unbindGlobalHandlers.call(this);\r\n        if (this.externalDropping) {\r\n            this.externalDropping.unbindFromDocument();\r\n        }\r\n    };\r\n    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {\r\n        var _this = this;\r\n        // attach a handler to the grid's root element.\r\n        // jQuery will take care of unregistering them when removeElement gets called.\r\n        this.el.on(name, function (ev) {\r\n            if (!$(ev.target).is(_this.segSelector + ':not(.fc-helper),' + // directly on an event element\r\n                _this.segSelector + ':not(.fc-helper) *,' + // within an event element\r\n                '.fc-more,' + // a \"more..\" link\r\n                'a[data-goto]' // a clickable nav link\r\n            )) {\r\n                return handler.call(_this, ev);\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {\r\n        [\r\n            this.eventPointing,\r\n            this.eventDragging,\r\n            this.eventResizing\r\n        ].forEach(function (eventInteraction) {\r\n            if (eventInteraction) {\r\n                eventInteraction.bindToEl(el);\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {\r\n        var _this = this;\r\n        el.on(name, this.segSelector, function (ev) {\r\n            var segEl = $(ev.currentTarget);\r\n            if (!segEl.is('.fc-helper')) {\r\n                var seg = segEl.data('fc-seg'); // grab segment data. put there by View::renderEventsPayload\r\n                if (seg && !_this.shouldIgnoreEventPointing()) {\r\n                    return handler.call(_this, seg, ev); // context will be the Grid\r\n                }\r\n            }\r\n        });\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {\r\n        // HACK\r\n        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.\r\n        return GlobalEmitter_1.default.get().shouldIgnoreMouse();\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {\r\n        var view = this._getView();\r\n        // On iOS (and Android?) when a new selection is initiated overtop another selection,\r\n        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\r\n        // HACK: simply don't allow this to happen.\r\n        // ALSO: prevent selection when an *event* is already raised.\r\n        return view.isSelected || view.selectedEvent;\r\n    };\r\n    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {\r\n        // only call the handlers if there is not a drag/resize in progress\r\n        return (this.eventDragging && this.eventDragging.isDragging) ||\r\n            (this.eventResizing && this.eventResizing.isResizing);\r\n    };\r\n    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {\r\n        return util_1.getEvIsTouch(ev) &&\r\n            !this.canStartResize(seg, ev) &&\r\n            (this.isEventDefDraggable(seg.footprint.eventDef) ||\r\n                this.isEventDefResizable(seg.footprint.eventDef));\r\n    };\r\n    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {\r\n        return !this.canStartResize(seg, ev) &&\r\n            this.isEventDefDraggable(seg.footprint.eventDef);\r\n    };\r\n    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {\r\n        var view = this._getView();\r\n        var eventDef = seg.footprint.eventDef;\r\n        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&\r\n            this.isEventDefResizable(eventDef) &&\r\n            $(ev.target).is('.fc-resizer');\r\n    };\r\n    // Kills all in-progress dragging.\r\n    // Useful for when public API methods that result in re-rendering are invoked during a drag.\r\n    // Also useful for when touch devices misbehave and don't fire their touchend.\r\n    InteractiveDateComponent.prototype.endInteractions = function () {\r\n        [\r\n            this.dateClicking,\r\n            this.dateSelecting,\r\n            this.eventPointing,\r\n            this.eventDragging,\r\n            this.eventResizing\r\n        ].forEach(function (interaction) {\r\n            if (interaction) {\r\n                interaction.end();\r\n            }\r\n        });\r\n    };\r\n    // Event Drag-n-Drop\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Computes if the given event is allowed to be dragged by the user\r\n    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {\r\n        return this.isEventDefStartEditable(eventDef);\r\n    };\r\n    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {\r\n        var isEditable = eventDef.isStartExplicitlyEditable();\r\n        if (isEditable == null) {\r\n            isEditable = this.opt('eventStartEditable');\r\n            if (isEditable == null) {\r\n                isEditable = this.isEventDefGenerallyEditable(eventDef);\r\n            }\r\n        }\r\n        return isEditable;\r\n    };\r\n    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {\r\n        var isEditable = eventDef.isExplicitlyEditable();\r\n        if (isEditable == null) {\r\n            isEditable = this.opt('editable');\r\n        }\r\n        return isEditable;\r\n    };\r\n    // Event Resizing\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Computes if the given event is allowed to be resized from its starting edge\r\n    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {\r\n        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);\r\n    };\r\n    // Computes if the given event is allowed to be resized from its ending edge\r\n    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {\r\n        return this.isEventDefResizable(eventDef);\r\n    };\r\n    // Computes if the given event is allowed to be resized by the user at all\r\n    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {\r\n        var isResizable = eventDef.isDurationExplicitlyEditable();\r\n        if (isResizable == null) {\r\n            isResizable = this.opt('eventDurationEditable');\r\n            if (isResizable == null) {\r\n                isResizable = this.isEventDefGenerallyEditable(eventDef);\r\n            }\r\n        }\r\n        return isResizable;\r\n    };\r\n    // Event Mutation / Constraints\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Diffs the two dates, returning a duration, based on granularity of the grid\r\n    // TODO: port isTimeScale into this system?\r\n    InteractiveDateComponent.prototype.diffDates = function (a, b) {\r\n        if (this.largeUnit) {\r\n            return util_1.diffByUnit(a, b, this.largeUnit);\r\n        }\r\n        else {\r\n            return util_1.diffDayTime(a, b);\r\n        }\r\n    };\r\n    // is it allowed, in relation to the view's validRange?\r\n    // NOTE: very similar to isExternalInstanceGroupAllowed\r\n    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var view = this._getView();\r\n        var dateProfile = this.dateProfile;\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            // TODO: just use getAllEventRanges directly\r\n            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n                return false;\r\n            }\r\n        }\r\n        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);\r\n    };\r\n    // NOTE: very similar to isEventInstanceGroupAllowed\r\n    // when it's a completely anonymous external drag, no event.\r\n    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var view = this._getView();\r\n        var dateProfile = this.dateProfile;\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n                return false;\r\n            }\r\n        }\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            // treat it as a selection\r\n            // TODO: pass in eventInstanceGroup instead\r\n            //  because we don't want calendar's constraint system to depend on a component's\r\n            //  determination of footprints.\r\n            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return InteractiveDateComponent;\r\n}(DateComponent_1.default));\r\nexports.default = InteractiveDateComponent;\r\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar RenderQueue_1 = __webpack_require__(218);\r\nvar DateProfileGenerator_1 = __webpack_require__(221);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\n/* An abstract class from which other views inherit from\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar View = /** @class */ (function (_super) {\r\n    tslib_1.__extends(View, _super);\r\n    function View(calendar, viewSpec) {\r\n        var _this = _super.call(this, null, viewSpec.options) || this;\r\n        _this.batchRenderDepth = 0;\r\n        _this.isSelected = false; // boolean whether a range of time is user-selected or not\r\n        _this.calendar = calendar;\r\n        _this.viewSpec = viewSpec;\r\n        // shortcuts\r\n        _this.type = viewSpec.type;\r\n        // .name is deprecated\r\n        _this.name = _this.type;\r\n        _this.initRenderQueue();\r\n        _this.initHiddenDays();\r\n        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);\r\n        _this.bindBaseRenderHandlers();\r\n        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));\r\n        // legacy\r\n        if (_this['initialize']) {\r\n            _this['initialize']();\r\n        }\r\n        return _this;\r\n    }\r\n    View.prototype._getView = function () {\r\n        return this;\r\n    };\r\n    // Retrieves an option with the given name\r\n    View.prototype.opt = function (name) {\r\n        return this.options[name];\r\n    };\r\n    /* Render Queue\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.initRenderQueue = function () {\r\n        this.renderQueue = new RenderQueue_1.default({\r\n            event: this.opt('eventRenderWait')\r\n        });\r\n        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));\r\n        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));\r\n        this.on('before:change', this.startBatchRender);\r\n        this.on('change', this.stopBatchRender);\r\n    };\r\n    View.prototype.onRenderQueueStart = function () {\r\n        this.calendar.freezeContentHeight();\r\n        this.addScroll(this.queryScroll());\r\n    };\r\n    View.prototype.onRenderQueueStop = function () {\r\n        if (this.calendar.updateViewSize()) {\r\n            this.popScroll();\r\n        }\r\n        this.calendar.thawContentHeight();\r\n    };\r\n    View.prototype.startBatchRender = function () {\r\n        if (!(this.batchRenderDepth++)) {\r\n            this.renderQueue.pause();\r\n        }\r\n    };\r\n    View.prototype.stopBatchRender = function () {\r\n        if (!(--this.batchRenderDepth)) {\r\n            this.renderQueue.resume();\r\n        }\r\n    };\r\n    View.prototype.requestRender = function (func, namespace, actionType) {\r\n        this.renderQueue.queue(func, namespace, actionType);\r\n    };\r\n    // given func will auto-bind to `this`\r\n    View.prototype.whenSizeUpdated = function (func) {\r\n        if (this.renderQueue.isRunning) {\r\n            this.renderQueue.one('stop', func.bind(this));\r\n        }\r\n        else {\r\n            func.call(this);\r\n        }\r\n    };\r\n    /* Title and Date Formatting\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes what the title at the top of the calendar should be for this view\r\n    View.prototype.computeTitle = function (dateProfile) {\r\n        var unzonedRange;\r\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\r\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\r\n            unzonedRange = dateProfile.currentUnzonedRange;\r\n        }\r\n        else {\r\n            unzonedRange = dateProfile.activeUnzonedRange;\r\n        }\r\n        return this.formatRange({\r\n            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),\r\n            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)\r\n        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));\r\n    };\r\n    // Generates the format string that should be used to generate the title for the current date range.\r\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\r\n    View.prototype.computeTitleFormat = function (dateProfile) {\r\n        var currentRangeUnit = dateProfile.currentRangeUnit;\r\n        if (currentRangeUnit === 'year') {\r\n            return 'YYYY';\r\n        }\r\n        else if (currentRangeUnit === 'month') {\r\n            return this.opt('monthYearFormat'); // like \"September 2014\"\r\n        }\r\n        else if (dateProfile.currentUnzonedRange.as('days') > 1) {\r\n            return 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\r\n        }\r\n        else {\r\n            return 'LL'; // one day. longer, like \"September 9 2014\"\r\n        }\r\n    };\r\n    // Date Setting/Unsetting\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.setDate = function (date) {\r\n        var currentDateProfile = this.get('dateProfile');\r\n        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true\r\n        if (!currentDateProfile ||\r\n            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {\r\n            this.set('dateProfile', newDateProfile);\r\n        }\r\n    };\r\n    View.prototype.unsetDate = function () {\r\n        this.unset('dateProfile');\r\n    };\r\n    // Event Data\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.fetchInitialEvents = function (dateProfile) {\r\n        var calendar = this.calendar;\r\n        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;\r\n        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));\r\n    };\r\n    View.prototype.bindEventChanges = function () {\r\n        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event\r\n    };\r\n    View.prototype.unbindEventChanges = function () {\r\n        this.stopListeningTo(this.calendar, 'eventsReset');\r\n    };\r\n    View.prototype.setEvents = function (eventsPayload) {\r\n        this.set('currentEvents', eventsPayload);\r\n        this.set('hasEvents', true);\r\n    };\r\n    View.prototype.unsetEvents = function () {\r\n        this.unset('currentEvents');\r\n        this.unset('hasEvents');\r\n    };\r\n    View.prototype.resetEvents = function (eventsPayload) {\r\n        this.startBatchRender();\r\n        this.unsetEvents();\r\n        this.setEvents(eventsPayload);\r\n        this.stopBatchRender();\r\n    };\r\n    // Date High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestDateRender = function (dateProfile) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeDateRender(dateProfile);\r\n        }, 'date', 'init');\r\n    };\r\n    View.prototype.requestDateUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeDateUnrender();\r\n        }, 'date', 'destroy');\r\n    };\r\n    // if dateProfile not specified, uses current\r\n    View.prototype.executeDateRender = function (dateProfile) {\r\n        _super.prototype.executeDateRender.call(this, dateProfile);\r\n        if (this['render']) {\r\n            this['render'](); // TODO: deprecate\r\n        }\r\n        this.trigger('datesRendered');\r\n        this.addScroll({ isDateInit: true });\r\n        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon\r\n    };\r\n    View.prototype.executeDateUnrender = function () {\r\n        this.unselect();\r\n        this.stopNowIndicator();\r\n        this.trigger('before:datesUnrendered');\r\n        if (this['destroy']) {\r\n            this['destroy'](); // TODO: deprecate\r\n        }\r\n        _super.prototype.executeDateUnrender.call(this);\r\n    };\r\n    // \"Base\" rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.bindBaseRenderHandlers = function () {\r\n        var _this = this;\r\n        this.on('datesRendered', function () {\r\n            _this.whenSizeUpdated(_this.triggerViewRender);\r\n        });\r\n        this.on('before:datesUnrendered', function () {\r\n            _this.triggerViewDestroy();\r\n        });\r\n    };\r\n    View.prototype.triggerViewRender = function () {\r\n        this.publiclyTrigger('viewRender', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    View.prototype.triggerViewDestroy = function () {\r\n        this.publiclyTrigger('viewDestroy', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    // Event High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestEventsRender = function (eventsPayload) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.executeEventRender(eventsPayload);\r\n            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);\r\n        }, 'event', 'init');\r\n    };\r\n    View.prototype.requestEventsUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.triggerBeforeEventsDestroyed();\r\n            _this.executeEventUnrender();\r\n        }, 'event', 'destroy');\r\n    };\r\n    // Business Hour High-level Rendering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.renderBusinessHours(businessHourGenerator);\r\n        }, 'businessHours', 'init');\r\n    };\r\n    View.prototype.requestBusinessHoursUnrender = function () {\r\n        var _this = this;\r\n        this.requestRender(function () {\r\n            _this.unrenderBusinessHours();\r\n        }, 'businessHours', 'destroy');\r\n    };\r\n    // Misc view rendering utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Binds DOM handlers to elements that reside outside the view container, such as the document\r\n    View.prototype.bindGlobalHandlers = function () {\r\n        _super.prototype.bindGlobalHandlers.call(this);\r\n        this.listenTo(GlobalEmitter_1.default.get(), {\r\n            touchstart: this.processUnselect,\r\n            mousedown: this.handleDocumentMousedown\r\n        });\r\n    };\r\n    // Unbinds DOM handlers from elements that reside outside the view container\r\n    View.prototype.unbindGlobalHandlers = function () {\r\n        _super.prototype.unbindGlobalHandlers.call(this);\r\n        this.stopListeningTo(GlobalEmitter_1.default.get());\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Immediately render the current time indicator and begins re-rendering it at an interval,\r\n    // which is defined by this.getNowIndicatorUnit().\r\n    // TODO: somehow do this for the current whole day's background too\r\n    View.prototype.startNowIndicator = function () {\r\n        var _this = this;\r\n        var unit;\r\n        var update;\r\n        var delay; // ms wait value\r\n        if (this.opt('nowIndicator')) {\r\n            unit = this.getNowIndicatorUnit();\r\n            if (unit) {\r\n                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`\r\n                this.initialNowDate = this.calendar.getNow();\r\n                this.initialNowQueriedMs = new Date().valueOf();\r\n                // wait until the beginning of the next interval\r\n                delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();\r\n                this.nowIndicatorTimeoutID = setTimeout(function () {\r\n                    _this.nowIndicatorTimeoutID = null;\r\n                    update();\r\n                    delay = +moment.duration(1, unit);\r\n                    delay = Math.max(100, delay); // prevent too frequent\r\n                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\r\n                }, delay);\r\n            }\r\n            // rendering will be initiated in updateSize\r\n        }\r\n    };\r\n    // rerenders the now indicator, computing the new current time from the amount of time that has passed\r\n    // since the initial getNow call.\r\n    View.prototype.updateNowIndicator = function () {\r\n        if (this.isDatesRendered &&\r\n            this.initialNowDate // activated before?\r\n        ) {\r\n            this.unrenderNowIndicator(); // won't unrender if unnecessary\r\n            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms\r\n            );\r\n            this.isNowIndicatorRendered = true;\r\n        }\r\n    };\r\n    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\r\n    // Won't cause side effects if indicator isn't rendered.\r\n    View.prototype.stopNowIndicator = function () {\r\n        if (this.isNowIndicatorRendered) {\r\n            if (this.nowIndicatorTimeoutID) {\r\n                clearTimeout(this.nowIndicatorTimeoutID);\r\n                this.nowIndicatorTimeoutID = null;\r\n            }\r\n            if (this.nowIndicatorIntervalID) {\r\n                clearInterval(this.nowIndicatorIntervalID);\r\n                this.nowIndicatorIntervalID = null;\r\n            }\r\n            this.unrenderNowIndicator();\r\n            this.isNowIndicatorRendered = false;\r\n        }\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        if (this['setHeight']) {\r\n            this['setHeight'](totalHeight, isAuto);\r\n        }\r\n        else {\r\n            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        }\r\n        this.updateNowIndicator();\r\n    };\r\n    /* Scroller\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.addScroll = function (scroll) {\r\n        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});\r\n        $.extend(queuedScroll, scroll);\r\n    };\r\n    View.prototype.popScroll = function () {\r\n        this.applyQueuedScroll();\r\n        this.queuedScroll = null;\r\n    };\r\n    View.prototype.applyQueuedScroll = function () {\r\n        if (this.queuedScroll) {\r\n            this.applyScroll(this.queuedScroll);\r\n        }\r\n    };\r\n    View.prototype.queryScroll = function () {\r\n        var scroll = {};\r\n        if (this.isDatesRendered) {\r\n            $.extend(scroll, this.queryDateScroll());\r\n        }\r\n        return scroll;\r\n    };\r\n    View.prototype.applyScroll = function (scroll) {\r\n        if (scroll.isDateInit && this.isDatesRendered) {\r\n            $.extend(scroll, this.computeInitialDateScroll());\r\n        }\r\n        if (this.isDatesRendered) {\r\n            this.applyDateScroll(scroll);\r\n        }\r\n    };\r\n    View.prototype.computeInitialDateScroll = function () {\r\n        return {}; // subclasses must implement\r\n    };\r\n    View.prototype.queryDateScroll = function () {\r\n        return {}; // subclasses must implement\r\n    };\r\n    View.prototype.applyDateScroll = function (scroll) {\r\n        // subclasses must implement\r\n    };\r\n    /* Event Drag-n-Drop\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {\r\n        var eventManager = this.calendar.eventManager;\r\n        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\r\n        var dateMutation = eventMutation.dateMutation;\r\n        // update the EventInstance, for handlers\r\n        if (dateMutation) {\r\n            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\r\n        }\r\n        this.triggerEventDrop(eventInstance, \r\n        // a drop doesn't necessarily mean a date mutation (ex: resource change)\r\n        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);\r\n    };\r\n    // Triggers event-drop handlers that have subscribed via the API\r\n    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {\r\n        this.publiclyTrigger('eventDrop', {\r\n            context: el[0],\r\n            args: [\r\n                eventInstance.toLegacy(),\r\n                dateDelta,\r\n                undoFunc,\r\n                ev,\r\n                {},\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    /* External Element Drag-n-Drop\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\r\n    // `meta` is the parsed data that has been embedded into the dragging event.\r\n    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\r\n    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {\r\n        if (isEvent) {\r\n            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);\r\n        }\r\n        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);\r\n    };\r\n    // Triggers external-drop handlers that have subscribed via the API\r\n    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {\r\n        // trigger 'drop' regardless of whether element represents an event\r\n        this.publiclyTrigger('drop', {\r\n            context: el[0],\r\n            args: [\r\n                singleEventDef.dateProfile.start.clone(),\r\n                ev,\r\n                ui,\r\n                this\r\n            ]\r\n        });\r\n        if (isEvent) {\r\n            // signal an external event landed\r\n            this.publiclyTrigger('eventReceive', {\r\n                context: this,\r\n                args: [\r\n                    singleEventDef.buildInstance().toLegacy(),\r\n                    this\r\n                ]\r\n            });\r\n        }\r\n    };\r\n    /* Event Resizing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Must be called when an event in the view has been resized to a new length\r\n    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {\r\n        var eventManager = this.calendar.eventManager;\r\n        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);\r\n        // update the EventInstance, for handlers\r\n        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);\r\n        this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);\r\n    };\r\n    // Triggers event-resize handlers that have subscribed via the API\r\n    View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {\r\n        this.publiclyTrigger('eventResize', {\r\n            context: el[0],\r\n            args: [\r\n                eventInstance.toLegacy(),\r\n                durationDelta,\r\n                undoFunc,\r\n                ev,\r\n                {},\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    /* Selection (time range)\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Selects a date span on the view. `start` and `end` are both Moments.\r\n    // `ev` is the native mouse event that begin the interaction.\r\n    View.prototype.select = function (footprint, ev) {\r\n        this.unselect(ev);\r\n        this.renderSelectionFootprint(footprint);\r\n        this.reportSelection(footprint, ev);\r\n    };\r\n    View.prototype.renderSelectionFootprint = function (footprint) {\r\n        if (this['renderSelection']) {\r\n            this['renderSelection'](footprint.toLegacy(this.calendar));\r\n        }\r\n        else {\r\n            _super.prototype.renderSelectionFootprint.call(this, footprint);\r\n        }\r\n    };\r\n    // Called when a new selection is made. Updates internal state and triggers handlers.\r\n    View.prototype.reportSelection = function (footprint, ev) {\r\n        this.isSelected = true;\r\n        this.triggerSelect(footprint, ev);\r\n    };\r\n    // Triggers handlers to 'select'\r\n    View.prototype.triggerSelect = function (footprint, ev) {\r\n        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n        this.publiclyTrigger('select', {\r\n            context: this,\r\n            args: [\r\n                dateProfile.start,\r\n                dateProfile.end,\r\n                ev,\r\n                this\r\n            ]\r\n        });\r\n    };\r\n    // Undoes a selection. updates in the internal state and triggers handlers.\r\n    // `ev` is the native mouse event that began the interaction.\r\n    View.prototype.unselect = function (ev) {\r\n        if (this.isSelected) {\r\n            this.isSelected = false;\r\n            if (this['destroySelection']) {\r\n                this['destroySelection'](); // TODO: deprecate\r\n            }\r\n            this.unrenderSelection();\r\n            this.publiclyTrigger('unselect', {\r\n                context: this,\r\n                args: [ev, this]\r\n            });\r\n        }\r\n    };\r\n    /* Event Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.selectEventInstance = function (eventInstance) {\r\n        if (!this.selectedEventInstance ||\r\n            this.selectedEventInstance !== eventInstance) {\r\n            this.unselectEventInstance();\r\n            this.getEventSegs().forEach(function (seg) {\r\n                if (seg.footprint.eventInstance === eventInstance &&\r\n                    seg.el // necessary?\r\n                ) {\r\n                    seg.el.addClass('fc-selected');\r\n                }\r\n            });\r\n            this.selectedEventInstance = eventInstance;\r\n        }\r\n    };\r\n    View.prototype.unselectEventInstance = function () {\r\n        if (this.selectedEventInstance) {\r\n            this.getEventSegs().forEach(function (seg) {\r\n                if (seg.el) {\r\n                    seg.el.removeClass('fc-selected');\r\n                }\r\n            });\r\n            this.selectedEventInstance = null;\r\n        }\r\n    };\r\n    View.prototype.isEventDefSelected = function (eventDef) {\r\n        // event references might change on refetchEvents(), while selectedEventInstance doesn't,\r\n        // so compare IDs\r\n        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;\r\n    };\r\n    /* Mouse / Touch Unselecting (time range & event unselection)\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // TODO: move consistently to down/start or up/end?\r\n    // TODO: don't kill previous selection if touch scrolling\r\n    View.prototype.handleDocumentMousedown = function (ev) {\r\n        if (util_1.isPrimaryMouseButton(ev)) {\r\n            this.processUnselect(ev);\r\n        }\r\n    };\r\n    View.prototype.processUnselect = function (ev) {\r\n        this.processRangeUnselect(ev);\r\n        this.processEventUnselect(ev);\r\n    };\r\n    View.prototype.processRangeUnselect = function (ev) {\r\n        var ignore;\r\n        // is there a time-range selection?\r\n        if (this.isSelected && this.opt('unselectAuto')) {\r\n            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\r\n            ignore = this.opt('unselectCancel');\r\n            if (!ignore || !$(ev.target).closest(ignore).length) {\r\n                this.unselect(ev);\r\n            }\r\n        }\r\n    };\r\n    View.prototype.processEventUnselect = function (ev) {\r\n        if (this.selectedEventInstance) {\r\n            if (!$(ev.target).closest('.fc-selected').length) {\r\n                this.unselectEventInstance();\r\n            }\r\n        }\r\n    };\r\n    /* Triggers\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    View.prototype.triggerBaseRendered = function () {\r\n        this.publiclyTrigger('viewRender', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    View.prototype.triggerBaseUnrendered = function () {\r\n        this.publiclyTrigger('viewDestroy', {\r\n            context: this,\r\n            args: [this, this.el]\r\n        });\r\n    };\r\n    // Triggers handlers to 'dayClick'\r\n    // Span has start/end of the clicked area. Only the start is useful.\r\n    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {\r\n        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n        this.publiclyTrigger('dayClick', {\r\n            context: dayEl,\r\n            args: [dateProfile.start, ev, this]\r\n        });\r\n    };\r\n    /* Date Utils\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // For DateComponent::getDayClasses\r\n    View.prototype.isDateInOtherMonth = function (date, dateProfile) {\r\n        return false;\r\n    };\r\n    // Arguments after name will be forwarded to a hypothetical function value\r\n    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\r\n    // Always clone your objects if you fear mutation.\r\n    View.prototype.getUnzonedRangeOption = function (name) {\r\n        var val = this.opt(name);\r\n        if (typeof val === 'function') {\r\n            val = val.apply(null, Array.prototype.slice.call(arguments, 1));\r\n        }\r\n        if (val) {\r\n            return this.calendar.parseUnzonedRange(val);\r\n        }\r\n    };\r\n    /* Hidden Days\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Initializes internal variables related to calculating hidden days-of-week\r\n    View.prototype.initHiddenDays = function () {\r\n        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\r\n        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\r\n        var dayCnt = 0;\r\n        var i;\r\n        if (this.opt('weekends') === false) {\r\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\r\n        }\r\n        for (i = 0; i < 7; i++) {\r\n            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {\r\n                dayCnt++;\r\n            }\r\n        }\r\n        if (!dayCnt) {\r\n            throw new Error('invalid hiddenDays'); // all days were hidden? bad.\r\n        }\r\n        this.isHiddenDayHash = isHiddenDayHash;\r\n    };\r\n    // Remove days from the beginning and end of the range that are computed as hidden.\r\n    // If the whole range is trimmed off, returns null\r\n    View.prototype.trimHiddenDays = function (inputUnzonedRange) {\r\n        var start = inputUnzonedRange.getStart();\r\n        var end = inputUnzonedRange.getEnd();\r\n        if (start) {\r\n            start = this.skipHiddenDays(start);\r\n        }\r\n        if (end) {\r\n            end = this.skipHiddenDays(end, -1, true);\r\n        }\r\n        if (start === null || end === null || start < end) {\r\n            return new UnzonedRange_1.default(start, end);\r\n        }\r\n        return null;\r\n    };\r\n    // Is the current day hidden?\r\n    // `day` is a day-of-week index (0-6), or a Moment\r\n    View.prototype.isHiddenDay = function (day) {\r\n        if (moment.isMoment(day)) {\r\n            day = day.day();\r\n        }\r\n        return this.isHiddenDayHash[day];\r\n    };\r\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\r\n    // DOES NOT CONSIDER validUnzonedRange!\r\n    // If the initial value of `date` is not a hidden day, don't do anything.\r\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\r\n    // `inc` defaults to `1` (increment one day forward each time)\r\n    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {\r\n        if (inc === void 0) { inc = 1; }\r\n        if (isExclusive === void 0) { isExclusive = false; }\r\n        var out = date.clone();\r\n        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {\r\n            out.add(inc, 'days');\r\n        }\r\n        return out;\r\n    };\r\n    return View;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = View;\r\nView.prototype.usesMinMaxTime = false;\r\nView.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;\r\nView.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {\r\n    this.requestDateRender(deps.dateProfile);\r\n}, function () {\r\n    this.requestDateUnrender();\r\n});\r\nView.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {\r\n    this.requestBusinessHoursRender(deps.businessHourGenerator);\r\n}, function () {\r\n    this.requestBusinessHoursUnrender();\r\n});\r\nView.watch('initialEvents', ['dateProfile'], function (deps) {\r\n    return this.fetchInitialEvents(deps.dateProfile);\r\n});\r\nView.watch('bindingEvents', ['initialEvents'], function (deps) {\r\n    this.setEvents(deps.initialEvents);\r\n    this.bindEventChanges();\r\n}, function () {\r\n    this.unbindEventChanges();\r\n    this.unsetEvents();\r\n});\r\nView.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {\r\n    this.requestEventsRender(this.get('currentEvents'));\r\n}, function () {\r\n    this.requestEventsUnrender();\r\n});\r\nView.watch('title', ['dateProfile'], function (deps) {\r\n    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons\r\n});\r\nView.watch('legacyDateProps', ['dateProfile'], function (deps) {\r\n    var calendar = this.calendar;\r\n    var dateProfile = deps.dateProfile;\r\n    // DEPRECATED, but we need to keep it updated...\r\n    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n});\r\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer = /** @class */ (function () {\r\n    function EventRenderer(component, fillRenderer) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n        this.fillRenderer = fillRenderer;\r\n    }\r\n    EventRenderer.prototype.opt = function (name) {\r\n        return this.view.opt(name);\r\n    };\r\n    // Updates values that rely on options and also relate to range\r\n    EventRenderer.prototype.rangeUpdated = function () {\r\n        var displayEventTime;\r\n        var displayEventEnd;\r\n        this.eventTimeFormat =\r\n            this.opt('eventTimeFormat') ||\r\n                this.opt('timeFormat') || // deprecated\r\n                this.computeEventTimeFormat();\r\n        displayEventTime = this.opt('displayEventTime');\r\n        if (displayEventTime == null) {\r\n            displayEventTime = this.computeDisplayEventTime(); // might be based off of range\r\n        }\r\n        displayEventEnd = this.opt('displayEventEnd');\r\n        if (displayEventEnd == null) {\r\n            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\r\n        }\r\n        this.displayEventTime = displayEventTime;\r\n        this.displayEventEnd = displayEventEnd;\r\n    };\r\n    EventRenderer.prototype.render = function (eventsPayload) {\r\n        var dateProfile = this.component._getDateProfile();\r\n        var eventDefId;\r\n        var instanceGroup;\r\n        var eventRanges;\r\n        var bgRanges = [];\r\n        var fgRanges = [];\r\n        for (eventDefId in eventsPayload) {\r\n            instanceGroup = eventsPayload[eventDefId];\r\n            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);\r\n            if (instanceGroup.getEventDef().hasBgRendering()) {\r\n                bgRanges.push.apply(bgRanges, eventRanges);\r\n            }\r\n            else {\r\n                fgRanges.push.apply(fgRanges, eventRanges);\r\n            }\r\n        }\r\n        this.renderBgRanges(bgRanges);\r\n        this.renderFgRanges(fgRanges);\r\n    };\r\n    EventRenderer.prototype.unrender = function () {\r\n        this.unrenderBgRanges();\r\n        this.unrenderFgRanges();\r\n    };\r\n    EventRenderer.prototype.renderFgRanges = function (eventRanges) {\r\n        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        // render an `.el` on each seg\r\n        // returns a subset of the segs. segs that were actually rendered\r\n        segs = this.renderFgSegEls(segs);\r\n        if (this.renderFgSegs(segs) !== false) {\r\n            this.fgSegs = segs;\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderFgRanges = function () {\r\n        this.unrenderFgSegs(this.fgSegs || []);\r\n        this.fgSegs = null;\r\n    };\r\n    EventRenderer.prototype.renderBgRanges = function (eventRanges) {\r\n        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        if (this.renderBgSegs(segs) !== false) {\r\n            this.bgSegs = segs;\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderBgRanges = function () {\r\n        this.unrenderBgSegs();\r\n        this.bgSegs = null;\r\n    };\r\n    EventRenderer.prototype.getSegs = function () {\r\n        return (this.bgSegs || []).concat(this.fgSegs || []);\r\n    };\r\n    // Renders foreground event segments onto the grid\r\n    EventRenderer.prototype.renderFgSegs = function (segs) {\r\n        // subclasses must implement\r\n        // segs already has rendered els, and has been filtered.\r\n        return false; // signal failure if not implemented\r\n    };\r\n    // Unrenders all currently rendered foreground segments\r\n    EventRenderer.prototype.unrenderFgSegs = function (segs) {\r\n        // subclasses must implement\r\n    };\r\n    EventRenderer.prototype.renderBgSegs = function (segs) {\r\n        var _this = this;\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderSegs('bgEvent', segs, {\r\n                getClasses: function (seg) {\r\n                    return _this.getBgClasses(seg.footprint.eventDef);\r\n                },\r\n                getCss: function (seg) {\r\n                    return {\r\n                        'background-color': _this.getBgColor(seg.footprint.eventDef)\r\n                    };\r\n                },\r\n                filterEl: function (seg, el) {\r\n                    return _this.filterEventRenderEl(seg.footprint, el);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return false; // signal failure if no fillRenderer\r\n        }\r\n    };\r\n    EventRenderer.prototype.unrenderBgSegs = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('bgEvent');\r\n        }\r\n    };\r\n    // Renders and assigns an `el` property for each foreground event segment.\r\n    // Only returns segments that successfully rendered.\r\n    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {\r\n        var _this = this;\r\n        if (disableResizing === void 0) { disableResizing = false; }\r\n        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');\r\n        var html = '';\r\n        var renderedSegs = [];\r\n        var i;\r\n        if (segs.length) {\r\n            // build a large concatenation of event segment HTML\r\n            for (i = 0; i < segs.length; i++) {\r\n                this.beforeFgSegHtml(segs[i]);\r\n                html += this.fgSegHtml(segs[i], disableResizing);\r\n            }\r\n            // Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\r\n            $(html).each(function (i, node) {\r\n                var seg = segs[i];\r\n                var el = $(node);\r\n                if (hasEventRenderHandlers) {\r\n                    el = _this.filterEventRenderEl(seg.footprint, el);\r\n                }\r\n                if (el) {\r\n                    el.data('fc-seg', seg); // used by handlers\r\n                    seg.el = el;\r\n                    renderedSegs.push(seg);\r\n                }\r\n            });\r\n        }\r\n        return renderedSegs;\r\n    };\r\n    EventRenderer.prototype.beforeFgSegHtml = function (seg) {\r\n    };\r\n    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\r\n    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        // subclasses should implement\r\n    };\r\n    // Generic utility for generating the HTML classNames for an event segment's element\r\n    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {\r\n        var classes = [\r\n            'fc-event',\r\n            seg.isStart ? 'fc-start' : 'fc-not-start',\r\n            seg.isEnd ? 'fc-end' : 'fc-not-end'\r\n        ].concat(this.getClasses(seg.footprint.eventDef));\r\n        if (isDraggable) {\r\n            classes.push('fc-draggable');\r\n        }\r\n        if (isResizable) {\r\n            classes.push('fc-resizable');\r\n        }\r\n        // event is currently selected? attach a className.\r\n        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {\r\n            classes.push('fc-selected');\r\n        }\r\n        return classes;\r\n    };\r\n    // Given an event and the default element used for rendering, returns the element that should actually be used.\r\n    // Basically runs events and elements through the eventRender hook.\r\n    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {\r\n        var legacy = eventFootprint.getEventLegacy();\r\n        var custom = this.view.publiclyTrigger('eventRender', {\r\n            context: legacy,\r\n            args: [legacy, el, this.view]\r\n        });\r\n        if (custom === false) {\r\n            el = null;\r\n        }\r\n        else if (custom && custom !== true) {\r\n            el = $(custom);\r\n        }\r\n        return el;\r\n    };\r\n    // Compute the text that should be displayed on an event's element.\r\n    // `range` can be the Event object itself, or something range-like, with at least a `start`.\r\n    // If event times are disabled, or the event has no time, will return a blank string.\r\n    // If not specified, formatStr will default to the eventTimeFormat setting,\r\n    // and displayEnd will default to the displayEventEnd setting.\r\n    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {\r\n        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);\r\n    };\r\n    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {\r\n        if (formatStr == null) {\r\n            formatStr = this.eventTimeFormat;\r\n        }\r\n        if (displayEnd == null) {\r\n            displayEnd = this.displayEventEnd;\r\n        }\r\n        if (this.displayEventTime && !isAllDay) {\r\n            if (displayEnd && end) {\r\n                return this.view.formatRange({ start: start, end: end }, false, // allDay\r\n                formatStr);\r\n            }\r\n            else {\r\n                return start.format(formatStr);\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n    EventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('smallTimeFormat');\r\n    };\r\n    EventRenderer.prototype.computeDisplayEventTime = function () {\r\n        return true;\r\n    };\r\n    EventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return true;\r\n    };\r\n    EventRenderer.prototype.getBgClasses = function (eventDef) {\r\n        var classNames = this.getClasses(eventDef);\r\n        classNames.push('fc-bgevent');\r\n        return classNames;\r\n    };\r\n    EventRenderer.prototype.getClasses = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var classNames = [];\r\n        for (i = 0; i < objs.length; i++) {\r\n            classNames.push.apply(// append\r\n            classNames, objs[i].eventClassName || objs[i].className || []);\r\n        }\r\n        return classNames;\r\n    };\r\n    // Utility for generating event skin-related CSS properties\r\n    EventRenderer.prototype.getSkinCss = function (eventDef) {\r\n        return {\r\n            'background-color': this.getBgColor(eventDef),\r\n            'border-color': this.getBorderColor(eventDef),\r\n            color: this.getTextColor(eventDef)\r\n        };\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getBgColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventBackgroundColor || objs[i].eventColor ||\r\n                objs[i].backgroundColor || objs[i].color;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventBackgroundColor') || this.opt('eventColor');\r\n        }\r\n        return val;\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getBorderColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventBorderColor || objs[i].eventColor ||\r\n                objs[i].borderColor || objs[i].color;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventBorderColor') || this.opt('eventColor');\r\n        }\r\n        return val;\r\n    };\r\n    // Queries for caller-specified color, then falls back to default\r\n    EventRenderer.prototype.getTextColor = function (eventDef) {\r\n        var objs = this.getStylingObjs(eventDef);\r\n        var i;\r\n        var val;\r\n        for (i = 0; i < objs.length && !val; i++) {\r\n            val = objs[i].eventTextColor ||\r\n                objs[i].textColor;\r\n        }\r\n        if (!val) {\r\n            val = this.opt('eventTextColor');\r\n        }\r\n        return val;\r\n    };\r\n    EventRenderer.prototype.getStylingObjs = function (eventDef) {\r\n        var objs = this.getFallbackStylingObjs(eventDef);\r\n        objs.unshift(eventDef);\r\n        return objs;\r\n    };\r\n    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {\r\n        return [eventDef.source];\r\n    };\r\n    EventRenderer.prototype.sortEventSegs = function (segs) {\r\n        segs.sort(util_1.proxy(this, 'compareEventSegs'));\r\n    };\r\n    // A cmp function for determining which segments should take visual priority\r\n    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {\r\n        var f1 = seg1.footprint;\r\n        var f2 = seg2.footprint;\r\n        var cf1 = f1.componentFootprint;\r\n        var cf2 = f2.componentFootprint;\r\n        var r1 = cf1.unzonedRange;\r\n        var r2 = cf2.unzonedRange;\r\n        return r1.startMs - r2.startMs || // earlier events go first\r\n            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first\r\n            cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)\r\n            util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);\r\n    };\r\n    return EventRenderer;\r\n}());\r\nexports.default = EventRenderer;\r\n\n\n/***/ }),\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment_ext_1 = __webpack_require__(10);\r\n// Plugin\r\n// -------------------------------------------------------------------------------------------------\r\nmoment_ext_1.newMomentProto.format = function () {\r\n    if (this._fullCalendar && arguments[0]) {\r\n        return formatDate(this, arguments[0]); // our extended formatting\r\n    }\r\n    if (this._ambigTime) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n    }\r\n    if (this._ambigZone) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n    }\r\n    if (this._fullCalendar) {\r\n        // moment.format() doesn't ensure english, but we want to.\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this));\r\n    }\r\n    return moment_ext_1.oldMomentProto.format.apply(this, arguments);\r\n};\r\nmoment_ext_1.newMomentProto.toISOString = function () {\r\n    if (this._ambigTime) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n    }\r\n    if (this._ambigZone) {\r\n        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n    }\r\n    if (this._fullCalendar) {\r\n        // depending on browser, moment might not output english. ensure english.\r\n        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\r\n        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);\r\n    }\r\n    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);\r\n};\r\nfunction englishMoment(mom) {\r\n    if (mom.locale() !== 'en') {\r\n        return mom.clone().locale('en');\r\n    }\r\n    return mom;\r\n}\r\n// Config\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nInserted between chunks in the fake (\"intermediate\") formatting string.\r\nImportant that it passes as whitespace (\\s) because moment often identifies non-standalone months\r\nvia a regexp with an \\s.\r\n*/\r\nvar PART_SEPARATOR = '\\u000b'; // vertical tab\r\n/*\r\nInserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\r\nbut rather, a \"special\" token that has custom rendering (see specialTokens map).\r\n*/\r\nvar SPECIAL_TOKEN_MARKER = '\\u001f'; // information separator 1\r\n/*\r\nInserted at the beginning and end of a span of text that must have non-zero numeric characters.\r\nHandling of these markers is done in a post-processing step at the very end of text rendering.\r\n*/\r\nvar MAYBE_MARKER = '\\u001e'; // information separator 2\r\nvar MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\r\n/*\r\nAddition formatting tokens we want recognized\r\n*/\r\nvar specialTokens = {\r\n    t: function (date) {\r\n        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);\r\n    },\r\n    T: function (date) {\r\n        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);\r\n    }\r\n};\r\n/*\r\nThe first characters of formatting tokens for units that are 1 day or larger.\r\n`value` is for ranking relative size (lower means bigger).\r\n`unit` is a normalized unit, used for comparing moments.\r\n*/\r\nvar largeTokenMap = {\r\n    Y: { value: 1, unit: 'year' },\r\n    M: { value: 2, unit: 'month' },\r\n    W: { value: 3, unit: 'week' },\r\n    w: { value: 3, unit: 'week' },\r\n    D: { value: 4, unit: 'day' },\r\n    d: { value: 4, unit: 'day' } // day of week\r\n};\r\n// Single Date Formatting\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nFormats `date` with a Moment formatting string, but allow our non-zero areas and special token\r\n*/\r\nfunction formatDate(date, formatStr) {\r\n    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);\r\n}\r\nexports.formatDate = formatDate;\r\n// Date Range Formatting\r\n// -------------------------------------------------------------------------------------------------\r\n// TODO: make it work with timezone offset\r\n/*\r\nUsing a formatting string meant for a single date, generate a range string, like\r\n\"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\r\nIf the dates are the same as far as the format string is concerned, just return a single\r\nrendering of one date, without any separator.\r\n*/\r\nfunction formatRange(date1, date2, formatStr, separator, isRTL) {\r\n    var localeData;\r\n    date1 = moment_ext_1.default.parseZone(date1);\r\n    date2 = moment_ext_1.default.parseZone(date2);\r\n    localeData = date1.localeData();\r\n    // Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\".\r\n    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens\r\n    // or non-zero areas in Moment's localized format strings.\r\n    formatStr = localeData.longDateFormat(formatStr) || formatStr;\r\n    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);\r\n}\r\nexports.formatRange = formatRange;\r\n/*\r\nRenders a range with an already-parsed format string.\r\n*/\r\nfunction renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\r\n    var sameUnits = parsedFormat.sameUnits;\r\n    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\r\n    var unzonedDate2 = date2.clone().stripZone(); // \"\r\n    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\r\n    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\r\n    var leftI;\r\n    var leftStr = '';\r\n    var rightI;\r\n    var rightStr = '';\r\n    var middleI;\r\n    var middleStr1 = '';\r\n    var middleStr2 = '';\r\n    var middleStr = '';\r\n    // Start at the leftmost side of the formatting string and continue until you hit a token\r\n    // that is not the same between dates.\r\n    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {\r\n        leftStr += renderedParts1[leftI];\r\n    }\r\n    // Similarly, start at the rightmost side of the formatting string and move left\r\n    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {\r\n        // If current chunk is on the boundary of unique date-content, and is a special-case\r\n        // date-formatting postfix character, then don't consume it. Consider it unique date-content.\r\n        // TODO: make configurable\r\n        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\r\n            break;\r\n        }\r\n        rightStr = renderedParts1[rightI] + rightStr;\r\n    }\r\n    // The area in the middle is different for both of the dates.\r\n    // Collect them distinctly so we can jam them together later.\r\n    for (middleI = leftI; middleI <= rightI; middleI++) {\r\n        middleStr1 += renderedParts1[middleI];\r\n        middleStr2 += renderedParts2[middleI];\r\n    }\r\n    if (middleStr1 || middleStr2) {\r\n        if (isRTL) {\r\n            middleStr = middleStr2 + separator + middleStr1;\r\n        }\r\n        else {\r\n            middleStr = middleStr1 + separator + middleStr2;\r\n        }\r\n    }\r\n    return processMaybeMarkers(leftStr + middleStr + rightStr);\r\n}\r\n// Format String Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nvar parsedFormatStrCache = {};\r\n/*\r\nReturns a parsed format string, leveraging a cache.\r\n*/\r\nfunction getParsedFormatString(formatStr) {\r\n    return parsedFormatStrCache[formatStr] ||\r\n        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\r\n}\r\n/*\r\nParses a format string into the following:\r\n- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\r\n- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \"day\"),\r\n  that indicates how similar a range's start & end must be in order to share the same formatted text.\r\n  If not a token, then the value is null.\r\n  Always a flat array (not nested liked \"chunks\").\r\n*/\r\nfunction parseFormatString(formatStr) {\r\n    var chunks = chunkFormatString(formatStr);\r\n    return {\r\n        fakeFormatString: buildFakeFormatString(chunks),\r\n        sameUnits: buildSameUnits(chunks)\r\n    };\r\n}\r\n/*\r\nBreak the formatting string into an array of chunks.\r\nA 'maybe' chunk will have nested chunks.\r\n*/\r\nfunction chunkFormatString(formatStr) {\r\n    var chunks = [];\r\n    var match;\r\n    // TODO: more descrimination\r\n    // \\4 is a backreference to the first character of a multi-character set.\r\n    var chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g;\r\n    while ((match = chunker.exec(formatStr))) {\r\n        if (match[1]) {\r\n            chunks.push.apply(chunks, // append\r\n            splitStringLiteral(match[1]));\r\n        }\r\n        else if (match[2]) {\r\n            chunks.push({ maybe: chunkFormatString(match[2]) });\r\n        }\r\n        else if (match[3]) {\r\n            chunks.push({ token: match[3] });\r\n        }\r\n        else if (match[5]) {\r\n            chunks.push.apply(chunks, // append\r\n            splitStringLiteral(match[5]));\r\n        }\r\n    }\r\n    return chunks;\r\n}\r\n/*\r\nPotentially splits a literal-text string into multiple parts. For special cases.\r\n*/\r\nfunction splitStringLiteral(s) {\r\n    if (s === '. ') {\r\n        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date\r\n    }\r\n    else {\r\n        return [s];\r\n    }\r\n}\r\n/*\r\nGiven chunks parsed from a real format string, generate a fake (aka \"intermediate\") format string with special control\r\ncharacters that will eventually be given to moment for formatting, and then post-processed.\r\n*/\r\nfunction buildFakeFormatString(chunks) {\r\n    var parts = [];\r\n    var i;\r\n    var chunk;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (typeof chunk === 'string') {\r\n            parts.push('[' + chunk + ']');\r\n        }\r\n        else if (chunk.token) {\r\n            if (chunk.token in specialTokens) {\r\n                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing\r\n                    '[' + chunk.token + ']' // preserve as literal text\r\n                );\r\n            }\r\n            else {\r\n                parts.push(chunk.token); // unprotected text implies a format string\r\n            }\r\n        }\r\n        else if (chunk.maybe) {\r\n            parts.push(MAYBE_MARKER + // useful during post-processing\r\n                buildFakeFormatString(chunk.maybe) +\r\n                MAYBE_MARKER);\r\n        }\r\n    }\r\n    return parts.join(PART_SEPARATOR);\r\n}\r\n/*\r\nGiven parsed chunks from a real formatting string, generates an array of unit strings (like \"day\") that indicate\r\nin which regard two dates must be similar in order to share range formatting text.\r\nThe `chunks` can be nested (because of \"maybe\" chunks), however, the returned array will be flat.\r\n*/\r\nfunction buildSameUnits(chunks) {\r\n    var units = [];\r\n    var i;\r\n    var chunk;\r\n    var tokenInfo;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (chunk.token) {\r\n            tokenInfo = largeTokenMap[chunk.token.charAt(0)];\r\n            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\r\n        }\r\n        else if (chunk.maybe) {\r\n            units.push.apply(units, // append\r\n            buildSameUnits(chunk.maybe));\r\n        }\r\n        else {\r\n            units.push(null);\r\n        }\r\n    }\r\n    return units;\r\n}\r\n// Rendering to text\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n/*\r\nFormats a date with a fake format string, post-processes the control characters, then returns.\r\n*/\r\nfunction renderFakeFormatString(fakeFormatString, date) {\r\n    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));\r\n}\r\n/*\r\nFormats a date into parts that will have been post-processed, EXCEPT for the \"maybe\" markers.\r\n*/\r\nfunction renderFakeFormatStringParts(fakeFormatString, date) {\r\n    var parts = [];\r\n    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);\r\n    var fakeParts = fakeRender.split(PART_SEPARATOR);\r\n    var i;\r\n    var fakePart;\r\n    for (i = 0; i < fakeParts.length; i++) {\r\n        fakePart = fakeParts[i];\r\n        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\r\n            parts.push(\r\n            // the literal string IS the token's name.\r\n            // call special token's registered function.\r\n            specialTokens[fakePart.substring(1)](date));\r\n        }\r\n        else {\r\n            parts.push(fakePart);\r\n        }\r\n    }\r\n    return parts;\r\n}\r\n/*\r\nAccepts an almost-finally-formatted string and processes the \"maybe\" control characters, returning a new string.\r\n*/\r\nfunction processMaybeMarkers(s) {\r\n    return s.replace(MAYBE_REGEXP, function (m0, m1) {\r\n        if (m1.match(/[1-9]/)) {\r\n            return m1;\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    });\r\n}\r\n// Misc Utils\r\n// -------------------------------------------------------------------------------------------------\r\n/*\r\nReturns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\r\n*/\r\nfunction queryMostGranularFormatUnit(formatStr) {\r\n    var chunks = chunkFormatString(formatStr);\r\n    var i;\r\n    var chunk;\r\n    var candidate;\r\n    var best;\r\n    for (i = 0; i < chunks.length; i++) {\r\n        chunk = chunks[i];\r\n        if (chunk.token) {\r\n            candidate = largeTokenMap[chunk.token.charAt(0)];\r\n            if (candidate) {\r\n                if (!best || candidate.value > best.value) {\r\n                    best = candidate;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (best) {\r\n        return best.unit;\r\n    }\r\n    return null;\r\n}\r\nexports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\r\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Class_1 = __webpack_require__(33);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Model = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Model, _super);\r\n    function Model() {\r\n        var _this = _super.call(this) || this;\r\n        _this._watchers = {};\r\n        _this._props = {};\r\n        _this.applyGlobalWatchers();\r\n        _this.constructed();\r\n        return _this;\r\n    }\r\n    Model.watch = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        // subclasses should make a masked-copy of the superclass's map\r\n        // TODO: write test\r\n        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {\r\n            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);\r\n        }\r\n        this.prototype._globalWatchArgs[name] = args;\r\n    };\r\n    Model.prototype.constructed = function () {\r\n        // useful for monkeypatching. TODO: BaseClass?\r\n    };\r\n    Model.prototype.applyGlobalWatchers = function () {\r\n        var map = this._globalWatchArgs;\r\n        var name;\r\n        for (name in map) {\r\n            this.watch.apply(this, [name].concat(map[name]));\r\n        }\r\n    };\r\n    Model.prototype.has = function (name) {\r\n        return name in this._props;\r\n    };\r\n    Model.prototype.get = function (name) {\r\n        if (name === undefined) {\r\n            return this._props;\r\n        }\r\n        return this._props[name];\r\n    };\r\n    Model.prototype.set = function (name, val) {\r\n        var newProps;\r\n        if (typeof name === 'string') {\r\n            newProps = {};\r\n            newProps[name] = val === undefined ? null : val;\r\n        }\r\n        else {\r\n            newProps = name;\r\n        }\r\n        this.setProps(newProps);\r\n    };\r\n    Model.prototype.reset = function (newProps) {\r\n        var oldProps = this._props;\r\n        var changeset = {}; // will have undefined's to signal unsets\r\n        var name;\r\n        for (name in oldProps) {\r\n            changeset[name] = undefined;\r\n        }\r\n        for (name in newProps) {\r\n            changeset[name] = newProps[name];\r\n        }\r\n        this.setProps(changeset);\r\n    };\r\n    Model.prototype.unset = function (name) {\r\n        var newProps = {};\r\n        var names;\r\n        var i;\r\n        if (typeof name === 'string') {\r\n            names = [name];\r\n        }\r\n        else {\r\n            names = name;\r\n        }\r\n        for (i = 0; i < names.length; i++) {\r\n            newProps[names[i]] = undefined;\r\n        }\r\n        this.setProps(newProps);\r\n    };\r\n    Model.prototype.setProps = function (newProps) {\r\n        var changedProps = {};\r\n        var changedCnt = 0;\r\n        var name;\r\n        var val;\r\n        for (name in newProps) {\r\n            val = newProps[name];\r\n            // a change in value?\r\n            // if an object, don't check equality, because might have been mutated internally.\r\n            // TODO: eventually enforce immutability.\r\n            if (typeof val === 'object' ||\r\n                val !== this._props[name]) {\r\n                changedProps[name] = val;\r\n                changedCnt++;\r\n            }\r\n        }\r\n        if (changedCnt) {\r\n            this.trigger('before:batchChange', changedProps);\r\n            for (name in changedProps) {\r\n                val = changedProps[name];\r\n                this.trigger('before:change', name, val);\r\n                this.trigger('before:change:' + name, val);\r\n            }\r\n            for (name in changedProps) {\r\n                val = changedProps[name];\r\n                if (val === undefined) {\r\n                    delete this._props[name];\r\n                }\r\n                else {\r\n                    this._props[name] = val;\r\n                }\r\n                this.trigger('change:' + name, val);\r\n                this.trigger('change', name, val);\r\n            }\r\n            this.trigger('batchChange', changedProps);\r\n        }\r\n    };\r\n    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {\r\n        var _this = this;\r\n        this.unwatch(name);\r\n        this._watchers[name] = this._watchDeps(depList, function (deps) {\r\n            var res = startFunc.call(_this, deps);\r\n            if (res && res.then) {\r\n                _this.unset(name); // put in an unset state while resolving\r\n                res.then(function (val) {\r\n                    _this.set(name, val);\r\n                });\r\n            }\r\n            else {\r\n                _this.set(name, res);\r\n            }\r\n        }, function (deps) {\r\n            _this.unset(name);\r\n            if (stopFunc) {\r\n                stopFunc.call(_this, deps);\r\n            }\r\n        });\r\n    };\r\n    Model.prototype.unwatch = function (name) {\r\n        var watcher = this._watchers[name];\r\n        if (watcher) {\r\n            delete this._watchers[name];\r\n            watcher.teardown();\r\n        }\r\n    };\r\n    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {\r\n        var _this = this;\r\n        var queuedChangeCnt = 0;\r\n        var depCnt = depList.length;\r\n        var satisfyCnt = 0;\r\n        var values = {}; // what's passed as the `deps` arguments\r\n        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays\r\n        var isCallingStop = false;\r\n        var onBeforeDepChange = function (depName, val, isOptional) {\r\n            queuedChangeCnt++;\r\n            if (queuedChangeCnt === 1) {\r\n                if (satisfyCnt === depCnt) {\r\n                    isCallingStop = true;\r\n                    stopFunc(values);\r\n                    isCallingStop = false;\r\n                }\r\n            }\r\n        };\r\n        var onDepChange = function (depName, val, isOptional) {\r\n            if (val === undefined) {\r\n                // required dependency that was previously set?\r\n                if (!isOptional && values[depName] !== undefined) {\r\n                    satisfyCnt--;\r\n                }\r\n                delete values[depName];\r\n            }\r\n            else {\r\n                // required dependency that was previously unset?\r\n                if (!isOptional && values[depName] === undefined) {\r\n                    satisfyCnt++;\r\n                }\r\n                values[depName] = val;\r\n            }\r\n            queuedChangeCnt--;\r\n            if (!queuedChangeCnt) {\r\n                // now finally satisfied or satisfied all along?\r\n                if (satisfyCnt === depCnt) {\r\n                    // if the stopFunc initiated another value change, ignore it.\r\n                    // it will be processed by another change event anyway.\r\n                    if (!isCallingStop) {\r\n                        startFunc(values);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        // intercept for .on() that remembers handlers\r\n        var bind = function (eventName, handler) {\r\n            _this.on(eventName, handler);\r\n            bindTuples.push([eventName, handler]);\r\n        };\r\n        // listen to dependency changes\r\n        depList.forEach(function (depName) {\r\n            var isOptional = false;\r\n            if (depName.charAt(0) === '?') {\r\n                depName = depName.substring(1);\r\n                isOptional = true;\r\n            }\r\n            bind('before:change:' + depName, function (val) {\r\n                onBeforeDepChange(depName, val, isOptional);\r\n            });\r\n            bind('change:' + depName, function (val) {\r\n                onDepChange(depName, val, isOptional);\r\n            });\r\n        });\r\n        // process current dependency values\r\n        depList.forEach(function (depName) {\r\n            var isOptional = false;\r\n            if (depName.charAt(0) === '?') {\r\n                depName = depName.substring(1);\r\n                isOptional = true;\r\n            }\r\n            if (_this.has(depName)) {\r\n                values[depName] = _this.get(depName);\r\n                satisfyCnt++;\r\n            }\r\n            else if (isOptional) {\r\n                satisfyCnt++;\r\n            }\r\n        });\r\n        // initially satisfied\r\n        if (satisfyCnt === depCnt) {\r\n            startFunc(values);\r\n        }\r\n        return {\r\n            teardown: function () {\r\n                // remove all handlers\r\n                for (var i = 0; i < bindTuples.length; i++) {\r\n                    _this.off(bindTuples[i][0], bindTuples[i][1]);\r\n                }\r\n                bindTuples = null;\r\n                // was satisfied, so call stopFunc\r\n                if (satisfyCnt === depCnt) {\r\n                    stopFunc();\r\n                }\r\n            },\r\n            flash: function () {\r\n                if (satisfyCnt === depCnt) {\r\n                    stopFunc();\r\n                    startFunc(values);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    Model.prototype.flash = function (name) {\r\n        var watcher = this._watchers[name];\r\n        if (watcher) {\r\n            watcher.flash();\r\n        }\r\n    };\r\n    return Model;\r\n}(Class_1.default));\r\nexports.default = Model;\r\nModel.prototype._globalWatchArgs = {}; // mutation protection in Model.watch\r\nEmitterMixin_1.default.mixInto(Model);\r\nListenerMixin_1.default.mixInto(Model);\r\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar RecurringEventDef_1 = __webpack_require__(210);\r\nexports.default = {\r\n    parse: function (eventInput, source) {\r\n        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||\r\n            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {\r\n            return RecurringEventDef_1.default.parse(eventInput, source);\r\n        }\r\n        else {\r\n            return SingleEventDef_1.default.parse(eventInput, source);\r\n        }\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventDefDateMutation = /** @class */ (function () {\r\n    function EventDefDateMutation() {\r\n        this.clearEnd = false;\r\n        this.forceTimed = false;\r\n        this.forceAllDay = false;\r\n    }\r\n    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {\r\n        var clearEnd = dateProfile0.end && !dateProfile1.end;\r\n        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();\r\n        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();\r\n        var dateDelta;\r\n        var endDiff;\r\n        var endDelta;\r\n        var mutation;\r\n        // subtracts the dates in the appropriate way, returning a duration\r\n        function subtractDates(date1, date0) {\r\n            if (largeUnit) {\r\n                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named\r\n            }\r\n            else if (dateProfile1.isAllDay()) {\r\n                return util_1.diffDay(date1, date0); // poorly named\r\n            }\r\n            else {\r\n                return util_1.diffDayTime(date1, date0); // poorly named\r\n            }\r\n        }\r\n        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);\r\n        if (dateProfile1.end) {\r\n            // use unzonedRanges because dateProfile0.end might be null\r\n            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());\r\n            endDelta = endDiff.subtract(dateDelta);\r\n        }\r\n        mutation = new EventDefDateMutation();\r\n        mutation.clearEnd = clearEnd;\r\n        mutation.forceTimed = forceTimed;\r\n        mutation.forceAllDay = forceAllDay;\r\n        mutation.setDateDelta(dateDelta);\r\n        mutation.setEndDelta(endDelta);\r\n        return mutation;\r\n    };\r\n    /*\r\n    returns an undo function.\r\n    */\r\n    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {\r\n        var start = eventDateProfile.start.clone();\r\n        var end = null;\r\n        var shouldRezone = false;\r\n        if (eventDateProfile.end && !this.clearEnd) {\r\n            end = eventDateProfile.end.clone();\r\n        }\r\n        else if (this.endDelta && !end) {\r\n            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n        }\r\n        if (this.forceTimed) {\r\n            shouldRezone = true;\r\n            if (!start.hasTime()) {\r\n                start.time(0);\r\n            }\r\n            if (end && !end.hasTime()) {\r\n                end.time(0);\r\n            }\r\n        }\r\n        else if (this.forceAllDay) {\r\n            if (start.hasTime()) {\r\n                start.stripTime();\r\n            }\r\n            if (end && end.hasTime()) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        if (this.dateDelta) {\r\n            shouldRezone = true;\r\n            start.add(this.dateDelta);\r\n            if (end) {\r\n                end.add(this.dateDelta);\r\n            }\r\n        }\r\n        // do this before adding startDelta to start, so we can work off of start\r\n        if (this.endDelta) {\r\n            shouldRezone = true;\r\n            end.add(this.endDelta);\r\n        }\r\n        if (this.startDelta) {\r\n            shouldRezone = true;\r\n            start.add(this.startDelta);\r\n        }\r\n        if (shouldRezone) {\r\n            start = calendar.applyTimezone(start);\r\n            if (end) {\r\n                end = calendar.applyTimezone(end);\r\n            }\r\n        }\r\n        // TODO: okay to access calendar option?\r\n        if (!end && calendar.opt('forceEventDuration')) {\r\n            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n        }\r\n        return new EventDateProfile_1.default(start, end, calendar);\r\n    };\r\n    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {\r\n        if (dateDelta && dateDelta.valueOf()) {\r\n            this.dateDelta = dateDelta;\r\n        }\r\n        else {\r\n            this.dateDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {\r\n        if (startDelta && startDelta.valueOf()) {\r\n            this.startDelta = startDelta;\r\n        }\r\n        else {\r\n            this.startDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {\r\n        if (endDelta && endDelta.valueOf()) {\r\n            this.endDelta = endDelta;\r\n        }\r\n        else {\r\n            this.endDelta = null;\r\n        }\r\n    };\r\n    EventDefDateMutation.prototype.isEmpty = function () {\r\n        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&\r\n            !this.dateDelta && !this.startDelta && !this.endDelta;\r\n    };\r\n    return EventDefDateMutation;\r\n}());\r\nexports.default = EventDefDateMutation;\r\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StandardTheme_1 = __webpack_require__(213);\r\nvar JqueryUiTheme_1 = __webpack_require__(214);\r\nvar themeClassHash = {};\r\nfunction defineThemeSystem(themeName, themeClass) {\r\n    themeClassHash[themeName] = themeClass;\r\n}\r\nexports.defineThemeSystem = defineThemeSystem;\r\nfunction getThemeSystemClass(themeSetting) {\r\n    if (!themeSetting) {\r\n        return StandardTheme_1.default;\r\n    }\r\n    else if (themeSetting === true) {\r\n        return JqueryUiTheme_1.default;\r\n    }\r\n    else {\r\n        return themeClassHash[themeSetting];\r\n    }\r\n}\r\nexports.getThemeSystemClass = getThemeSystemClass;\r\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar ArrayEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayEventSource, _super);\r\n    function ArrayEventSource(calendar) {\r\n        var _this = _super.call(this, calendar) || this;\r\n        _this.eventDefs = []; // for if setRawEventDefs is never called\r\n        return _this;\r\n    }\r\n    ArrayEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if ($.isArray(rawInput.events)) {\r\n            rawProps = rawInput;\r\n        }\r\n        else if ($.isArray(rawInput)) {\r\n            rawProps = { events: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {\r\n        this.rawEventDefs = rawEventDefs;\r\n        this.eventDefs = this.parseEventDefs(rawEventDefs);\r\n    };\r\n    ArrayEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var eventDefs = this.eventDefs;\r\n        var i;\r\n        if (this.currentTimezone != null &&\r\n            this.currentTimezone !== timezone) {\r\n            for (i = 0; i < eventDefs.length; i++) {\r\n                if (eventDefs[i] instanceof SingleEventDef_1.default) {\r\n                    eventDefs[i].rezone();\r\n                }\r\n            }\r\n        }\r\n        this.currentTimezone = timezone;\r\n        return Promise_1.default.resolve(eventDefs);\r\n    };\r\n    ArrayEventSource.prototype.addEventDef = function (eventDef) {\r\n        this.eventDefs.push(eventDef);\r\n    };\r\n    /*\r\n    eventDefId already normalized to a string\r\n    */\r\n    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {\r\n        return util_1.removeMatching(this.eventDefs, function (eventDef) {\r\n            return eventDef.id === eventDefId;\r\n        });\r\n    };\r\n    ArrayEventSource.prototype.removeAllEventDefs = function () {\r\n        this.eventDefs = [];\r\n    };\r\n    ArrayEventSource.prototype.getPrimitive = function () {\r\n        return this.rawEventDefs;\r\n    };\r\n    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        this.setRawEventDefs(rawProps.events);\r\n        return superSuccess;\r\n    };\r\n    return ArrayEventSource;\r\n}(EventSource_1.default));\r\nexports.default = ArrayEventSource;\r\nArrayEventSource.defineStandardProps({\r\n    events: false // don't automatically transfer\r\n});\r\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\n/*\r\nA cache for the left/right/top/bottom/width/height values for one or more elements.\r\nWorks with both offset (from topleft document) and position (from offsetParent).\r\n\noptions:\r\n- els\r\n- isHorizontal\r\n- isVertical\r\n*/\r\nvar CoordCache = /** @class */ (function () {\r\n    function CoordCache(options) {\r\n        this.isHorizontal = false; // whether to query for left/right/width\r\n        this.isVertical = false; // whether to query for top/bottom/height\r\n        this.els = $(options.els);\r\n        this.isHorizontal = options.isHorizontal;\r\n        this.isVertical = options.isVertical;\r\n        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\r\n    }\r\n    // Queries the els for coordinates and stores them.\r\n    // Call this method before using and of the get* methods below.\r\n    CoordCache.prototype.build = function () {\r\n        var offsetParentEl = this.forcedOffsetParentEl;\r\n        if (!offsetParentEl && this.els.length > 0) {\r\n            offsetParentEl = this.els.eq(0).offsetParent();\r\n        }\r\n        this.origin = offsetParentEl ?\r\n            offsetParentEl.offset() :\r\n            null;\r\n        this.boundingRect = this.queryBoundingRect();\r\n        if (this.isHorizontal) {\r\n            this.buildElHorizontals();\r\n        }\r\n        if (this.isVertical) {\r\n            this.buildElVerticals();\r\n        }\r\n    };\r\n    // Destroys all internal data about coordinates, freeing memory\r\n    CoordCache.prototype.clear = function () {\r\n        this.origin = null;\r\n        this.boundingRect = null;\r\n        this.lefts = null;\r\n        this.rights = null;\r\n        this.tops = null;\r\n        this.bottoms = null;\r\n    };\r\n    // When called, if coord caches aren't built, builds them\r\n    CoordCache.prototype.ensureBuilt = function () {\r\n        if (!this.origin) {\r\n            this.build();\r\n        }\r\n    };\r\n    // Populates the left/right internal coordinate arrays\r\n    CoordCache.prototype.buildElHorizontals = function () {\r\n        var lefts = [];\r\n        var rights = [];\r\n        this.els.each(function (i, node) {\r\n            var el = $(node);\r\n            var left = el.offset().left;\r\n            var width = el.outerWidth();\r\n            lefts.push(left);\r\n            rights.push(left + width);\r\n        });\r\n        this.lefts = lefts;\r\n        this.rights = rights;\r\n    };\r\n    // Populates the top/bottom internal coordinate arrays\r\n    CoordCache.prototype.buildElVerticals = function () {\r\n        var tops = [];\r\n        var bottoms = [];\r\n        this.els.each(function (i, node) {\r\n            var el = $(node);\r\n            var top = el.offset().top;\r\n            var height = el.outerHeight();\r\n            tops.push(top);\r\n            bottoms.push(top + height);\r\n        });\r\n        this.tops = tops;\r\n        this.bottoms = bottoms;\r\n    };\r\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\r\n    // If no intersection is made, returns undefined.\r\n    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {\r\n        this.ensureBuilt();\r\n        var lefts = this.lefts;\r\n        var rights = this.rights;\r\n        var len = lefts.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {\r\n                return i;\r\n            }\r\n        }\r\n    };\r\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\r\n    // If no intersection is made, returns undefined.\r\n    CoordCache.prototype.getVerticalIndex = function (topOffset) {\r\n        this.ensureBuilt();\r\n        var tops = this.tops;\r\n        var bottoms = this.bottoms;\r\n        var len = tops.length;\r\n        var i;\r\n        for (i = 0; i < len; i++) {\r\n            if (topOffset >= tops[i] && topOffset < bottoms[i]) {\r\n                return i;\r\n            }\r\n        }\r\n    };\r\n    // Gets the left offset (from document left) of the element at the given index\r\n    CoordCache.prototype.getLeftOffset = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.lefts[leftIndex];\r\n    };\r\n    // Gets the left position (from offsetParent left) of the element at the given index\r\n    CoordCache.prototype.getLeftPosition = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.lefts[leftIndex] - this.origin.left;\r\n    };\r\n    // Gets the right offset (from document left) of the element at the given index.\r\n    // This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\r\n    CoordCache.prototype.getRightOffset = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex];\r\n    };\r\n    // Gets the right position (from offsetParent left) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\r\n    CoordCache.prototype.getRightPosition = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex] - this.origin.left;\r\n    };\r\n    // Gets the width of the element at the given index\r\n    CoordCache.prototype.getWidth = function (leftIndex) {\r\n        this.ensureBuilt();\r\n        return this.rights[leftIndex] - this.lefts[leftIndex];\r\n    };\r\n    // Gets the top offset (from document top) of the element at the given index\r\n    CoordCache.prototype.getTopOffset = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.tops[topIndex];\r\n    };\r\n    // Gets the top position (from offsetParent top) of the element at the given position\r\n    CoordCache.prototype.getTopPosition = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.tops[topIndex] - this.origin.top;\r\n    };\r\n    // Gets the bottom offset (from the document top) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n    CoordCache.prototype.getBottomOffset = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex];\r\n    };\r\n    // Gets the bottom position (from the offsetParent top) of the element at the given index.\r\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n    CoordCache.prototype.getBottomPosition = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex] - this.origin.top;\r\n    };\r\n    // Gets the height of the element at the given index\r\n    CoordCache.prototype.getHeight = function (topIndex) {\r\n        this.ensureBuilt();\r\n        return this.bottoms[topIndex] - this.tops[topIndex];\r\n    };\r\n    // Bounding Rect\r\n    // TODO: decouple this from CoordCache\r\n    // Compute and return what the elements' bounding rectangle is, from the user's perspective.\r\n    // Right now, only returns a rectangle if constrained by an overflow:scroll element.\r\n    // Returns null if there are no elements\r\n    CoordCache.prototype.queryBoundingRect = function () {\r\n        var scrollParentEl;\r\n        if (this.els.length > 0) {\r\n            scrollParentEl = util_1.getScrollParent(this.els.eq(0));\r\n            if (!scrollParentEl.is(document)) {\r\n                return util_1.getClientRect(scrollParentEl);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {\r\n        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\r\n    };\r\n    CoordCache.prototype.isLeftInBounds = function (leftOffset) {\r\n        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\r\n    };\r\n    CoordCache.prototype.isTopInBounds = function (topOffset) {\r\n        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\r\n    };\r\n    return CoordCache;\r\n}());\r\nexports.default = CoordCache;\r\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\n/* Tracks a drag's mouse movement, firing various handlers\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// TODO: use Emitter\r\nvar DragListener = /** @class */ (function () {\r\n    function DragListener(options) {\r\n        this.isInteracting = false;\r\n        this.isDistanceSurpassed = false;\r\n        this.isDelayEnded = false;\r\n        this.isDragging = false;\r\n        this.isTouch = false;\r\n        this.isGeneric = false; // initiated by 'dragstart' (jqui)\r\n        this.shouldCancelTouchScroll = true;\r\n        this.scrollAlwaysKills = false;\r\n        this.isAutoScroll = false;\r\n        // defaults\r\n        this.scrollSensitivity = 30; // pixels from edge for scrolling to start\r\n        this.scrollSpeed = 200; // pixels per second, at maximum speed\r\n        this.scrollIntervalMs = 50; // millisecond wait between scroll increment\r\n        this.options = options || {};\r\n    }\r\n    // Interaction (high-level)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.startInteraction = function (ev, extraOptions) {\r\n        if (extraOptions === void 0) { extraOptions = {}; }\r\n        if (ev.type === 'mousedown') {\r\n            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {\r\n                return;\r\n            }\r\n            else if (!util_1.isPrimaryMouseButton(ev)) {\r\n                return;\r\n            }\r\n            else {\r\n                ev.preventDefault(); // prevents native selection in most browsers\r\n            }\r\n        }\r\n        if (!this.isInteracting) {\r\n            // process options\r\n            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);\r\n            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);\r\n            this.subjectEl = this.options.subjectEl;\r\n            util_1.preventSelection($('body'));\r\n            this.isInteracting = true;\r\n            this.isTouch = util_1.getEvIsTouch(ev);\r\n            this.isGeneric = ev.type === 'dragstart';\r\n            this.isDelayEnded = false;\r\n            this.isDistanceSurpassed = false;\r\n            this.originX = util_1.getEvX(ev);\r\n            this.originY = util_1.getEvY(ev);\r\n            this.scrollEl = util_1.getScrollParent($(ev.target));\r\n            this.bindHandlers();\r\n            this.initAutoScroll();\r\n            this.handleInteractionStart(ev);\r\n            this.startDelay(ev);\r\n            if (!this.minDistance) {\r\n                this.handleDistanceSurpassed(ev);\r\n            }\r\n        }\r\n    };\r\n    DragListener.prototype.handleInteractionStart = function (ev) {\r\n        this.trigger('interactionStart', ev);\r\n    };\r\n    DragListener.prototype.endInteraction = function (ev, isCancelled) {\r\n        if (this.isInteracting) {\r\n            this.endDrag(ev);\r\n            if (this.delayTimeoutId) {\r\n                clearTimeout(this.delayTimeoutId);\r\n                this.delayTimeoutId = null;\r\n            }\r\n            this.destroyAutoScroll();\r\n            this.unbindHandlers();\r\n            this.isInteracting = false;\r\n            this.handleInteractionEnd(ev, isCancelled);\r\n            util_1.allowSelection($('body'));\r\n        }\r\n    };\r\n    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {\r\n        this.trigger('interactionEnd', ev, isCancelled || false);\r\n    };\r\n    // Binding To DOM\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.bindHandlers = function () {\r\n        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\r\n        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\r\n        var globalEmitter = GlobalEmitter_1.default.get();\r\n        if (this.isGeneric) {\r\n            this.listenTo($(document), {\r\n                drag: this.handleMove,\r\n                dragstop: this.endInteraction\r\n            });\r\n        }\r\n        else if (this.isTouch) {\r\n            this.listenTo(globalEmitter, {\r\n                touchmove: this.handleTouchMove,\r\n                touchend: this.endInteraction,\r\n                scroll: this.handleTouchScroll\r\n            });\r\n        }\r\n        else {\r\n            this.listenTo(globalEmitter, {\r\n                mousemove: this.handleMouseMove,\r\n                mouseup: this.endInteraction\r\n            });\r\n        }\r\n        this.listenTo(globalEmitter, {\r\n            selectstart: util_1.preventDefault,\r\n            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools\r\n        });\r\n    };\r\n    DragListener.prototype.unbindHandlers = function () {\r\n        this.stopListeningTo(GlobalEmitter_1.default.get());\r\n        this.stopListeningTo($(document)); // for isGeneric\r\n    };\r\n    // Drag (high-level)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // extraOptions ignored if drag already started\r\n    DragListener.prototype.startDrag = function (ev, extraOptions) {\r\n        this.startInteraction(ev, extraOptions); // ensure interaction began\r\n        if (!this.isDragging) {\r\n            this.isDragging = true;\r\n            this.handleDragStart(ev);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDragStart = function (ev) {\r\n        this.trigger('dragStart', ev);\r\n    };\r\n    DragListener.prototype.handleMove = function (ev) {\r\n        var dx = util_1.getEvX(ev) - this.originX;\r\n        var dy = util_1.getEvY(ev) - this.originY;\r\n        var minDistance = this.minDistance;\r\n        var distanceSq; // current distance from the origin, squared\r\n        if (!this.isDistanceSurpassed) {\r\n            distanceSq = dx * dx + dy * dy;\r\n            if (distanceSq >= minDistance * minDistance) {\r\n                this.handleDistanceSurpassed(ev);\r\n            }\r\n        }\r\n        if (this.isDragging) {\r\n            this.handleDrag(dx, dy, ev);\r\n        }\r\n    };\r\n    // Called while the mouse is being moved and when we know a legitimate drag is taking place\r\n    DragListener.prototype.handleDrag = function (dx, dy, ev) {\r\n        this.trigger('drag', dx, dy, ev);\r\n        this.updateAutoScroll(ev); // will possibly cause scrolling\r\n    };\r\n    DragListener.prototype.endDrag = function (ev) {\r\n        if (this.isDragging) {\r\n            this.isDragging = false;\r\n            this.handleDragEnd(ev);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDragEnd = function (ev) {\r\n        this.trigger('dragEnd', ev);\r\n    };\r\n    // Delay\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.startDelay = function (initialEv) {\r\n        var _this = this;\r\n        if (this.delay) {\r\n            this.delayTimeoutId = setTimeout(function () {\r\n                _this.handleDelayEnd(initialEv);\r\n            }, this.delay);\r\n        }\r\n        else {\r\n            this.handleDelayEnd(initialEv);\r\n        }\r\n    };\r\n    DragListener.prototype.handleDelayEnd = function (initialEv) {\r\n        this.isDelayEnded = true;\r\n        if (this.isDistanceSurpassed) {\r\n            this.startDrag(initialEv);\r\n        }\r\n    };\r\n    // Distance\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleDistanceSurpassed = function (ev) {\r\n        this.isDistanceSurpassed = true;\r\n        if (this.isDelayEnded) {\r\n            this.startDrag(ev);\r\n        }\r\n    };\r\n    // Mouse / Touch\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleTouchMove = function (ev) {\r\n        // prevent inertia and touchmove-scrolling while dragging\r\n        if (this.isDragging && this.shouldCancelTouchScroll) {\r\n            ev.preventDefault();\r\n        }\r\n        this.handleMove(ev);\r\n    };\r\n    DragListener.prototype.handleMouseMove = function (ev) {\r\n        this.handleMove(ev);\r\n    };\r\n    // Scrolling (unrelated to auto-scroll)\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.handleTouchScroll = function (ev) {\r\n        // if the drag is being initiated by touch, but a scroll happens before\r\n        // the drag-initiating delay is over, cancel the drag\r\n        if (!this.isDragging || this.scrollAlwaysKills) {\r\n            this.endInteraction(ev, true); // isCancelled=true\r\n        }\r\n    };\r\n    // Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Triggers a callback. Calls a function in the option hash of the same name.\r\n    // Arguments beyond the first `name` are forwarded on.\r\n    DragListener.prototype.trigger = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.options[name]) {\r\n            this.options[name].apply(this, args);\r\n        }\r\n        // makes _methods callable by event name. TODO: kill this\r\n        if (this['_' + name]) {\r\n            this['_' + name].apply(this, args);\r\n        }\r\n    };\r\n    // Auto-scroll\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DragListener.prototype.initAutoScroll = function () {\r\n        var scrollEl = this.scrollEl;\r\n        this.isAutoScroll =\r\n            this.options.scroll &&\r\n                scrollEl &&\r\n                !scrollEl.is(window) &&\r\n                !scrollEl.is(document);\r\n        if (this.isAutoScroll) {\r\n            // debounce makes sure rapid calls don't happen\r\n            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));\r\n        }\r\n    };\r\n    DragListener.prototype.destroyAutoScroll = function () {\r\n        this.endAutoScroll(); // kill any animation loop\r\n        // remove the scroll handler if there is a scrollEl\r\n        if (this.isAutoScroll) {\r\n            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\r\n        }\r\n    };\r\n    // Computes and stores the bounding rectangle of scrollEl\r\n    DragListener.prototype.computeScrollBounds = function () {\r\n        if (this.isAutoScroll) {\r\n            this.scrollBounds = util_1.getOuterRect(this.scrollEl);\r\n            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\r\n        }\r\n    };\r\n    // Called when the dragging is in progress and scrolling should be updated\r\n    DragListener.prototype.updateAutoScroll = function (ev) {\r\n        var sensitivity = this.scrollSensitivity;\r\n        var bounds = this.scrollBounds;\r\n        var topCloseness;\r\n        var bottomCloseness;\r\n        var leftCloseness;\r\n        var rightCloseness;\r\n        var topVel = 0;\r\n        var leftVel = 0;\r\n        if (bounds) {\r\n            // compute closeness to edges. valid range is from 0.0 - 1.0\r\n            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;\r\n            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;\r\n            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;\r\n            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;\r\n            // translate vertical closeness into velocity.\r\n            // mouse must be completely in bounds for velocity to happen.\r\n            if (topCloseness >= 0 && topCloseness <= 1) {\r\n                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\r\n            }\r\n            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {\r\n                topVel = bottomCloseness * this.scrollSpeed;\r\n            }\r\n            // translate horizontal closeness into velocity\r\n            if (leftCloseness >= 0 && leftCloseness <= 1) {\r\n                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\r\n            }\r\n            else if (rightCloseness >= 0 && rightCloseness <= 1) {\r\n                leftVel = rightCloseness * this.scrollSpeed;\r\n            }\r\n        }\r\n        this.setScrollVel(topVel, leftVel);\r\n    };\r\n    // Sets the speed-of-scrolling for the scrollEl\r\n    DragListener.prototype.setScrollVel = function (topVel, leftVel) {\r\n        this.scrollTopVel = topVel;\r\n        this.scrollLeftVel = leftVel;\r\n        this.constrainScrollVel(); // massages into realistic values\r\n        // if there is non-zero velocity, and an animation loop hasn't already started, then START\r\n        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\r\n            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`\r\n            this.scrollIntervalMs);\r\n        }\r\n    };\r\n    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\r\n    DragListener.prototype.constrainScrollVel = function () {\r\n        var el = this.scrollEl;\r\n        if (this.scrollTopVel < 0) {\r\n            if (el.scrollTop() <= 0) {\r\n                this.scrollTopVel = 0;\r\n            }\r\n        }\r\n        else if (this.scrollTopVel > 0) {\r\n            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {\r\n                this.scrollTopVel = 0;\r\n            }\r\n        }\r\n        if (this.scrollLeftVel < 0) {\r\n            if (el.scrollLeft() <= 0) {\r\n                this.scrollLeftVel = 0;\r\n            }\r\n        }\r\n        else if (this.scrollLeftVel > 0) {\r\n            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {\r\n                this.scrollLeftVel = 0;\r\n            }\r\n        }\r\n    };\r\n    // This function gets called during every iteration of the scrolling animation loop\r\n    DragListener.prototype.scrollIntervalFunc = function () {\r\n        var el = this.scrollEl;\r\n        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\r\n        // change the value of scrollEl's scroll\r\n        if (this.scrollTopVel) {\r\n            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\r\n        }\r\n        if (this.scrollLeftVel) {\r\n            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\r\n        }\r\n        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities\r\n        // if scrolled all the way, which causes the vels to be zero, stop the animation loop\r\n        if (!this.scrollTopVel && !this.scrollLeftVel) {\r\n            this.endAutoScroll();\r\n        }\r\n    };\r\n    // Kills any existing scrolling animation loop\r\n    DragListener.prototype.endAutoScroll = function () {\r\n        if (this.scrollIntervalId) {\r\n            clearInterval(this.scrollIntervalId);\r\n            this.scrollIntervalId = null;\r\n            this.handleScrollEnd();\r\n        }\r\n    };\r\n    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\r\n    DragListener.prototype.handleDebouncedScroll = function () {\r\n        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation\r\n        if (!this.scrollIntervalId) {\r\n            this.handleScrollEnd();\r\n        }\r\n    };\r\n    DragListener.prototype.handleScrollEnd = function () {\r\n        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n    };\r\n    return DragListener;\r\n}());\r\nexports.default = DragListener;\r\nListenerMixin_1.default.mixInto(DragListener);\r\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar Mixin_1 = __webpack_require__(14);\r\n/*\r\nA set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\r\nPrerequisite: the object being mixed into needs to be a *Grid*\r\n*/\r\nvar DayTableMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayTableMixin, _super);\r\n    function DayTableMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Populates internal variables used for date calculation and rendering\r\n    DayTableMixin.prototype.updateDayTable = function () {\r\n        var t = this;\r\n        var view = t.view;\r\n        var calendar = view.calendar;\r\n        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);\r\n        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);\r\n        var dayIndex = -1;\r\n        var dayIndices = [];\r\n        var dayDates = [];\r\n        var daysPerRow;\r\n        var firstDay;\r\n        var rowCnt;\r\n        while (date.isBefore(end)) {\r\n            if (view.isHiddenDay(date)) {\r\n                dayIndices.push(dayIndex + 0.5); // mark that it's between indices\r\n            }\r\n            else {\r\n                dayIndex++;\r\n                dayIndices.push(dayIndex);\r\n                dayDates.push(date.clone());\r\n            }\r\n            date.add(1, 'days');\r\n        }\r\n        if (this.breakOnWeeks) {\r\n            // count columns until the day-of-week repeats\r\n            firstDay = dayDates[0].day();\r\n            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\r\n                if (dayDates[daysPerRow].day() === firstDay) {\r\n                    break;\r\n                }\r\n            }\r\n            rowCnt = Math.ceil(dayDates.length / daysPerRow);\r\n        }\r\n        else {\r\n            rowCnt = 1;\r\n            daysPerRow = dayDates.length;\r\n        }\r\n        this.dayDates = dayDates;\r\n        this.dayIndices = dayIndices;\r\n        this.daysPerRow = daysPerRow;\r\n        this.rowCnt = rowCnt;\r\n        this.updateDayTableCols();\r\n    };\r\n    // Computes and assigned the colCnt property and updates any options that may be computed from it\r\n    DayTableMixin.prototype.updateDayTableCols = function () {\r\n        this.colCnt = this.computeColCnt();\r\n        this.colHeadFormat =\r\n            this.opt('columnHeaderFormat') ||\r\n                this.opt('columnFormat') || // deprecated\r\n                this.computeColHeadFormat();\r\n    };\r\n    // Determines how many columns there should be in the table\r\n    DayTableMixin.prototype.computeColCnt = function () {\r\n        return this.daysPerRow;\r\n    };\r\n    // Computes the ambiguously-timed moment for the given cell\r\n    DayTableMixin.prototype.getCellDate = function (row, col) {\r\n        return this.dayDates[this.getCellDayIndex(row, col)].clone();\r\n    };\r\n    // Computes the ambiguously-timed date range for the given cell\r\n    DayTableMixin.prototype.getCellRange = function (row, col) {\r\n        var start = this.getCellDate(row, col);\r\n        var end = start.clone().add(1, 'days');\r\n        return { start: start, end: end };\r\n    };\r\n    // Returns the number of day cells, chronologically, from the first of the grid (0-based)\r\n    DayTableMixin.prototype.getCellDayIndex = function (row, col) {\r\n        return row * this.daysPerRow + this.getColDayIndex(col);\r\n    };\r\n    // Returns the numner of day cells, chronologically, from the first cell in *any given row*\r\n    DayTableMixin.prototype.getColDayIndex = function (col) {\r\n        if (this.isRTL) {\r\n            return this.colCnt - 1 - col;\r\n        }\r\n        else {\r\n            return col;\r\n        }\r\n    };\r\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\r\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\r\n    // If before the first offset, returns a negative number.\r\n    // If after the last offset, returns an offset past the last cell offset.\r\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\r\n    DayTableMixin.prototype.getDateDayIndex = function (date) {\r\n        var dayIndices = this.dayIndices;\r\n        var dayOffset = date.diff(this.dayDates[0], 'days');\r\n        if (dayOffset < 0) {\r\n            return dayIndices[0] - 1;\r\n        }\r\n        else if (dayOffset >= dayIndices.length) {\r\n            return dayIndices[dayIndices.length - 1] + 1;\r\n        }\r\n        else {\r\n            return dayIndices[dayOffset];\r\n        }\r\n    };\r\n    /* Options\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\r\n    DayTableMixin.prototype.computeColHeadFormat = function () {\r\n        // if more than one week row, or if there are a lot of columns with not much space,\r\n        // put just the day numbers will be in each cell\r\n        if (this.rowCnt > 1 || this.colCnt > 10) {\r\n            return 'ddd'; // \"Sat\"\r\n        }\r\n        else if (this.colCnt > 1) {\r\n            return this.opt('dayOfMonthFormat'); // \"Sat 12/10\"\r\n        }\r\n        else {\r\n            return 'dddd'; // \"Saturday\"\r\n        }\r\n    };\r\n    /* Slicing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Slices up a date range into a segment for every week-row it intersects with\r\n    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {\r\n        var daysPerRow = this.daysPerRow;\r\n        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n        var segs = [];\r\n        var row;\r\n        var rowFirst;\r\n        var rowLast; // inclusive day-index range for current row\r\n        var segFirst;\r\n        var segLast; // inclusive day-index range for segment\r\n        for (row = 0; row < this.rowCnt; row++) {\r\n            rowFirst = row * daysPerRow;\r\n            rowLast = rowFirst + daysPerRow - 1;\r\n            // intersect segment's offset range with the row's\r\n            segFirst = Math.max(rangeFirst, rowFirst);\r\n            segLast = Math.min(rangeLast, rowLast);\r\n            // deal with in-between indices\r\n            segFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n            segLast = Math.floor(segLast); // in-between ends round to prev cell\r\n            if (segFirst <= segLast) {\r\n                segs.push({\r\n                    row: row,\r\n                    // normalize to start of row\r\n                    firstRowDayIndex: segFirst - rowFirst,\r\n                    lastRowDayIndex: segLast - rowFirst,\r\n                    // must be matching integers to be the segment's start/end\r\n                    isStart: segFirst === rangeFirst,\r\n                    isEnd: segLast === rangeLast\r\n                });\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    // Slices up a date range into a segment for every day-cell it intersects with.\r\n    // TODO: make more DRY with sliceRangeByRow somehow.\r\n    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {\r\n        var daysPerRow = this.daysPerRow;\r\n        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n        var segs = [];\r\n        var row;\r\n        var rowFirst;\r\n        var rowLast; // inclusive day-index range for current row\r\n        var i;\r\n        var segFirst;\r\n        var segLast; // inclusive day-index range for segment\r\n        for (row = 0; row < this.rowCnt; row++) {\r\n            rowFirst = row * daysPerRow;\r\n            rowLast = rowFirst + daysPerRow - 1;\r\n            for (i = rowFirst; i <= rowLast; i++) {\r\n                // intersect segment's offset range with the row's\r\n                segFirst = Math.max(rangeFirst, i);\r\n                segLast = Math.min(rangeLast, i);\r\n                // deal with in-between indices\r\n                segFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n                segLast = Math.floor(segLast); // in-between ends round to prev cell\r\n                if (segFirst <= segLast) {\r\n                    segs.push({\r\n                        row: row,\r\n                        // normalize to start of row\r\n                        firstRowDayIndex: segFirst - rowFirst,\r\n                        lastRowDayIndex: segLast - rowFirst,\r\n                        // must be matching integers to be the segment's start/end\r\n                        isStart: segFirst === rangeFirst,\r\n                        isEnd: segLast === rangeLast\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Header Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderHeadHtml = function () {\r\n        var theme = this.view.calendar.theme;\r\n        return '' +\r\n            '<div class=\"fc-row ' + theme.getClass('headerRow') + '\">' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            '<thead>' +\r\n            this.renderHeadTrHtml() +\r\n            '</thead>' +\r\n            '</table>' +\r\n            '</div>';\r\n    };\r\n    DayTableMixin.prototype.renderHeadIntroHtml = function () {\r\n        return this.renderIntroHtml(); // fall back to generic\r\n    };\r\n    DayTableMixin.prototype.renderHeadTrHtml = function () {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderHeadIntroHtml()) +\r\n            this.renderHeadDateCellsHtml() +\r\n            (this.isRTL ? this.renderHeadIntroHtml() : '') +\r\n            '</tr>';\r\n    };\r\n    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(0, col);\r\n            htmls.push(this.renderHeadDateCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    // TODO: when internalApiVersion, accept an object for HTML attributes\r\n    // (colspan should be no different)\r\n    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {\r\n        var t = this;\r\n        var view = t.view;\r\n        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var classNames = [\r\n            'fc-day-header',\r\n            view.calendar.theme.getClass('widgetHeader')\r\n        ];\r\n        var innerHtml;\r\n        if (typeof t.opt('columnHeaderHtml') === 'function') {\r\n            innerHtml = t.opt('columnHeaderHtml')(date);\r\n        }\r\n        else if (typeof t.opt('columnHeaderText') === 'function') {\r\n            innerHtml = util_1.htmlEscape(t.opt('columnHeaderText')(date));\r\n        }\r\n        else {\r\n            innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));\r\n        }\r\n        // if only one row of days, the classNames on the header can represent the specific days beneath\r\n        if (t.rowCnt === 1) {\r\n            classNames = classNames.concat(\r\n            // includes the day-of-week class\r\n            // noThemeHighlight=true (don't highlight the header)\r\n            t.getDayClasses(date, true));\r\n        }\r\n        else {\r\n            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class\r\n        }\r\n        return '' +\r\n            '<th class=\"' + classNames.join(' ') + '\"' +\r\n            ((isDateValid && t.rowCnt) === 1 ?\r\n                ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\r\n                '') +\r\n            (colspan > 1 ?\r\n                ' colspan=\"' + colspan + '\"' :\r\n                '') +\r\n            (otherAttrs ?\r\n                ' ' + otherAttrs :\r\n                '') +\r\n            '>' +\r\n            (isDateValid ?\r\n                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\r\n                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :\r\n                // if not valid, display text, but no link\r\n                innerHtml) +\r\n            '</th>';\r\n    };\r\n    /* Background Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderBgTrHtml = function (row) {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +\r\n            this.renderBgCellsHtml(row) +\r\n            (this.isRTL ? this.renderBgIntroHtml(row) : '') +\r\n            '</tr>';\r\n    };\r\n    DayTableMixin.prototype.renderBgIntroHtml = function (row) {\r\n        return this.renderIntroHtml(); // fall back to generic\r\n    };\r\n    DayTableMixin.prototype.renderBgCellsHtml = function (row) {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(row, col);\r\n            htmls.push(this.renderBgCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {\r\n        var t = this;\r\n        var view = t.view;\r\n        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var classes = t.getDayClasses(date);\r\n        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));\r\n        return '<td class=\"' + classes.join(' ') + '\"' +\r\n            (isDateValid ?\r\n                ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : // if date has a time, won't format it\r\n                '') +\r\n            (otherAttrs ?\r\n                ' ' + otherAttrs :\r\n                '') +\r\n            '></td>';\r\n    };\r\n    /* Generic\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayTableMixin.prototype.renderIntroHtml = function () {\r\n        // Generates the default HTML intro for any row. User classes should override\r\n    };\r\n    // TODO: a generic method for dealing with <tr>, RTL, intro\r\n    // when increment internalApiVersion\r\n    // wrapTr (scheduler)\r\n    /* Utils\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Applies the generic \"intro\" and \"outro\" HTML to the given cells.\r\n    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\r\n    DayTableMixin.prototype.bookendCells = function (trEl) {\r\n        var introHtml = this.renderIntroHtml();\r\n        if (introHtml) {\r\n            if (this.isRTL) {\r\n                trEl.append(introHtml);\r\n            }\r\n            else {\r\n                trEl.prepend(introHtml);\r\n            }\r\n        }\r\n    };\r\n    return DayTableMixin;\r\n}(Mixin_1.default));\r\nexports.default = DayTableMixin;\r\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BusinessHourRenderer = /** @class */ (function () {\r\n    /*\r\n    component implements:\r\n      - eventRangesToEventFootprints\r\n      - eventFootprintsToSegs\r\n    */\r\n    function BusinessHourRenderer(component, fillRenderer) {\r\n        this.component = component;\r\n        this.fillRenderer = fillRenderer;\r\n    }\r\n    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {\r\n        var component = this.component;\r\n        var unzonedRange = component._getDateProfile().activeUnzonedRange;\r\n        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);\r\n        var eventFootprints = eventInstanceGroup ?\r\n            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :\r\n            [];\r\n        this.renderEventFootprints(eventFootprints);\r\n    };\r\n    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        this.renderSegs(segs);\r\n        this.segs = segs;\r\n    };\r\n    BusinessHourRenderer.prototype.renderSegs = function (segs) {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderSegs('businessHours', segs, {\r\n                getClasses: function (seg) {\r\n                    return ['fc-nonbusiness', 'fc-bgevent'];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    BusinessHourRenderer.prototype.unrender = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('businessHours');\r\n        }\r\n        this.segs = null;\r\n    };\r\n    BusinessHourRenderer.prototype.getSegs = function () {\r\n        return this.segs || [];\r\n    };\r\n    return BusinessHourRenderer;\r\n}());\r\nexports.default = BusinessHourRenderer;\r\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar FillRenderer = /** @class */ (function () {\r\n    function FillRenderer(component) {\r\n        this.fillSegTag = 'div';\r\n        this.component = component;\r\n        this.elsByFill = {};\r\n    }\r\n    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {\r\n        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);\r\n    };\r\n    FillRenderer.prototype.renderSegs = function (type, segs, props) {\r\n        var els;\r\n        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs\r\n        els = this.attachSegEls(type, segs);\r\n        if (els) {\r\n            this.reportEls(type, els);\r\n        }\r\n        return segs;\r\n    };\r\n    // Unrenders a specific type of fill that is currently rendered on the grid\r\n    FillRenderer.prototype.unrender = function (type) {\r\n        var el = this.elsByFill[type];\r\n        if (el) {\r\n            el.remove();\r\n            delete this.elsByFill[type];\r\n        }\r\n    };\r\n    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\r\n    // Only returns segments that successfully rendered.\r\n    FillRenderer.prototype.buildSegEls = function (type, segs, props) {\r\n        var _this = this;\r\n        var html = '';\r\n        var renderedSegs = [];\r\n        var i;\r\n        if (segs.length) {\r\n            // build a large concatenation of segment HTML\r\n            for (i = 0; i < segs.length; i++) {\r\n                html += this.buildSegHtml(type, segs[i], props);\r\n            }\r\n            // Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n            // Then, compute the 'el' for each segment.\r\n            $(html).each(function (i, node) {\r\n                var seg = segs[i];\r\n                var el = $(node);\r\n                // allow custom filter methods per-type\r\n                if (props.filterEl) {\r\n                    el = props.filterEl(seg, el);\r\n                }\r\n                if (el) {\r\n                    el = $(el); // allow custom filter to return raw DOM node\r\n                    // correct element type? (would be bad if a non-TD were inserted into a table for example)\r\n                    if (el.is(_this.fillSegTag)) {\r\n                        seg.el = el;\r\n                        renderedSegs.push(seg);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return renderedSegs;\r\n    };\r\n    // Builds the HTML needed for one fill segment. Generic enough to work with different types.\r\n    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {\r\n        // custom hooks per-type\r\n        var classes = props.getClasses ? props.getClasses(seg) : [];\r\n        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});\r\n        return '<' + this.fillSegTag +\r\n            (classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\r\n            (css ? ' style=\"' + css + '\"' : '') +\r\n            ' />';\r\n    };\r\n    // Should return wrapping DOM structure\r\n    FillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        // subclasses must implement\r\n    };\r\n    FillRenderer.prototype.reportEls = function (type, nodes) {\r\n        if (this.elsByFill[type]) {\r\n            this.elsByFill[type] = this.elsByFill[type].add(nodes);\r\n        }\r\n        else {\r\n            this.elsByFill[type] = $(nodes);\r\n        }\r\n    };\r\n    return FillRenderer;\r\n}());\r\nexports.default = FillRenderer;\r\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar HelperRenderer = /** @class */ (function () {\r\n    function HelperRenderer(component, eventRenderer) {\r\n        this.view = component._getView();\r\n        this.component = component;\r\n        this.eventRenderer = eventRenderer;\r\n    }\r\n    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {\r\n        this.renderEventFootprints([\r\n            this.fabricateEventFootprint(componentFootprint)\r\n        ]);\r\n    };\r\n    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {\r\n        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));\r\n    };\r\n    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {\r\n        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');\r\n    };\r\n    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {\r\n        var segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n        var classNames = 'fc-helper ' + (extraClassNames || '');\r\n        var i;\r\n        // assigns each seg's el and returns a subset of segs that were rendered\r\n        segs = this.eventRenderer.renderFgSegEls(segs);\r\n        for (i = 0; i < segs.length; i++) {\r\n            segs[i].el.addClass(classNames);\r\n        }\r\n        if (opacity != null) {\r\n            for (i = 0; i < segs.length; i++) {\r\n                segs[i].el.css('opacity', opacity);\r\n            }\r\n        }\r\n        this.helperEls = this.renderSegs(segs, sourceSeg);\r\n    };\r\n    /*\r\n    Must return all mock event elements\r\n    */\r\n    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        // Subclasses must implement\r\n    };\r\n    HelperRenderer.prototype.unrender = function () {\r\n        if (this.helperEls) {\r\n            this.helperEls.remove();\r\n            this.helperEls = null;\r\n        }\r\n    };\r\n    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {\r\n        var calendar = this.view.calendar;\r\n        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);\r\n        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));\r\n        var dummyInstance;\r\n        dummyEvent.dateProfile = eventDateProfile;\r\n        dummyInstance = dummyEvent.buildInstance();\r\n        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);\r\n    };\r\n    return HelperRenderer;\r\n}());\r\nexports.default = HelperRenderer;\r\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventPointing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventPointing, _super);\r\n    function EventPointing() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /*\r\n    component must implement:\r\n      - publiclyTrigger\r\n    */\r\n    EventPointing.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));\r\n        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));\r\n        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));\r\n    };\r\n    EventPointing.prototype.handleClick = function (seg, ev) {\r\n        var res = this.component.publiclyTrigger('eventClick', {\r\n            context: seg.el[0],\r\n            args: [seg.footprint.getEventLegacy(), ev, this.view]\r\n        });\r\n        if (res === false) {\r\n            ev.preventDefault();\r\n        }\r\n    };\r\n    // Updates internal state and triggers handlers for when an event element is moused over\r\n    EventPointing.prototype.handleMouseover = function (seg, ev) {\r\n        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&\r\n            !this.mousedOverSeg) {\r\n            this.mousedOverSeg = seg;\r\n            // TODO: move to EventSelecting's responsibility\r\n            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n                seg.el.addClass('fc-allow-mouse-resize');\r\n            }\r\n            this.component.publiclyTrigger('eventMouseover', {\r\n                context: seg.el[0],\r\n                args: [seg.footprint.getEventLegacy(), ev, this.view]\r\n            });\r\n        }\r\n    };\r\n    // Updates internal state and triggers handlers for when an event element is moused out.\r\n    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\r\n    EventPointing.prototype.handleMouseout = function (seg, ev) {\r\n        if (this.mousedOverSeg) {\r\n            this.mousedOverSeg = null;\r\n            // TODO: move to EventSelecting's responsibility\r\n            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n                seg.el.removeClass('fc-allow-mouse-resize');\r\n            }\r\n            this.component.publiclyTrigger('eventMouseout', {\r\n                context: seg.el[0],\r\n                args: [\r\n                    seg.footprint.getEventLegacy(),\r\n                    ev || {},\r\n                    this.view\r\n                ]\r\n            });\r\n        }\r\n    };\r\n    EventPointing.prototype.end = function () {\r\n        if (this.mousedOverSeg) {\r\n            this.handleMouseout(this.mousedOverSeg);\r\n        }\r\n    };\r\n    return EventPointing;\r\n}(Interaction_1.default));\r\nexports.default = EventPointing;\r\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar DateClicking_1 = __webpack_require__(245);\r\nvar DateSelecting_1 = __webpack_require__(225);\r\nvar EventPointing_1 = __webpack_require__(59);\r\nvar EventDragging_1 = __webpack_require__(224);\r\nvar EventResizing_1 = __webpack_require__(223);\r\nvar ExternalDropping_1 = __webpack_require__(222);\r\nvar StandardInteractionsMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StandardInteractionsMixin, _super);\r\n    function StandardInteractionsMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return StandardInteractionsMixin;\r\n}(Mixin_1.default));\r\nexports.default = StandardInteractionsMixin;\r\nStandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;\r\nStandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;\r\nStandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;\r\nStandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;\r\nStandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;\r\nStandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;\r\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar CoordCache_1 = __webpack_require__(53);\r\nvar Popover_1 = __webpack_require__(249);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventFootprint_1 = __webpack_require__(36);\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nvar DayGridEventRenderer_1 = __webpack_require__(250);\r\nvar DayGridHelperRenderer_1 = __webpack_require__(251);\r\nvar DayGridFillRenderer_1 = __webpack_require__(252);\r\n/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar DayGrid = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGrid, _super);\r\n    function DayGrid(view) {\r\n        var _this = _super.call(this, view) || this;\r\n        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?\r\n        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\r\n        // isRigid determines whether the individual rows should ignore the contents and be a constant height.\r\n        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\r\n        _this.isRigid = false;\r\n        _this.hasAllDayBusinessHours = true;\r\n        return _this;\r\n    }\r\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (this.isRTL) {\r\n                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\r\n                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\r\n            }\r\n            else {\r\n                seg.leftCol = seg.firstRowDayIndex;\r\n                seg.rightCol = seg.lastRowDayIndex;\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Date Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.renderDates = function (dateProfile) {\r\n        this.dateProfile = dateProfile;\r\n        this.updateDayTable();\r\n        this.renderGrid();\r\n    };\r\n    DayGrid.prototype.unrenderDates = function () {\r\n        this.removeSegPopover();\r\n    };\r\n    // Renders the rows and columns into the component's `this.el`, which should already be assigned.\r\n    DayGrid.prototype.renderGrid = function () {\r\n        var view = this.view;\r\n        var rowCnt = this.rowCnt;\r\n        var colCnt = this.colCnt;\r\n        var html = '';\r\n        var row;\r\n        var col;\r\n        if (this.headContainerEl) {\r\n            this.headContainerEl.html(this.renderHeadHtml());\r\n        }\r\n        for (row = 0; row < rowCnt; row++) {\r\n            html += this.renderDayRowHtml(row, this.isRigid);\r\n        }\r\n        this.el.html(html);\r\n        this.rowEls = this.el.find('.fc-row');\r\n        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');\r\n        this.rowCoordCache = new CoordCache_1.default({\r\n            els: this.rowEls,\r\n            isVertical: true\r\n        });\r\n        this.colCoordCache = new CoordCache_1.default({\r\n            els: this.cellEls.slice(0, this.colCnt),\r\n            isHorizontal: true\r\n        });\r\n        // trigger dayRender with each cell's element\r\n        for (row = 0; row < rowCnt; row++) {\r\n            for (col = 0; col < colCnt; col++) {\r\n                this.publiclyTrigger('dayRender', {\r\n                    context: view,\r\n                    args: [\r\n                        this.getCellDate(row, col),\r\n                        this.getCellEl(row, col),\r\n                        view\r\n                    ]\r\n                });\r\n            }\r\n        }\r\n    };\r\n    // Generates the HTML for a single row, which is a div that wraps a table.\r\n    // `row` is the row number.\r\n    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\r\n        var theme = this.view.calendar.theme;\r\n        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\r\n        if (isRigid) {\r\n            classes.push('fc-rigid');\r\n        }\r\n        return '' +\r\n            '<div class=\"' + classes.join(' ') + '\">' +\r\n            '<div class=\"fc-bg\">' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderBgTrHtml(row) +\r\n            '</table>' +\r\n            '</div>' +\r\n            '<div class=\"fc-content-skeleton\">' +\r\n            '<table>' +\r\n            (this.getIsNumbersVisible() ?\r\n                '<thead>' +\r\n                    this.renderNumberTrHtml(row) +\r\n                    '</thead>' :\r\n                '') +\r\n            '</table>' +\r\n            '</div>' +\r\n            '</div>';\r\n    };\r\n    DayGrid.prototype.getIsNumbersVisible = function () {\r\n        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;\r\n    };\r\n    DayGrid.prototype.getIsDayNumbersVisible = function () {\r\n        return this.rowCnt > 1;\r\n    };\r\n    /* Grid Number Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.renderNumberTrHtml = function (row) {\r\n        return '' +\r\n            '<tr>' +\r\n            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\r\n            this.renderNumberCellsHtml(row) +\r\n            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +\r\n            '</tr>';\r\n    };\r\n    DayGrid.prototype.renderNumberIntroHtml = function (row) {\r\n        return this.renderIntroHtml();\r\n    };\r\n    DayGrid.prototype.renderNumberCellsHtml = function (row) {\r\n        var htmls = [];\r\n        var col;\r\n        var date;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            date = this.getCellDate(row, col);\r\n            htmls.push(this.renderNumberCellHtml(date));\r\n        }\r\n        return htmls.join('');\r\n    };\r\n    // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\r\n    // The number row will only exist if either day numbers or week numbers are turned on.\r\n    DayGrid.prototype.renderNumberCellHtml = function (date) {\r\n        var view = this.view;\r\n        var html = '';\r\n        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\r\n        var classes;\r\n        var weekCalcFirstDoW;\r\n        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {\r\n            // no numbers in day cell (week number must be along the side)\r\n            return '<td/>'; //  will create an empty space above events :(\r\n        }\r\n        classes = this.getDayClasses(date);\r\n        classes.unshift('fc-day-top');\r\n        if (this.cellWeekNumbersVisible) {\r\n            // To determine the day of week number change under ISO, we cannot\r\n            // rely on moment.js methods such as firstDayOfWeek() or weekday(),\r\n            // because they rely on the locale's dow (possibly overridden by\r\n            // our firstDay option), which may not be Monday. We cannot change\r\n            // dow, because that would affect the calendar start day as well.\r\n            if (date._locale._fullCalendar_weekCalc === 'ISO') {\r\n                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition\r\n            }\r\n            else {\r\n                weekCalcFirstDoW = date._locale.firstDayOfWeek();\r\n            }\r\n        }\r\n        html += '<td class=\"' + classes.join(' ') + '\"' +\r\n            (isDateValid ?\r\n                ' data-date=\"' + date.format() + '\"' :\r\n                '') +\r\n            '>';\r\n        if (this.cellWeekNumbersVisible && (date.day() === weekCalcFirstDoW)) {\r\n            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML\r\n            );\r\n        }\r\n        if (isDayNumberVisible) {\r\n            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.format('D') // inner HTML\r\n            );\r\n        }\r\n        html += '</td>';\r\n        return html;\r\n    };\r\n    /* Hit System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.prepareHits = function () {\r\n        this.colCoordCache.build();\r\n        this.rowCoordCache.build();\r\n        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\r\n    };\r\n    DayGrid.prototype.releaseHits = function () {\r\n        this.colCoordCache.clear();\r\n        this.rowCoordCache.clear();\r\n    };\r\n    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {\r\n        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\r\n            var col = this.colCoordCache.getHorizontalIndex(leftOffset);\r\n            var row = this.rowCoordCache.getVerticalIndex(topOffset);\r\n            if (row != null && col != null) {\r\n                return this.getCellHit(row, col);\r\n            }\r\n        }\r\n    };\r\n    DayGrid.prototype.getHitFootprint = function (hit) {\r\n        var range = this.getCellRange(hit.row, hit.col);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?\r\n        );\r\n    };\r\n    DayGrid.prototype.getHitEl = function (hit) {\r\n        return this.getCellEl(hit.row, hit.col);\r\n    };\r\n    /* Cell System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // FYI: the first column is the leftmost column, regardless of date\r\n    DayGrid.prototype.getCellHit = function (row, col) {\r\n        return {\r\n            row: row,\r\n            col: col,\r\n            component: this,\r\n            left: this.colCoordCache.getLeftOffset(col),\r\n            right: this.colCoordCache.getRightOffset(col),\r\n            top: this.rowCoordCache.getTopOffset(row),\r\n            bottom: this.rowCoordCache.getBottomOffset(row)\r\n        };\r\n    };\r\n    DayGrid.prototype.getCellEl = function (row, col) {\r\n        return this.cellEls.eq(row * this.colCnt + col);\r\n    };\r\n    /* Event Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Unrenders all events currently rendered on the grid\r\n    DayGrid.prototype.executeEventUnrender = function () {\r\n        this.removeSegPopover(); // removes the \"more..\" events popover\r\n        _super.prototype.executeEventUnrender.call(this);\r\n    };\r\n    // Retrieves all rendered segment objects currently rendered on the grid\r\n    DayGrid.prototype.getOwnEventSegs = function () {\r\n        // append the segments from the \"more...\" popover\r\n        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);\r\n    };\r\n    /* Event Drag Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event or external element being dragged.\r\n    // `eventLocation` has zoned start and end (optional)\r\n    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            this.renderHighlight(eventFootprints[i].componentFootprint);\r\n        }\r\n        // render drags from OTHER components as helpers\r\n        if (eventFootprints.length && seg && seg.component !== this) {\r\n            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n            return true; // signal helpers rendered\r\n        }\r\n    };\r\n    // Unrenders any visual indication of a hovering event\r\n    DayGrid.prototype.unrenderDrag = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Event Resize Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being resized\r\n    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            this.renderHighlight(eventFootprints[i].componentFootprint);\r\n        }\r\n        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n    };\r\n    // Unrenders a visual indication of an event being resized\r\n    DayGrid.prototype.unrenderEventResize = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* More+ Link Popover\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DayGrid.prototype.removeSegPopover = function () {\r\n        if (this.segPopover) {\r\n            this.segPopover.hide(); // in handler, will call segPopover's removeElement\r\n        }\r\n    };\r\n    // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\r\n    // `levelLimit` can be false (don't limit), a number, or true (should be computed).\r\n    DayGrid.prototype.limitRows = function (levelLimit) {\r\n        var rowStructs = this.eventRenderer.rowStructs || [];\r\n        var row; // row #\r\n        var rowLevelLimit;\r\n        for (row = 0; row < rowStructs.length; row++) {\r\n            this.unlimitRow(row);\r\n            if (!levelLimit) {\r\n                rowLevelLimit = false;\r\n            }\r\n            else if (typeof levelLimit === 'number') {\r\n                rowLevelLimit = levelLimit;\r\n            }\r\n            else {\r\n                rowLevelLimit = this.computeRowLevelLimit(row);\r\n            }\r\n            if (rowLevelLimit !== false) {\r\n                this.limitRow(row, rowLevelLimit);\r\n            }\r\n        }\r\n    };\r\n    // Computes the number of levels a row will accomodate without going outside its bounds.\r\n    // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\r\n    // `row` is the row number.\r\n    DayGrid.prototype.computeRowLevelLimit = function (row) {\r\n        var rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\r\n        var rowHeight = rowEl.height(); // TODO: cache somehow?\r\n        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();\r\n        var i;\r\n        var trEl;\r\n        var trHeight;\r\n        function iterInnerHeights(i, childNode) {\r\n            trHeight = Math.max(trHeight, $(childNode).outerHeight());\r\n        }\r\n        // Reveal one level <tr> at a time and stop when we find one out of bounds\r\n        for (i = 0; i < trEls.length; i++) {\r\n            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\r\n            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\r\n            // so instead, find the tallest inner content element.\r\n            trHeight = 0;\r\n            trEl.find('> td > :first-child').each(iterInnerHeights);\r\n            if (trEl.position().top + trHeight > rowHeight) {\r\n                return i;\r\n            }\r\n        }\r\n        return false; // should not limit at all\r\n    };\r\n    // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\r\n    // `row` is the row number.\r\n    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\r\n    DayGrid.prototype.limitRow = function (row, levelLimit) {\r\n        var _this = this;\r\n        var rowStruct = this.eventRenderer.rowStructs[row];\r\n        var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\r\n        var col = 0; // col #, left-to-right (not chronologically)\r\n        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\r\n        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\r\n        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\r\n        var i;\r\n        var seg;\r\n        var segsBelow; // array of segment objects below `seg` in the current `col`\r\n        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\r\n        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\r\n        var td;\r\n        var rowspan;\r\n        var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\r\n        var j;\r\n        var moreTd;\r\n        var moreWrap;\r\n        var moreLink;\r\n        // Iterates through empty level cells and places \"more\" links inside if need be\r\n        var emptyCellsUntil = function (endCol) {\r\n            while (col < endCol) {\r\n                segsBelow = _this.getCellSegs(row, col, levelLimit);\r\n                if (segsBelow.length) {\r\n                    td = cellMatrix[levelLimit - 1][col];\r\n                    moreLink = _this.renderMoreLink(row, col, segsBelow);\r\n                    moreWrap = $('<div/>').append(moreLink);\r\n                    td.append(moreWrap);\r\n                    moreNodes.push(moreWrap[0]);\r\n                }\r\n                col++;\r\n            }\r\n        };\r\n        if (levelLimit && levelLimit < rowStruct.segLevels.length) {\r\n            levelSegs = rowStruct.segLevels[levelLimit - 1];\r\n            cellMatrix = rowStruct.cellMatrix;\r\n            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\r\n                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\r\n            // iterate though segments in the last allowable level\r\n            for (i = 0; i < levelSegs.length; i++) {\r\n                seg = levelSegs[i];\r\n                emptyCellsUntil(seg.leftCol); // process empty cells before the segment\r\n                // determine *all* segments below `seg` that occupy the same columns\r\n                colSegsBelow = [];\r\n                totalSegsBelow = 0;\r\n                while (col <= seg.rightCol) {\r\n                    segsBelow = this.getCellSegs(row, col, levelLimit);\r\n                    colSegsBelow.push(segsBelow);\r\n                    totalSegsBelow += segsBelow.length;\r\n                    col++;\r\n                }\r\n                if (totalSegsBelow) {\r\n                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\r\n                    rowspan = td.attr('rowspan') || 1;\r\n                    segMoreNodes = [];\r\n                    // make a replacement <td> for each column the segment occupies. will be one for each colspan\r\n                    for (j = 0; j < colSegsBelow.length; j++) {\r\n                        moreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\r\n                        segsBelow = colSegsBelow[j];\r\n                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\r\n                        );\r\n                        moreWrap = $('<div/>').append(moreLink);\r\n                        moreTd.append(moreWrap);\r\n                        segMoreNodes.push(moreTd[0]);\r\n                        moreNodes.push(moreTd[0]);\r\n                    }\r\n                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\r\n                    limitedNodes.push(td[0]);\r\n                }\r\n            }\r\n            emptyCellsUntil(this.colCnt); // finish off the level\r\n            rowStruct.moreEls = $(moreNodes); // for easy undoing later\r\n            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later\r\n        }\r\n    };\r\n    // Reveals all levels and removes all \"more\"-related elements for a grid's row.\r\n    // `row` is a row number.\r\n    DayGrid.prototype.unlimitRow = function (row) {\r\n        var rowStruct = this.eventRenderer.rowStructs[row];\r\n        if (rowStruct.moreEls) {\r\n            rowStruct.moreEls.remove();\r\n            rowStruct.moreEls = null;\r\n        }\r\n        if (rowStruct.limitedEls) {\r\n            rowStruct.limitedEls.removeClass('fc-limited');\r\n            rowStruct.limitedEls = null;\r\n        }\r\n    };\r\n    // Renders an <a> element that represents hidden event element for a cell.\r\n    // Responsible for attaching click handler as well.\r\n    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        return $('<a class=\"fc-more\"/>')\r\n            .text(this.getMoreLinkText(hiddenSegs.length))\r\n            .on('click', function (ev) {\r\n            var clickOption = _this.opt('eventLimitClick');\r\n            var date = _this.getCellDate(row, col);\r\n            var moreEl = $(ev.currentTarget);\r\n            var dayEl = _this.getCellEl(row, col);\r\n            var allSegs = _this.getCellSegs(row, col);\r\n            // rescope the segments to be within the cell's date\r\n            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\r\n            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\r\n            if (typeof clickOption === 'function') {\r\n                // the returned value can be an atomic option\r\n                clickOption = _this.publiclyTrigger('eventLimitClick', {\r\n                    context: view,\r\n                    args: [\r\n                        {\r\n                            date: date.clone(),\r\n                            dayEl: dayEl,\r\n                            moreEl: moreEl,\r\n                            segs: reslicedAllSegs,\r\n                            hiddenSegs: reslicedHiddenSegs\r\n                        },\r\n                        ev,\r\n                        view\r\n                    ]\r\n                });\r\n            }\r\n            if (clickOption === 'popover') {\r\n                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\r\n            }\r\n            else if (typeof clickOption === 'string') {\r\n                view.calendar.zoomTo(date, clickOption);\r\n            }\r\n        });\r\n    };\r\n    // Reveals the popover that displays all events within a cell\r\n    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\r\n        var topEl; // the element we want to match the top coordinate of\r\n        var options;\r\n        if (this.rowCnt === 1) {\r\n            topEl = view.el; // will cause the popover to cover any sort of header\r\n        }\r\n        else {\r\n            topEl = this.rowEls.eq(row); // will align with top of row\r\n        }\r\n        options = {\r\n            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),\r\n            content: this.renderSegPopoverContent(row, col, segs),\r\n            parentEl: view.el,\r\n            top: topEl.offset().top,\r\n            autoHide: true,\r\n            viewportConstrain: this.opt('popoverViewportConstrain'),\r\n            hide: function () {\r\n                // kill everything when the popover is hidden\r\n                // notify events to be removed\r\n                if (_this.popoverSegs) {\r\n                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);\r\n                }\r\n                _this.segPopover.removeElement();\r\n                _this.segPopover = null;\r\n                _this.popoverSegs = null;\r\n            }\r\n        };\r\n        // Determine horizontal coordinate.\r\n        // We use the moreWrap instead of the <td> to avoid border confusion.\r\n        if (this.isRTL) {\r\n            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\r\n        }\r\n        else {\r\n            options.left = moreWrap.offset().left - 1; // -1 to be over cell border\r\n        }\r\n        this.segPopover = new Popover_1.default(options);\r\n        this.segPopover.show();\r\n        // the popover doesn't live within the grid's container element, and thus won't get the event\r\n        // delegated-handlers for free. attach event-related handlers to the popover.\r\n        this.bindAllSegHandlersToEl(this.segPopover.el);\r\n        this.triggerAfterEventSegsRendered(segs);\r\n    };\r\n    // Builds the inner DOM contents of the segment popover\r\n    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {\r\n        var view = this.view;\r\n        var theme = view.calendar.theme;\r\n        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));\r\n        var content = $('<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' +\r\n            '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' +\r\n            '<span class=\"fc-title\">' +\r\n            util_1.htmlEscape(title) +\r\n            '</span>' +\r\n            '<div class=\"fc-clear\"/>' +\r\n            '</div>' +\r\n            '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' +\r\n            '<div class=\"fc-event-container\"></div>' +\r\n            '</div>');\r\n        var segContainer = content.find('.fc-event-container');\r\n        var i;\r\n        // render each seg's `el` and only return the visible segs\r\n        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true\r\n        this.popoverSegs = segs;\r\n        for (i = 0; i < segs.length; i++) {\r\n            // because segments in the popover are not part of a grid coordinate system, provide a hint to any\r\n            // grids that want to do drag-n-drop about which cell it came from\r\n            this.hitsNeeded();\r\n            segs[i].hit = this.getCellHit(row, col);\r\n            this.hitsNotNeeded();\r\n            segContainer.append(segs[i].el);\r\n        }\r\n        return content;\r\n    };\r\n    // Given the events within an array of segment objects, reslice them to be in a single day\r\n    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\r\n        var dayStart = dayDate.clone();\r\n        var dayEnd = dayStart.clone().add(1, 'days');\r\n        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);\r\n        var newSegs = [];\r\n        var i;\r\n        var seg;\r\n        var slicedRange;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);\r\n            if (slicedRange) {\r\n                newSegs.push($.extend({}, seg, {\r\n                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),\r\n                    isStart: seg.isStart && slicedRange.isStart,\r\n                    isEnd: seg.isEnd && slicedRange.isEnd\r\n                }));\r\n            }\r\n        }\r\n        // force an order because eventsToSegs doesn't guarantee one\r\n        // TODO: research if still needed\r\n        this.eventRenderer.sortEventSegs(newSegs);\r\n        return newSegs;\r\n    };\r\n    // Generates the text that should be inside a \"more\" link, given the number of events it represents\r\n    DayGrid.prototype.getMoreLinkText = function (num) {\r\n        var opt = this.opt('eventLimitText');\r\n        if (typeof opt === 'function') {\r\n            return opt(num);\r\n        }\r\n        else {\r\n            return '+' + num + ' ' + opt;\r\n        }\r\n    };\r\n    // Returns segments within a given cell.\r\n    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\r\n    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\r\n        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\r\n        var level = startLevel || 0;\r\n        var segs = [];\r\n        var seg;\r\n        while (level < segMatrix.length) {\r\n            seg = segMatrix[level][col];\r\n            if (seg) {\r\n                segs.push(seg);\r\n            }\r\n            level++;\r\n        }\r\n        return segs;\r\n    };\r\n    return DayGrid;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = DayGrid;\r\nDayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;\r\nDayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\r\nDayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;\r\nDayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;\r\nStandardInteractionsMixin_1.default.mixInto(DayGrid);\r\nDayTableMixin_1.default.mixInto(DayGrid);\r\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar View_1 = __webpack_require__(41);\r\nvar BasicViewDateProfileGenerator_1 = __webpack_require__(228);\r\nvar DayGrid_1 = __webpack_require__(61);\r\n/* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\r\n// It is responsible for managing width/height.\r\nvar BasicView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BasicView, _super);\r\n    function BasicView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.dayGrid = _this.instantiateDayGrid();\r\n        _this.dayGrid.isRigid = _this.hasRigidRows();\r\n        if (_this.opt('weekNumbers')) {\r\n            if (_this.opt('weekNumbersWithinDays')) {\r\n                _this.dayGrid.cellWeekNumbersVisible = true;\r\n                _this.dayGrid.colWeekNumbersVisible = false;\r\n            }\r\n            else {\r\n                _this.dayGrid.cellWeekNumbersVisible = false;\r\n                _this.dayGrid.colWeekNumbersVisible = true;\r\n            }\r\n        }\r\n        _this.addChild(_this.dayGrid);\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    // Generates the DayGrid object this view needs. Draws from this.dayGridClass\r\n    BasicView.prototype.instantiateDayGrid = function () {\r\n        // generate a subclass on the fly with BasicView-specific behavior\r\n        // TODO: cache this subclass\r\n        var subclass = makeDayGridSubclass(this.dayGridClass);\r\n        return new subclass(this);\r\n    };\r\n    BasicView.prototype.executeDateRender = function (dateProfile) {\r\n        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);\r\n        _super.prototype.executeDateRender.call(this, dateProfile);\r\n    };\r\n    BasicView.prototype.renderSkeleton = function () {\r\n        var dayGridContainerEl;\r\n        var dayGridEl;\r\n        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\r\n        this.scroller.render();\r\n        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\r\n        dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\r\n        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);\r\n        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');\r\n        this.dayGrid.setElement(dayGridEl);\r\n    };\r\n    BasicView.prototype.unrenderSkeleton = function () {\r\n        this.dayGrid.removeElement();\r\n        this.scroller.destroy();\r\n    };\r\n    // Builds the HTML skeleton for the view.\r\n    // The day-grid component will render inside of a container defined by this HTML.\r\n    BasicView.prototype.renderSkeletonHtml = function () {\r\n        var theme = this.calendar.theme;\r\n        return '' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            (this.opt('columnHeader') ?\r\n                '<thead class=\"fc-head\">' +\r\n                    '<tr>' +\r\n                    '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n                    '</tr>' +\r\n                    '</thead>' :\r\n                '') +\r\n            '<tbody class=\"fc-body\">' +\r\n            '<tr>' +\r\n            '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' +\r\n            '</tr>' +\r\n            '</tbody>' +\r\n            '</table>';\r\n    };\r\n    // Generates an HTML attribute string for setting the width of the week number column, if it is known\r\n    BasicView.prototype.weekNumberStyleAttr = function () {\r\n        if (this.weekNumberWidth != null) {\r\n            return 'style=\"width:' + this.weekNumberWidth + 'px\"';\r\n        }\r\n        return '';\r\n    };\r\n    // Determines whether each row should have a constant height\r\n    BasicView.prototype.hasRigidRows = function () {\r\n        var eventLimit = this.opt('eventLimit');\r\n        return eventLimit && typeof eventLimit !== 'number';\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Refreshes the horizontal dimensions of the view\r\n    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        var eventLimit = this.opt('eventLimit');\r\n        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');\r\n        var scrollerHeight;\r\n        var scrollbarWidths;\r\n        // hack to give the view some height prior to dayGrid's columns being rendered\r\n        // TODO: separate setting height from scroller VS dayGrid.\r\n        if (!this.dayGrid.rowEls) {\r\n            if (!isAuto) {\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            return;\r\n        }\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        if (this.dayGrid.colWeekNumbersVisible) {\r\n            // Make sure all week number cells running down the side have the same width.\r\n            // Record the width for cells created later.\r\n            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));\r\n        }\r\n        // reset all heights to be natural\r\n        this.scroller.clear();\r\n        util_1.uncompensateScroll(headRowEl);\r\n        this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n        // is the event limit a constant level number?\r\n        if (eventLimit && typeof eventLimit === 'number') {\r\n            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\r\n        }\r\n        // distribute the height to the rows\r\n        // (totalHeight is a \"recommended\" value if isAuto)\r\n        scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n        this.setGridHeight(scrollerHeight, isAuto);\r\n        // is the event limit dynamically calculated?\r\n        if (eventLimit && typeof eventLimit !== 'number') {\r\n            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\r\n        }\r\n        if (!isAuto) {\r\n            this.scroller.setHeight(scrollerHeight);\r\n            scrollbarWidths = this.scroller.getScrollbarWidths();\r\n            if (scrollbarWidths.left || scrollbarWidths.right) {\r\n                util_1.compensateScroll(headRowEl, scrollbarWidths);\r\n                // doing the scrollbar compensation might have created text overflow which created more height. redo\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            // guarantees the same scrollbar widths\r\n            this.scroller.lockOverflow(scrollbarWidths);\r\n        }\r\n    };\r\n    // given a desired total height of the view, returns what the height of the scroller should be\r\n    BasicView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    // Sets the height of just the DayGrid component in this view\r\n    BasicView.prototype.setGridHeight = function (height, isAuto) {\r\n        if (isAuto) {\r\n            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\r\n        }\r\n        else {\r\n            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\r\n        }\r\n    };\r\n    /* Scroll\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    BasicView.prototype.computeInitialDateScroll = function () {\r\n        return { top: 0 };\r\n    };\r\n    BasicView.prototype.queryDateScroll = function () {\r\n        return { top: this.scroller.getScrollTop() };\r\n    };\r\n    BasicView.prototype.applyDateScroll = function (scroll) {\r\n        if (scroll.top !== undefined) {\r\n            this.scroller.setScrollTop(scroll.top);\r\n        }\r\n    };\r\n    return BasicView;\r\n}(View_1.default));\r\nexports.default = BasicView;\r\nBasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;\r\nBasicView.prototype.dayGridClass = DayGrid_1.default;\r\n// customize the rendering behavior of BasicView's dayGrid\r\nfunction makeDayGridSubclass(SuperClass) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(SubClass, _super);\r\n        function SubClass() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this.colWeekNumbersVisible = false; // display week numbers along the side?\r\n            return _this;\r\n        }\r\n        // Generates the HTML that will go before the day-of week header cells\r\n        SubClass.prototype.renderHeadIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '' +\r\n                    '<th class=\"fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '\" ' + view.weekNumberStyleAttr() + '>' +\r\n                    '<span>' + // needed for matchCellWidths\r\n                    util_1.htmlEscape(this.opt('weekNumberTitle')) +\r\n                    '</span>' +\r\n                    '</th>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\r\n        SubClass.prototype.renderNumberIntroHtml = function (row) {\r\n            var view = this.view;\r\n            var weekStart = this.getCellDate(row, 0);\r\n            if (this.colWeekNumbersVisible) {\r\n                return '' +\r\n                    '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\r\n                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\r\n                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML\r\n                    ) +\r\n                    '</td>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that goes before the day bg cells for each day-row\r\n        SubClass.prototype.renderBgIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '<td class=\"fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '\" ' +\r\n                    view.weekNumberStyleAttr() + '></td>';\r\n            }\r\n            return '';\r\n        };\r\n        // Generates the HTML that goes before every other type of row generated by DayGrid.\r\n        // Affects helper-skeleton and highlight-skeleton rows.\r\n        SubClass.prototype.renderIntroHtml = function () {\r\n            var view = this.view;\r\n            if (this.colWeekNumbersVisible) {\r\n                return '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\r\n            }\r\n            return '';\r\n        };\r\n        SubClass.prototype.getIsNumbersVisible = function () {\r\n            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;\r\n        };\r\n        return SubClass;\r\n    }(SuperClass));\r\n}\r\n\n\n/***/ }),\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */,\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */,\n/* 160 */,\n/* 161 */,\n/* 162 */,\n/* 163 */,\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */,\n/* 175 */,\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */,\n/* 182 */,\n/* 183 */,\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar util_1 = __webpack_require__(35);\r\nvar Constraints = /** @class */ (function () {\r\n    function Constraints(eventManager, _calendar) {\r\n        this.eventManager = eventManager;\r\n        this._calendar = _calendar;\r\n    }\r\n    Constraints.prototype.opt = function (name) {\r\n        return this._calendar.opt(name);\r\n    };\r\n    /*\r\n    determines if eventInstanceGroup is allowed,\r\n    in relation to other EVENTS and business hours.\r\n    */\r\n    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {\r\n        var eventDef = eventInstanceGroup.getEventDef();\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n        var i;\r\n        var peerEventInstances = this.getPeerEventInstances(eventDef);\r\n        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\r\n        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n        var constraintVal = eventDef.getConstraint();\r\n        var overlapVal = eventDef.getOverlap();\r\n        var eventAllowFunc = this.opt('eventAllow');\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (eventAllowFunc) {\r\n            for (i = 0; i < eventFootprints.length; i++) {\r\n                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Constraints.prototype.getPeerEventInstances = function (eventDef) {\r\n        return this.eventManager.getEventInstancesWithoutId(eventDef.id);\r\n    };\r\n    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\r\n        var peerEventInstances = this.eventManager.getEventInstances();\r\n        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);\r\n        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n        var selectAllowFunc;\r\n        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {\r\n            selectAllowFunc = this.opt('selectAllow');\r\n            if (selectAllowFunc) {\r\n                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional\r\n    ) {\r\n        var constraintFootprints; // ComponentFootprint[]\r\n        var overlapEventFootprints; // EventFootprint[]\r\n        if (constraintVal != null) {\r\n            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);\r\n            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {\r\n                return false;\r\n            }\r\n        }\r\n        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);\r\n        if (overlapVal === false) {\r\n            if (overlapEventFootprints.length) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (typeof overlapVal === 'function') {\r\n            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (subjectEventInstance) {\r\n            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    // Constraint\r\n    // ------------------------------------------------------------------------------------------------\r\n    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {\r\n        var i;\r\n        for (i = 0; i < constraintFootprints.length; i++) {\r\n            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {\r\n        var eventInstances;\r\n        if (constraintVal === 'businessHours') {\r\n            return this.buildCurrentBusinessFootprints(isAllDay);\r\n        }\r\n        else if (typeof constraintVal === 'object') {\r\n            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events\r\n            if (!eventInstances) {\r\n                return this.parseFootprints(constraintVal);\r\n            }\r\n            else {\r\n                return this.eventInstancesToFootprints(eventInstances);\r\n            }\r\n        }\r\n        else if (constraintVal != null) {\r\n            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);\r\n            return this.eventInstancesToFootprints(eventInstances);\r\n        }\r\n    };\r\n    // returns ComponentFootprint[]\r\n    // uses current view's range\r\n    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {\r\n        var view = this._calendar.view;\r\n        var businessHourGenerator = view.get('businessHourGenerator');\r\n        var unzonedRange = view.dateProfile.activeUnzonedRange;\r\n        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);\r\n        if (eventInstanceGroup) {\r\n            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n    // conversion util\r\n    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {\r\n        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);\r\n        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);\r\n        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);\r\n    };\r\n    // Overlap\r\n    // ------------------------------------------------------------------------------------------------\r\n    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {\r\n        var overlapEventFootprints = [];\r\n        var i;\r\n        for (i = 0; i < peerEventFootprints.length; i++) {\r\n            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {\r\n                overlapEventFootprints.push(peerEventFootprints[i]);\r\n            }\r\n        }\r\n        return overlapEventFootprints;\r\n    };\r\n    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints\r\n    // ------------------------------------------------------------------------------------------------\r\n    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to\r\n    // constraints whereas the Grid code is related to rendering. Each approach might want to convert\r\n    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make\r\n    // this more DRY.\r\n    /*\r\n    Returns false on invalid input.\r\n    */\r\n    Constraints.prototype.parseEventDefToInstances = function (eventInput) {\r\n        var eventManager = this.eventManager;\r\n        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));\r\n        if (!eventDef) {\r\n            return false;\r\n        }\r\n        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);\r\n    };\r\n    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {\r\n        var i;\r\n        var eventFootprints = [];\r\n        for (i = 0; i < eventRanges.length; i++) {\r\n            eventFootprints.push.apply(// footprints\r\n            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\r\n        }\r\n        return eventFootprints;\r\n    };\r\n    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {\r\n        return [util_1.eventRangeToEventFootprint(eventRange)];\r\n    };\r\n    /*\r\n    Parses footprints directly.\r\n    Very similar to EventDateProfile::parse :(\r\n    */\r\n    Constraints.prototype.parseFootprints = function (rawInput) {\r\n        var start;\r\n        var end;\r\n        if (rawInput.start) {\r\n            start = this._calendar.moment(rawInput.start);\r\n            if (!start.isValid()) {\r\n                start = null;\r\n            }\r\n        }\r\n        if (rawInput.end) {\r\n            end = this._calendar.moment(rawInput.end);\r\n            if (!end.isValid()) {\r\n                end = null;\r\n            }\r\n        }\r\n        return [\r\n            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay\r\n            )\r\n        ];\r\n    };\r\n    // Footprint Utils\r\n    // ----------------------------------------------------------------------------------------\r\n    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {\r\n        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);\r\n    };\r\n    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {\r\n        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);\r\n    };\r\n    return Constraints;\r\n}());\r\nexports.default = Constraints;\r\n// optional subjectEventInstance\r\nfunction isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {\r\n    var i;\r\n    for (i = 0; i < overlapEventFootprints.length; i++) {\r\n        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {\r\n    var subjectLegacyInstance = subjectEventInstance.toLegacy();\r\n    var i;\r\n    var overlapEventInstance;\r\n    var overlapEventDef;\r\n    var overlapVal;\r\n    for (i = 0; i < overlapEventFootprints.length; i++) {\r\n        overlapEventInstance = overlapEventFootprints[i].eventInstance;\r\n        overlapEventDef = overlapEventInstance.def;\r\n        // don't need to pass in calendar, because don't want to consider global eventOverlap property,\r\n        // because we already considered that earlier in the process.\r\n        overlapVal = overlapEventDef.getOverlap();\r\n        if (overlapVal === false) {\r\n            return false;\r\n        }\r\n        else if (typeof overlapVal === 'function') {\r\n            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\r\nUSAGE:\r\n  import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'\r\nin class:\r\n  applyProps: ParsableModelInterface['applyProps']\r\n  applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']\r\n  applyMiscProps: ParsableModelInterface['applyMiscProps']\r\n  isStandardProp: ParsableModelInterface['isStandardProp']\r\n  static defineStandardProps = ParsableModelMixin.defineStandardProps\r\n  static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps\r\nafter class:\r\n  ParsableModelMixin.mixInto(TheClass)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar Mixin_1 = __webpack_require__(14);\r\nvar ParsableModelMixin = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParsableModelMixin, _super);\r\n    function ParsableModelMixin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ParsableModelMixin.defineStandardProps = function (propDefs) {\r\n        var proto = this.prototype;\r\n        if (!proto.hasOwnProperty('standardPropMap')) {\r\n            proto.standardPropMap = Object.create(proto.standardPropMap);\r\n        }\r\n        util_1.copyOwnProps(propDefs, proto.standardPropMap);\r\n    };\r\n    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {\r\n        var map = this.prototype.standardPropMap;\r\n        var propName;\r\n        for (propName in map) {\r\n            if (src[propName] != null && // in the src object?\r\n                map[propName] === true // false means \"copy verbatim\"\r\n            ) {\r\n                dest[propName] = src[propName];\r\n            }\r\n        }\r\n    };\r\n    /*\r\n    Returns true/false for success.\r\n    Meant to be only called ONCE, at object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyProps = function (rawProps) {\r\n        var standardPropMap = this.standardPropMap;\r\n        var manualProps = {};\r\n        var miscProps = {};\r\n        var propName;\r\n        for (propName in rawProps) {\r\n            if (standardPropMap[propName] === true) {\r\n                this[propName] = rawProps[propName];\r\n            }\r\n            else if (standardPropMap[propName] === false) {\r\n                manualProps[propName] = rawProps[propName];\r\n            }\r\n            else {\r\n                miscProps[propName] = rawProps[propName];\r\n            }\r\n        }\r\n        this.applyMiscProps(miscProps);\r\n        return this.applyManualStandardProps(manualProps);\r\n    };\r\n    /*\r\n    If subclasses override, they must call this supermethod and return the boolean response.\r\n    Meant to be only called ONCE, at object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {\r\n        return true;\r\n    };\r\n    /*\r\n    Can be called even after initial object creation.\r\n    */\r\n    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {\r\n        // subclasses can implement\r\n    };\r\n    /*\r\n    TODO: why is this a method when defineStandardProps is static\r\n    */\r\n    ParsableModelMixin.prototype.isStandardProp = function (propName) {\r\n        return propName in this.standardPropMap;\r\n    };\r\n    return ParsableModelMixin;\r\n}(Mixin_1.default));\r\nexports.default = ParsableModelMixin;\r\nParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps\r\n\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventInstance = /** @class */ (function () {\r\n    function EventInstance(def, dateProfile) {\r\n        this.def = def;\r\n        this.dateProfile = dateProfile;\r\n    }\r\n    EventInstance.prototype.toLegacy = function () {\r\n        var dateProfile = this.dateProfile;\r\n        var obj = this.def.toLegacy();\r\n        obj.start = dateProfile.start.clone();\r\n        obj.end = dateProfile.end ? dateProfile.end.clone() : null;\r\n        return obj;\r\n    };\r\n    return EventInstance;\r\n}());\r\nexports.default = EventInstance;\r\n\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar EventDef_1 = __webpack_require__(34);\r\nvar EventInstance_1 = __webpack_require__(209);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar RecurringEventDef = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RecurringEventDef, _super);\r\n    function RecurringEventDef() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RecurringEventDef.prototype.isAllDay = function () {\r\n        return !this.startTime && !this.endTime;\r\n    };\r\n    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {\r\n        var calendar = this.source.calendar;\r\n        var unzonedDate = unzonedRange.getStart();\r\n        var unzonedEnd = unzonedRange.getEnd();\r\n        var zonedDayStart;\r\n        var instanceStart;\r\n        var instanceEnd;\r\n        var instances = [];\r\n        while (unzonedDate.isBefore(unzonedEnd)) {\r\n            // if everyday, or this particular day-of-week\r\n            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {\r\n                zonedDayStart = calendar.applyTimezone(unzonedDate);\r\n                instanceStart = zonedDayStart.clone();\r\n                instanceEnd = null;\r\n                if (this.startTime) {\r\n                    instanceStart.time(this.startTime);\r\n                }\r\n                else {\r\n                    instanceStart.stripTime();\r\n                }\r\n                if (this.endTime) {\r\n                    instanceEnd = zonedDayStart.clone().time(this.endTime);\r\n                }\r\n                instances.push(new EventInstance_1.default(this, // definition\r\n                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));\r\n            }\r\n            unzonedDate.add(1, 'days');\r\n        }\r\n        return instances;\r\n    };\r\n    RecurringEventDef.prototype.setDow = function (dowNumbers) {\r\n        if (!this.dowHash) {\r\n            this.dowHash = {};\r\n        }\r\n        for (var i = 0; i < dowNumbers.length; i++) {\r\n            this.dowHash[dowNumbers[i]] = true;\r\n        }\r\n    };\r\n    RecurringEventDef.prototype.clone = function () {\r\n        var def = _super.prototype.clone.call(this);\r\n        if (def.startTime) {\r\n            def.startTime = moment.duration(this.startTime);\r\n        }\r\n        if (def.endTime) {\r\n            def.endTime = moment.duration(this.endTime);\r\n        }\r\n        if (this.dowHash) {\r\n            def.dowHash = $.extend({}, this.dowHash);\r\n        }\r\n        return def;\r\n    };\r\n    return RecurringEventDef;\r\n}(EventDef_1.default));\r\nexports.default = RecurringEventDef;\r\n/*\r\nHACK to work with TypeScript mixins\r\nNOTE: if super-method fails, should still attempt to apply\r\n*/\r\nRecurringEventDef.prototype.applyProps = function (rawProps) {\r\n    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);\r\n    if (rawProps.start) {\r\n        this.startTime = moment.duration(rawProps.start);\r\n    }\r\n    if (rawProps.end) {\r\n        this.endTime = moment.duration(rawProps.end);\r\n    }\r\n    if (rawProps.dow) {\r\n        this.setDow(rawProps.dow);\r\n    }\r\n    return superSuccess;\r\n};\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\nRecurringEventDef.defineStandardProps({\r\n    start: false,\r\n    end: false,\r\n    dow: false\r\n});\r\n\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventRange = /** @class */ (function () {\r\n    function EventRange(unzonedRange, eventDef, eventInstance) {\r\n        this.unzonedRange = unzonedRange;\r\n        this.eventDef = eventDef;\r\n        if (eventInstance) {\r\n            this.eventInstance = eventInstance;\r\n        }\r\n    }\r\n    return EventRange;\r\n}());\r\nexports.default = EventRange;\r\n\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(35);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar RecurringEventDef_1 = __webpack_require__(210);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar BUSINESS_HOUR_EVENT_DEFAULTS = {\r\n    start: '09:00',\r\n    end: '17:00',\r\n    dow: [1, 2, 3, 4, 5],\r\n    rendering: 'inverse-background'\r\n    // classNames are defined in businessHoursSegClasses\r\n};\r\nvar BusinessHourGenerator = /** @class */ (function () {\r\n    function BusinessHourGenerator(rawComplexDef, calendar) {\r\n        this.rawComplexDef = rawComplexDef;\r\n        this.calendar = calendar;\r\n    }\r\n    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {\r\n        var eventDefs = this.buildEventDefs(isAllDay);\r\n        var eventInstanceGroup;\r\n        if (eventDefs.length) {\r\n            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));\r\n            // so that inverse-background rendering can happen even when no eventRanges in view\r\n            eventInstanceGroup.explicitEventDef = eventDefs[0];\r\n            return eventInstanceGroup;\r\n        }\r\n    };\r\n    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {\r\n        var rawComplexDef = this.rawComplexDef;\r\n        var rawDefs = [];\r\n        var requireDow = false;\r\n        var i;\r\n        var defs = [];\r\n        if (rawComplexDef === true) {\r\n            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim\r\n        }\r\n        else if ($.isPlainObject(rawComplexDef)) {\r\n            rawDefs = [rawComplexDef];\r\n        }\r\n        else if ($.isArray(rawComplexDef)) {\r\n            rawDefs = rawComplexDef;\r\n            requireDow = true; // every sub-definition NEEDS a day-of-week\r\n        }\r\n        for (i = 0; i < rawDefs.length; i++) {\r\n            if (!requireDow || rawDefs[i].dow) {\r\n                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));\r\n            }\r\n        }\r\n        return defs;\r\n    };\r\n    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {\r\n        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);\r\n        if (isAllDay) {\r\n            fullRawDef.start = null;\r\n            fullRawDef.end = null;\r\n        }\r\n        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source\r\n        );\r\n    };\r\n    return BusinessHourGenerator;\r\n}());\r\nexports.default = BusinessHourGenerator;\r\n\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar StandardTheme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StandardTheme, _super);\r\n    function StandardTheme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return StandardTheme;\r\n}(Theme_1.default));\r\nexports.default = StandardTheme;\r\nStandardTheme.prototype.classes = {\r\n    widget: 'fc-unthemed',\r\n    widgetHeader: 'fc-widget-header',\r\n    widgetContent: 'fc-widget-content',\r\n    buttonGroup: 'fc-button-group',\r\n    button: 'fc-button',\r\n    cornerLeft: 'fc-corner-left',\r\n    cornerRight: 'fc-corner-right',\r\n    stateDefault: 'fc-state-default',\r\n    stateActive: 'fc-state-active',\r\n    stateDisabled: 'fc-state-disabled',\r\n    stateHover: 'fc-state-hover',\r\n    stateDown: 'fc-state-down',\r\n    popoverHeader: 'fc-widget-header',\r\n    popoverContent: 'fc-widget-content',\r\n    // day grid\r\n    headerRow: 'fc-widget-header',\r\n    dayRow: 'fc-widget-content',\r\n    // list view\r\n    listView: 'fc-widget-content'\r\n};\r\nStandardTheme.prototype.baseIconClass = 'fc-icon';\r\nStandardTheme.prototype.iconClasses = {\r\n    close: 'fc-icon-x',\r\n    prev: 'fc-icon-left-single-arrow',\r\n    next: 'fc-icon-right-single-arrow',\r\n    prevYear: 'fc-icon-left-double-arrow',\r\n    nextYear: 'fc-icon-right-double-arrow'\r\n};\r\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons';\r\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\r\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\r\n\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar JqueryUiTheme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JqueryUiTheme, _super);\r\n    function JqueryUiTheme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JqueryUiTheme;\r\n}(Theme_1.default));\r\nexports.default = JqueryUiTheme;\r\nJqueryUiTheme.prototype.classes = {\r\n    widget: 'ui-widget',\r\n    widgetHeader: 'ui-widget-header',\r\n    widgetContent: 'ui-widget-content',\r\n    buttonGroup: 'fc-button-group',\r\n    button: 'ui-button',\r\n    cornerLeft: 'ui-corner-left',\r\n    cornerRight: 'ui-corner-right',\r\n    stateDefault: 'ui-state-default',\r\n    stateActive: 'ui-state-active',\r\n    stateDisabled: 'ui-state-disabled',\r\n    stateHover: 'ui-state-hover',\r\n    stateDown: 'ui-state-down',\r\n    today: 'ui-state-highlight',\r\n    popoverHeader: 'ui-widget-header',\r\n    popoverContent: 'ui-widget-content',\r\n    // day grid\r\n    headerRow: 'ui-widget-header',\r\n    dayRow: 'ui-widget-content',\r\n    // list view\r\n    listView: 'ui-widget-content'\r\n};\r\nJqueryUiTheme.prototype.baseIconClass = 'ui-icon';\r\nJqueryUiTheme.prototype.iconClasses = {\r\n    close: 'ui-icon-closethick',\r\n    prev: 'ui-icon-circle-triangle-w',\r\n    next: 'ui-icon-circle-triangle-e',\r\n    prevYear: 'ui-icon-seek-prev',\r\n    nextYear: 'ui-icon-seek-next'\r\n};\r\nJqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';\r\nJqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';\r\nJqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';\r\n\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar FuncEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FuncEventSource, _super);\r\n    function FuncEventSource() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FuncEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if ($.isFunction(rawInput.events)) {\r\n            rawProps = rawInput;\r\n        }\r\n        else if ($.isFunction(rawInput)) {\r\n            rawProps = { events: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    FuncEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var _this = this;\r\n        this.calendar.pushLoading();\r\n        return Promise_1.default.construct(function (onResolve) {\r\n            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {\r\n                _this.calendar.popLoading();\r\n                onResolve(_this.parseEventDefs(rawEventDefs));\r\n            });\r\n        });\r\n    };\r\n    FuncEventSource.prototype.getPrimitive = function () {\r\n        return this.func;\r\n    };\r\n    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {\r\n        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);\r\n        this.func = rawProps.events;\r\n        return superSuccess;\r\n    };\r\n    return FuncEventSource;\r\n}(EventSource_1.default));\r\nexports.default = FuncEventSource;\r\nFuncEventSource.defineStandardProps({\r\n    events: false // don't automatically transfer\r\n});\r\n\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar JsonFeedEventSource = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsonFeedEventSource, _super);\r\n    function JsonFeedEventSource() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    JsonFeedEventSource.parse = function (rawInput, calendar) {\r\n        var rawProps;\r\n        // normalize raw input\r\n        if (typeof rawInput.url === 'string') {\r\n            rawProps = rawInput;\r\n        }\r\n        else if (typeof rawInput === 'string') {\r\n            rawProps = { url: rawInput };\r\n        }\r\n        if (rawProps) {\r\n            return EventSource_1.default.parse.call(this, rawProps, calendar);\r\n        }\r\n        return false;\r\n    };\r\n    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {\r\n        var _this = this;\r\n        var ajaxSettings = this.ajaxSettings;\r\n        var onSuccess = ajaxSettings.success;\r\n        var onError = ajaxSettings.error;\r\n        var requestParams = this.buildRequestParams(start, end, timezone);\r\n        // todo: eventually handle the promise's then,\r\n        // don't intercept success/error\r\n        // tho will be a breaking API change\r\n        this.calendar.pushLoading();\r\n        return Promise_1.default.construct(function (onResolve, onReject) {\r\n            $.ajax($.extend({}, // destination\r\n            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {\r\n                url: _this.url,\r\n                data: requestParams,\r\n                success: function (rawEventDefs, status, xhr) {\r\n                    var callbackRes;\r\n                    _this.calendar.popLoading();\r\n                    if (rawEventDefs) {\r\n                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`\r\n                        if ($.isArray(callbackRes)) {\r\n                            rawEventDefs = callbackRes;\r\n                        }\r\n                        onResolve(_this.parseEventDefs(rawEventDefs));\r\n                    }\r\n                    else {\r\n                        onReject();\r\n                    }\r\n                },\r\n                error: function (xhr, statusText, errorThrown) {\r\n                    _this.calendar.popLoading();\r\n                    util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`\r\n                    onReject();\r\n                }\r\n            }));\r\n        });\r\n    };\r\n    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {\r\n        var calendar = this.calendar;\r\n        var ajaxSettings = this.ajaxSettings;\r\n        var startParam;\r\n        var endParam;\r\n        var timezoneParam;\r\n        var customRequestParams;\r\n        var params = {};\r\n        startParam = this.startParam;\r\n        if (startParam == null) {\r\n            startParam = calendar.opt('startParam');\r\n        }\r\n        endParam = this.endParam;\r\n        if (endParam == null) {\r\n            endParam = calendar.opt('endParam');\r\n        }\r\n        timezoneParam = this.timezoneParam;\r\n        if (timezoneParam == null) {\r\n            timezoneParam = calendar.opt('timezoneParam');\r\n        }\r\n        // retrieve any outbound GET/POST $.ajax data from the options\r\n        if ($.isFunction(ajaxSettings.data)) {\r\n            // supplied as a function that returns a key/value object\r\n            customRequestParams = ajaxSettings.data();\r\n        }\r\n        else {\r\n            // probably supplied as a straight key/value object\r\n            customRequestParams = ajaxSettings.data || {};\r\n        }\r\n        $.extend(params, customRequestParams);\r\n        params[startParam] = start.format();\r\n        params[endParam] = end.format();\r\n        if (timezone && timezone !== 'local') {\r\n            params[timezoneParam] = timezone;\r\n        }\r\n        return params;\r\n    };\r\n    JsonFeedEventSource.prototype.getPrimitive = function () {\r\n        return this.url;\r\n    };\r\n    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {\r\n        this.ajaxSettings = rawProps;\r\n    };\r\n    JsonFeedEventSource.AJAX_DEFAULTS = {\r\n        dataType: 'json',\r\n        cache: false\r\n    };\r\n    return JsonFeedEventSource;\r\n}(EventSource_1.default));\r\nexports.default = JsonFeedEventSource;\r\nJsonFeedEventSource.defineStandardProps({\r\n    // automatically transfer (true)...\r\n    url: true,\r\n    startParam: true,\r\n    endParam: true,\r\n    timezoneParam: true\r\n});\r\n\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar TaskQueue = /** @class */ (function () {\r\n    function TaskQueue() {\r\n        this.q = [];\r\n        this.isPaused = false;\r\n        this.isRunning = false;\r\n    }\r\n    TaskQueue.prototype.queue = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this.q.push.apply(this.q, args); // append\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.pause = function () {\r\n        this.isPaused = true;\r\n    };\r\n    TaskQueue.prototype.resume = function () {\r\n        this.isPaused = false;\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.getIsIdle = function () {\r\n        return !this.isRunning && !this.isPaused;\r\n    };\r\n    TaskQueue.prototype.tryStart = function () {\r\n        if (!this.isRunning && this.canRunNext()) {\r\n            this.isRunning = true;\r\n            this.trigger('start');\r\n            this.runRemaining();\r\n        }\r\n    };\r\n    TaskQueue.prototype.canRunNext = function () {\r\n        return !this.isPaused && this.q.length;\r\n    };\r\n    TaskQueue.prototype.runRemaining = function () {\r\n        var _this = this;\r\n        var task;\r\n        var res;\r\n        do {\r\n            task = this.q.shift(); // always freshly reference q. might have been reassigned.\r\n            res = this.runTask(task);\r\n            if (res && res.then) {\r\n                res.then(function () {\r\n                    if (_this.canRunNext()) {\r\n                        _this.runRemaining();\r\n                    }\r\n                });\r\n                return; // prevent marking as stopped\r\n            }\r\n        } while (this.canRunNext());\r\n        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'\r\n        this.isRunning = false;\r\n        // if 'stop' handler added more tasks.... TODO: write test for this\r\n        this.tryStart();\r\n    };\r\n    TaskQueue.prototype.runTask = function (task) {\r\n        return task(); // task *is* the function, but subclasses can change the format of a task\r\n    };\r\n    return TaskQueue;\r\n}());\r\nexports.default = TaskQueue;\r\nEmitterMixin_1.default.mixInto(TaskQueue);\r\n\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar TaskQueue_1 = __webpack_require__(217);\r\nvar RenderQueue = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RenderQueue, _super);\r\n    function RenderQueue(waitsByNamespace) {\r\n        var _this = _super.call(this) || this;\r\n        _this.waitsByNamespace = waitsByNamespace || {};\r\n        return _this;\r\n    }\r\n    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {\r\n        var task = {\r\n            func: taskFunc,\r\n            namespace: namespace,\r\n            type: type\r\n        };\r\n        var waitMs;\r\n        if (namespace) {\r\n            waitMs = this.waitsByNamespace[namespace];\r\n        }\r\n        if (this.waitNamespace) {\r\n            if (namespace === this.waitNamespace && waitMs != null) {\r\n                this.delayWait(waitMs);\r\n            }\r\n            else {\r\n                this.clearWait();\r\n                this.tryStart();\r\n            }\r\n        }\r\n        if (this.compoundTask(task)) {\r\n            if (!this.waitNamespace && waitMs != null) {\r\n                this.startWait(namespace, waitMs);\r\n            }\r\n            else {\r\n                this.tryStart();\r\n            }\r\n        }\r\n    };\r\n    RenderQueue.prototype.startWait = function (namespace, waitMs) {\r\n        this.waitNamespace = namespace;\r\n        this.spawnWait(waitMs);\r\n    };\r\n    RenderQueue.prototype.delayWait = function (waitMs) {\r\n        clearTimeout(this.waitId);\r\n        this.spawnWait(waitMs);\r\n    };\r\n    RenderQueue.prototype.spawnWait = function (waitMs) {\r\n        var _this = this;\r\n        this.waitId = setTimeout(function () {\r\n            _this.waitNamespace = null;\r\n            _this.tryStart();\r\n        }, waitMs);\r\n    };\r\n    RenderQueue.prototype.clearWait = function () {\r\n        if (this.waitNamespace) {\r\n            clearTimeout(this.waitId);\r\n            this.waitId = null;\r\n            this.waitNamespace = null;\r\n        }\r\n    };\r\n    RenderQueue.prototype.canRunNext = function () {\r\n        if (!_super.prototype.canRunNext.call(this)) {\r\n            return false;\r\n        }\r\n        // waiting for a certain namespace to stop receiving tasks?\r\n        if (this.waitNamespace) {\r\n            var q = this.q;\r\n            // if there was a different namespace task in the meantime,\r\n            // that forces all previously-waiting tasks to suddenly execute.\r\n            // TODO: find a way to do this in constant time.\r\n            for (var i = 0; i < q.length; i++) {\r\n                if (q[i].namespace !== this.waitNamespace) {\r\n                    return true; // allow execution\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    RenderQueue.prototype.runTask = function (task) {\r\n        task.func();\r\n    };\r\n    RenderQueue.prototype.compoundTask = function (newTask) {\r\n        var q = this.q;\r\n        var shouldAppend = true;\r\n        var i;\r\n        var task;\r\n        if (newTask.namespace && newTask.type === 'destroy') {\r\n            // remove all init/add/remove ops with same namespace, regardless of order\r\n            for (i = q.length - 1; i >= 0; i--) {\r\n                task = q[i];\r\n                switch (task.type) {\r\n                    case 'init':\r\n                        shouldAppend = false;\r\n                    // the latest destroy is cancelled out by not doing the init\r\n                    /* falls through */\r\n                    case 'add':\r\n                    /* falls through */\r\n                    case 'remove':\r\n                        q.splice(i, 1); // remove task\r\n                }\r\n            }\r\n        }\r\n        if (shouldAppend) {\r\n            q.push(newTask);\r\n        }\r\n        return shouldAppend;\r\n    };\r\n    return RenderQueue;\r\n}(TaskQueue_1.default));\r\nexports.default = RenderQueue;\r\n\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar date_formatting_1 = __webpack_require__(47);\r\nvar Component_1 = __webpack_require__(237);\r\nvar util_2 = __webpack_require__(35);\r\nvar DateComponent = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateComponent, _super);\r\n    function DateComponent(_view, _options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.isRTL = false; // frequently accessed options\r\n        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits\r\n        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?\r\n        _this.isDatesRendered = false;\r\n        // hack to set options prior to the this.opt calls\r\n        if (_view) {\r\n            _this['view'] = _view;\r\n        }\r\n        if (_options) {\r\n            _this['options'] = _options;\r\n        }\r\n        _this.uid = String(DateComponent.guid++);\r\n        _this.childrenByUid = {};\r\n        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));\r\n        _this.isRTL = _this.opt('isRTL');\r\n        if (_this.fillRendererClass) {\r\n            _this.fillRenderer = new _this.fillRendererClass(_this);\r\n        }\r\n        if (_this.eventRendererClass) {\r\n            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);\r\n        }\r\n        if (_this.helperRendererClass && _this.eventRenderer) {\r\n            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);\r\n        }\r\n        if (_this.businessHourRendererClass && _this.fillRenderer) {\r\n            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);\r\n        }\r\n        return _this;\r\n    }\r\n    DateComponent.prototype.addChild = function (child) {\r\n        if (!this.childrenByUid[child.uid]) {\r\n            this.childrenByUid[child.uid] = child;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    DateComponent.prototype.removeChild = function (child) {\r\n        if (this.childrenByUid[child.uid]) {\r\n            delete this.childrenByUid[child.uid];\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    // TODO: only do if isInDom?\r\n    // TODO: make part of Component, along with children/batch-render system?\r\n    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        this.callChildren('updateSize', arguments);\r\n    };\r\n    // Options\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.opt = function (name) {\r\n        return this._getView().opt(name); // default implementation\r\n    };\r\n    DateComponent.prototype.publiclyTrigger = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var calendar = this._getCalendar();\r\n        return calendar.publiclyTrigger.apply(calendar, args);\r\n    };\r\n    DateComponent.prototype.hasPublicHandlers = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var calendar = this._getCalendar();\r\n        return calendar.hasPublicHandlers.apply(calendar, args);\r\n    };\r\n    // Date\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.executeDateRender = function (dateProfile) {\r\n        this.dateProfile = dateProfile; // for rendering\r\n        this.renderDates(dateProfile);\r\n        this.isDatesRendered = true;\r\n        this.callChildren('executeDateRender', arguments);\r\n    };\r\n    DateComponent.prototype.executeDateUnrender = function () {\r\n        this.callChildren('executeDateUnrender', arguments);\r\n        this.dateProfile = null;\r\n        this.unrenderDates();\r\n        this.isDatesRendered = false;\r\n    };\r\n    // date-cell content only\r\n    DateComponent.prototype.renderDates = function (dateProfile) {\r\n        // subclasses should implement\r\n    };\r\n    // date-cell content only\r\n    DateComponent.prototype.unrenderDates = function () {\r\n        // subclasses should override\r\n    };\r\n    // Now-Indicator\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\r\n    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.\r\n    DateComponent.prototype.getNowIndicatorUnit = function () {\r\n        // subclasses should implement\r\n    };\r\n    // Renders a current time indicator at the given datetime\r\n    DateComponent.prototype.renderNowIndicator = function (date) {\r\n        this.callChildren('renderNowIndicator', arguments);\r\n    };\r\n    // Undoes the rendering actions from renderNowIndicator\r\n    DateComponent.prototype.unrenderNowIndicator = function () {\r\n        this.callChildren('unrenderNowIndicator', arguments);\r\n    };\r\n    // Business Hours\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {\r\n        if (this.businessHourRenderer) {\r\n            this.businessHourRenderer.render(businessHourGenerator);\r\n        }\r\n        this.callChildren('renderBusinessHours', arguments);\r\n    };\r\n    // Unrenders previously-rendered business-hours\r\n    DateComponent.prototype.unrenderBusinessHours = function () {\r\n        this.callChildren('unrenderBusinessHours', arguments);\r\n        if (this.businessHourRenderer) {\r\n            this.businessHourRenderer.unrender();\r\n        }\r\n    };\r\n    // Event Displaying\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.executeEventRender = function (eventsPayload) {\r\n        if (this.eventRenderer) {\r\n            this.eventRenderer.rangeUpdated(); // poorly named now\r\n            this.eventRenderer.render(eventsPayload);\r\n        }\r\n        else if (this['renderEvents']) {\r\n            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));\r\n        }\r\n        this.callChildren('executeEventRender', arguments);\r\n    };\r\n    DateComponent.prototype.executeEventUnrender = function () {\r\n        this.callChildren('executeEventUnrender', arguments);\r\n        if (this.eventRenderer) {\r\n            this.eventRenderer.unrender();\r\n        }\r\n        else if (this['destroyEvents']) {\r\n            this['destroyEvents']();\r\n        }\r\n    };\r\n    DateComponent.prototype.getBusinessHourSegs = function () {\r\n        var segs = this.getOwnBusinessHourSegs();\r\n        this.iterChildren(function (child) {\r\n            segs.push.apply(segs, child.getBusinessHourSegs());\r\n        });\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.getOwnBusinessHourSegs = function () {\r\n        if (this.businessHourRenderer) {\r\n            return this.businessHourRenderer.getSegs();\r\n        }\r\n        return [];\r\n    };\r\n    DateComponent.prototype.getEventSegs = function () {\r\n        var segs = this.getOwnEventSegs();\r\n        this.iterChildren(function (child) {\r\n            segs.push.apply(segs, child.getEventSegs());\r\n        });\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.getOwnEventSegs = function () {\r\n        if (this.eventRenderer) {\r\n            return this.eventRenderer.getSegs();\r\n        }\r\n        return [];\r\n    };\r\n    // Event Rendering Triggering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.triggerAfterEventsRendered = function () {\r\n        this.triggerAfterEventSegsRendered(this.getEventSegs());\r\n        this.publiclyTrigger('eventAfterAllRender', {\r\n            context: this,\r\n            args: [this]\r\n        });\r\n    };\r\n    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {\r\n        var _this = this;\r\n        // an optimization, because getEventLegacy is expensive\r\n        if (this.hasPublicHandlers('eventAfterRender')) {\r\n            segs.forEach(function (seg) {\r\n                var legacy;\r\n                if (seg.el) {\r\n                    legacy = seg.footprint.getEventLegacy();\r\n                    _this.publiclyTrigger('eventAfterRender', {\r\n                        context: legacy,\r\n                        args: [legacy, seg.el, _this]\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {\r\n        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());\r\n    };\r\n    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {\r\n        var _this = this;\r\n        if (this.hasPublicHandlers('eventDestroy')) {\r\n            segs.forEach(function (seg) {\r\n                var legacy;\r\n                if (seg.el) {\r\n                    legacy = seg.footprint.getEventLegacy();\r\n                    _this.publiclyTrigger('eventDestroy', {\r\n                        context: legacy,\r\n                        args: [legacy, seg.el, _this]\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    // Event Rendering Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Hides all rendered event segments linked to the given event\r\n    // RECURSIVE with subcomponents\r\n    DateComponent.prototype.showEventsWithId = function (eventDefId) {\r\n        this.getEventSegs().forEach(function (seg) {\r\n            if (seg.footprint.eventDef.id === eventDefId &&\r\n                seg.el // necessary?\r\n            ) {\r\n                seg.el.css('visibility', '');\r\n            }\r\n        });\r\n        this.callChildren('showEventsWithId', arguments);\r\n    };\r\n    // Shows all rendered event segments linked to the given event\r\n    // RECURSIVE with subcomponents\r\n    DateComponent.prototype.hideEventsWithId = function (eventDefId) {\r\n        this.getEventSegs().forEach(function (seg) {\r\n            if (seg.footprint.eventDef.id === eventDefId &&\r\n                seg.el // necessary?\r\n            ) {\r\n                seg.el.css('visibility', 'hidden');\r\n            }\r\n        });\r\n        this.callChildren('hideEventsWithId', arguments);\r\n    };\r\n    // Drag-n-Drop Rendering (for both events and external elements)\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of a event or external-element drag over the given drop zone.\r\n    // If an external-element, seg will be `null`.\r\n    // Must return elements used for any mock events.\r\n    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var renderedHelper = false;\r\n        this.iterChildren(function (child) {\r\n            if (child.renderDrag(eventFootprints, seg, isTouch)) {\r\n                renderedHelper = true;\r\n            }\r\n        });\r\n        return renderedHelper;\r\n    };\r\n    // Unrenders a visual indication of an event or external-element being dragged.\r\n    DateComponent.prototype.unrenderDrag = function () {\r\n        this.callChildren('unrenderDrag', arguments);\r\n    };\r\n    // Event Resizing\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of an event being resized.\r\n    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        this.callChildren('renderEventResize', arguments);\r\n    };\r\n    // Unrenders a visual indication of an event being resized.\r\n    DateComponent.prototype.unrenderEventResize = function () {\r\n        this.callChildren('unrenderEventResize', arguments);\r\n    };\r\n    // Selection\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders a visual indication of the selection\r\n    // TODO: rename to `renderSelection` after legacy is gone\r\n    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        this.renderHighlight(componentFootprint);\r\n        this.callChildren('renderSelectionFootprint', arguments);\r\n    };\r\n    // Unrenders a visual indication of selection\r\n    DateComponent.prototype.unrenderSelection = function () {\r\n        this.unrenderHighlight();\r\n        this.callChildren('unrenderSelection', arguments);\r\n    };\r\n    // Highlight\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\r\n    DateComponent.prototype.renderHighlight = function (componentFootprint) {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.renderFootprint('highlight', componentFootprint, {\r\n                getClasses: function () {\r\n                    return ['fc-highlight'];\r\n                }\r\n            });\r\n        }\r\n        this.callChildren('renderHighlight', arguments);\r\n    };\r\n    // Unrenders the emphasis on a date range\r\n    DateComponent.prototype.unrenderHighlight = function () {\r\n        if (this.fillRenderer) {\r\n            this.fillRenderer.unrender('highlight');\r\n        }\r\n        this.callChildren('unrenderHighlight', arguments);\r\n    };\r\n    // Hit Areas\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    // just because all DateComponents support this interface\r\n    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.\r\n    DateComponent.prototype.hitsNeeded = function () {\r\n        if (!(this.hitsNeededDepth++)) {\r\n            this.prepareHits();\r\n        }\r\n        this.callChildren('hitsNeeded', arguments);\r\n    };\r\n    DateComponent.prototype.hitsNotNeeded = function () {\r\n        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\r\n            this.releaseHits();\r\n        }\r\n        this.callChildren('hitsNotNeeded', arguments);\r\n    };\r\n    DateComponent.prototype.prepareHits = function () {\r\n        // subclasses can implement\r\n    };\r\n    DateComponent.prototype.releaseHits = function () {\r\n        // subclasses can implement\r\n    };\r\n    // Given coordinates from the topleft of the document, return data about the date-related area underneath.\r\n    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\r\n    // Must have a `grid` property, a reference to this current grid. TODO: avoid this\r\n    // The returned object will be processed by getHitFootprint and getHitEl.\r\n    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {\r\n        var childrenByUid = this.childrenByUid;\r\n        var uid;\r\n        var hit;\r\n        for (uid in childrenByUid) {\r\n            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);\r\n            if (hit) {\r\n                break;\r\n            }\r\n        }\r\n        return hit;\r\n    };\r\n    DateComponent.prototype.getSafeHitFootprint = function (hit) {\r\n        var footprint = this.getHitFootprint(hit);\r\n        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {\r\n            return null;\r\n        }\r\n        return footprint;\r\n    };\r\n    DateComponent.prototype.getHitFootprint = function (hit) {\r\n        // what about being abstract!?\r\n    };\r\n    // Given position-level information about a date-related area within the grid,\r\n    // should return a jQuery element that best represents it. passed to dayClick callback.\r\n    DateComponent.prototype.getHitEl = function (hit) {\r\n        // what about being abstract!?\r\n    };\r\n    /* Converting eventRange -> eventFootprint\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {\r\n        var eventFootprints = [];\r\n        var i;\r\n        for (i = 0; i < eventRanges.length; i++) {\r\n            eventFootprints.push.apply(// append\r\n            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));\r\n        }\r\n        return eventFootprints;\r\n    };\r\n    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {\r\n        return [util_2.eventRangeToEventFootprint(eventRange)];\r\n    };\r\n    /* Converting componentFootprint/eventFootprint -> segs\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {\r\n        var segs = [];\r\n        var i;\r\n        for (i = 0; i < eventFootprints.length; i++) {\r\n            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));\r\n        }\r\n        return segs;\r\n    };\r\n    // Given an event's span (unzoned start/end and other misc data), and the event itself,\r\n    // slices into segments and attaches event-derived properties to them.\r\n    // eventSpan - { start, end, isStart, isEnd, otherthings... }\r\n    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {\r\n        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;\r\n        var segs;\r\n        var i;\r\n        var seg;\r\n        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (!unzonedRange.isStart) {\r\n                seg.isStart = false;\r\n            }\r\n            if (!unzonedRange.isEnd) {\r\n                seg.isEnd = false;\r\n            }\r\n            seg.footprint = eventFootprint;\r\n            // TODO: rename to seg.eventFootprint\r\n        }\r\n        return segs;\r\n    };\r\n    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        return [];\r\n    };\r\n    // Utils\r\n    // ---------------------------------------------------------------------------------------------------------------\r\n    DateComponent.prototype.callChildren = function (methodName, args) {\r\n        this.iterChildren(function (child) {\r\n            child[methodName].apply(child, args);\r\n        });\r\n    };\r\n    DateComponent.prototype.iterChildren = function (func) {\r\n        var childrenByUid = this.childrenByUid;\r\n        var uid;\r\n        for (uid in childrenByUid) {\r\n            func(childrenByUid[uid]);\r\n        }\r\n    };\r\n    DateComponent.prototype._getCalendar = function () {\r\n        var t = this;\r\n        return t.calendar || t.view.calendar;\r\n    };\r\n    DateComponent.prototype._getView = function () {\r\n        return this.view;\r\n    };\r\n    DateComponent.prototype._getDateProfile = function () {\r\n        return this._getView().get('dateProfile');\r\n    };\r\n    // Generates HTML for an anchor to another view into the calendar.\r\n    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\r\n    // `gotoOptions` can either be a moment input, or an object with the form:\r\n    // { date, type, forceOff }\r\n    // `type` is a view-type like \"day\" or \"week\". default value is \"day\".\r\n    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\r\n    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {\r\n        var date;\r\n        var type;\r\n        var forceOff;\r\n        var finalOptions;\r\n        if ($.isPlainObject(gotoOptions)) {\r\n            date = gotoOptions.date;\r\n            type = gotoOptions.type;\r\n            forceOff = gotoOptions.forceOff;\r\n        }\r\n        else {\r\n            date = gotoOptions; // a single moment input\r\n        }\r\n        date = moment_ext_1.default(date); // if a string, parse it\r\n        finalOptions = {\r\n            date: date.format('YYYY-MM-DD'),\r\n            type: type || 'day'\r\n        };\r\n        if (typeof attrs === 'string') {\r\n            innerHtml = attrs;\r\n            attrs = null;\r\n        }\r\n        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space\r\n        innerHtml = innerHtml || '';\r\n        if (!forceOff && this.opt('navLinks')) {\r\n            return '<a' + attrs +\r\n                ' data-goto=\"' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '\">' +\r\n                innerHtml +\r\n                '</a>';\r\n        }\r\n        else {\r\n            return '<span' + attrs + '>' +\r\n                innerHtml +\r\n                '</span>';\r\n        }\r\n    };\r\n    DateComponent.prototype.getAllDayHtml = function () {\r\n        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));\r\n    };\r\n    // Computes HTML classNames for a single-day element\r\n    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {\r\n        var view = this._getView();\r\n        var classes = [];\r\n        var today;\r\n        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {\r\n            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?\r\n        }\r\n        else {\r\n            classes.push('fc-' + util_1.dayIDs[date.day()]);\r\n            if (view.isDateInOtherMonth(date, this.dateProfile)) {\r\n                classes.push('fc-other-month');\r\n            }\r\n            today = view.calendar.getNow();\r\n            if (date.isSame(today, 'day')) {\r\n                classes.push('fc-today');\r\n                if (noThemeHighlight !== true) {\r\n                    classes.push(view.calendar.theme.getClass('today'));\r\n                }\r\n            }\r\n            else if (date < today) {\r\n                classes.push('fc-past');\r\n            }\r\n            else {\r\n                classes.push('fc-future');\r\n            }\r\n        }\r\n        return classes;\r\n    };\r\n    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\r\n    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\r\n    // The timezones of the dates within `range` will be respected.\r\n    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {\r\n        var end = range.end;\r\n        if (isAllDay) {\r\n            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day\r\n        }\r\n        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);\r\n    };\r\n    // Compute the number of the give units in the \"current\" range.\r\n    // Will return a floating-point number. Won't round.\r\n    DateComponent.prototype.currentRangeAs = function (unit) {\r\n        return this._getDateProfile().currentUnzonedRange.as(unit);\r\n    };\r\n    // Returns the date range of the full days the given range visually appears to occupy.\r\n    // Returns a plain object with start/end, NOT an UnzonedRange!\r\n    DateComponent.prototype.computeDayRange = function (unzonedRange) {\r\n        var calendar = this._getCalendar();\r\n        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts\r\n        var end = calendar.msToUtcMoment(unzonedRange.endMs);\r\n        var endTimeMS = +end.time(); // # of milliseconds into `endDay`\r\n        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\r\n        // If the end time is actually inclusively part of the next day and is equal to or\r\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\r\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\r\n        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {\r\n            endDay.add(1, 'days');\r\n        }\r\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\r\n        if (endDay <= startDay) {\r\n            endDay = startDay.clone().add(1, 'days');\r\n        }\r\n        return { start: startDay, end: endDay };\r\n    };\r\n    // Does the given range visually appear to occupy more than one day?\r\n    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {\r\n        var dayRange = this.computeDayRange(unzonedRange);\r\n        return dayRange.end.diff(dayRange.start, 'days') > 1;\r\n    };\r\n    DateComponent.guid = 0; // TODO: better system for this?\r\n    return DateComponent;\r\n}(Component_1.default));\r\nexports.default = DateComponent;\r\n// legacy\r\nfunction convertEventsPayloadToLegacyArray(eventsPayload) {\r\n    var eventDefId;\r\n    var eventInstances;\r\n    var legacyEvents = [];\r\n    var i;\r\n    for (eventDefId in eventsPayload) {\r\n        eventInstances = eventsPayload[eventDefId].eventInstances;\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            legacyEvents.push(eventInstances[i].toLegacy());\r\n        }\r\n    }\r\n    return legacyEvents;\r\n}\r\n\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar Iterator_1 = __webpack_require__(238);\r\nvar GlobalEmitter_1 = __webpack_require__(21);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Toolbar_1 = __webpack_require__(239);\r\nvar OptionsManager_1 = __webpack_require__(240);\r\nvar ViewSpecManager_1 = __webpack_require__(241);\r\nvar Constraints_1 = __webpack_require__(207);\r\nvar locale_1 = __webpack_require__(31);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar EventDateProfile_1 = __webpack_require__(17);\r\nvar EventManager_1 = __webpack_require__(242);\r\nvar BusinessHourGenerator_1 = __webpack_require__(212);\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar EventDefParser_1 = __webpack_require__(49);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nvar Calendar = /** @class */ (function () {\r\n    function Calendar(el, overrides) {\r\n        this.loadingLevel = 0; // number of simultaneous loading tasks\r\n        this.ignoreUpdateViewSize = 0;\r\n        this.freezeContentHeightDepth = 0;\r\n        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\r\n        // unneeded() is called in destroy.\r\n        GlobalEmitter_1.default.needed();\r\n        this.el = el;\r\n        this.viewsByType = {};\r\n        this.optionsManager = new OptionsManager_1.default(this, overrides);\r\n        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);\r\n        this.initMomentInternals(); // needs to happen after options hash initialized\r\n        this.initCurrentDate();\r\n        this.initEventManager();\r\n        this.constraints = new Constraints_1.default(this.eventManager, this);\r\n        this.constructed();\r\n    }\r\n    Calendar.prototype.constructed = function () {\r\n        // useful for monkeypatching. used?\r\n    };\r\n    Calendar.prototype.getView = function () {\r\n        return this.view;\r\n    };\r\n    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {\r\n        var optHandler = this.opt(name);\r\n        var context;\r\n        var args;\r\n        if ($.isPlainObject(triggerInfo)) {\r\n            context = triggerInfo.context;\r\n            args = triggerInfo.args;\r\n        }\r\n        else if ($.isArray(triggerInfo)) {\r\n            args = triggerInfo;\r\n        }\r\n        if (context == null) {\r\n            context = this.el[0]; // fallback context\r\n        }\r\n        if (!args) {\r\n            args = [];\r\n        }\r\n        this.triggerWith(name, context, args); // Emitter's method\r\n        if (optHandler) {\r\n            return optHandler.apply(context, args);\r\n        }\r\n    };\r\n    Calendar.prototype.hasPublicHandlers = function (name) {\r\n        return this.hasHandlers(name) ||\r\n            this.opt(name); // handler specified in options\r\n    };\r\n    // Options Public API\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // public getter/setter\r\n    Calendar.prototype.option = function (name, value) {\r\n        var newOptionHash;\r\n        if (typeof name === 'string') {\r\n            if (value === undefined) {\r\n                return this.optionsManager.get(name);\r\n            }\r\n            else {\r\n                newOptionHash = {};\r\n                newOptionHash[name] = value;\r\n                this.optionsManager.add(newOptionHash);\r\n            }\r\n        }\r\n        else if (typeof name === 'object') {\r\n            this.optionsManager.add(name);\r\n        }\r\n    };\r\n    // private getter\r\n    Calendar.prototype.opt = function (name) {\r\n        return this.optionsManager.get(name);\r\n    };\r\n    // View\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Given a view name for a custom view or a standard view, creates a ready-to-go View object\r\n    Calendar.prototype.instantiateView = function (viewType) {\r\n        var spec = this.viewSpecManager.getViewSpec(viewType);\r\n        if (!spec) {\r\n            throw new Error(\"View type \\\"\" + viewType + \"\\\" is not valid\");\r\n        }\r\n        return new spec['class'](this, spec);\r\n    };\r\n    // Returns a boolean about whether the view is okay to instantiate at some point\r\n    Calendar.prototype.isValidViewType = function (viewType) {\r\n        return Boolean(this.viewSpecManager.getViewSpec(viewType));\r\n    };\r\n    Calendar.prototype.changeView = function (viewName, dateOrRange) {\r\n        if (dateOrRange) {\r\n            if (dateOrRange.start && dateOrRange.end) {\r\n                this.optionsManager.recordOverrides({\r\n                    visibleRange: dateOrRange\r\n                });\r\n            }\r\n            else {\r\n                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\r\n            }\r\n        }\r\n        this.renderView(viewName);\r\n    };\r\n    // Forces navigation to a view for the given date.\r\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\r\n    Calendar.prototype.zoomTo = function (newDate, viewType) {\r\n        var spec;\r\n        viewType = viewType || 'day'; // day is default zoom\r\n        spec = this.viewSpecManager.getViewSpec(viewType) ||\r\n            this.viewSpecManager.getUnitViewSpec(viewType);\r\n        this.currentDate = newDate.clone();\r\n        this.renderView(spec ? spec.type : null);\r\n    };\r\n    // Current Date\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initCurrentDate = function () {\r\n        var defaultDateInput = this.opt('defaultDate');\r\n        // compute the initial ambig-timezone date\r\n        if (defaultDateInput != null) {\r\n            this.currentDate = this.moment(defaultDateInput).stripZone();\r\n        }\r\n        else {\r\n            this.currentDate = this.getNow(); // getNow already returns unzoned\r\n        }\r\n    };\r\n    Calendar.prototype.prev = function () {\r\n        var view = this.view;\r\n        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\r\n        if (prevInfo.isValid) {\r\n            this.currentDate = prevInfo.date;\r\n            this.renderView();\r\n        }\r\n    };\r\n    Calendar.prototype.next = function () {\r\n        var view = this.view;\r\n        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\r\n        if (nextInfo.isValid) {\r\n            this.currentDate = nextInfo.date;\r\n            this.renderView();\r\n        }\r\n    };\r\n    Calendar.prototype.prevYear = function () {\r\n        this.currentDate.add(-1, 'years');\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.nextYear = function () {\r\n        this.currentDate.add(1, 'years');\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.today = function () {\r\n        this.currentDate = this.getNow(); // should deny like prev/next?\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.gotoDate = function (zonedDateInput) {\r\n        this.currentDate = this.moment(zonedDateInput).stripZone();\r\n        this.renderView();\r\n    };\r\n    Calendar.prototype.incrementDate = function (delta) {\r\n        this.currentDate.add(moment.duration(delta));\r\n        this.renderView();\r\n    };\r\n    // for external API\r\n    Calendar.prototype.getDate = function () {\r\n        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone\r\n    };\r\n    // Loading Triggering\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // Should be called when any type of async data fetching begins\r\n    Calendar.prototype.pushLoading = function () {\r\n        if (!(this.loadingLevel++)) {\r\n            this.publiclyTrigger('loading', [true, this.view]);\r\n        }\r\n    };\r\n    // Should be called when any type of async data fetching completes\r\n    Calendar.prototype.popLoading = function () {\r\n        if (!(--this.loadingLevel)) {\r\n            this.publiclyTrigger('loading', [false, this.view]);\r\n        }\r\n    };\r\n    // High-level Rendering\r\n    // -----------------------------------------------------------------------------------\r\n    Calendar.prototype.render = function () {\r\n        if (!this.contentEl) {\r\n            this.initialRender();\r\n        }\r\n        else if (this.elementVisible()) {\r\n            // mainly for the public API\r\n            this.calcSize();\r\n            this.updateViewSize();\r\n        }\r\n    };\r\n    Calendar.prototype.initialRender = function () {\r\n        var _this = this;\r\n        var el = this.el;\r\n        el.addClass('fc');\r\n        // event delegation for nav links\r\n        el.on('click.fc', 'a[data-goto]', function (ev) {\r\n            var anchorEl = $(ev.currentTarget);\r\n            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\r\n            var date = _this.moment(gotoOptions.date);\r\n            var viewType = gotoOptions.type;\r\n            // property like \"navLinkDayClick\". might be a string or a function\r\n            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');\r\n            if (typeof customAction === 'function') {\r\n                customAction(date, ev);\r\n            }\r\n            else {\r\n                if (typeof customAction === 'string') {\r\n                    viewType = customAction;\r\n                }\r\n                _this.zoomTo(date, viewType);\r\n            }\r\n        });\r\n        // called immediately, and upon option change\r\n        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {\r\n            var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);\r\n            var theme = new themeClass(_this.optionsManager);\r\n            var widgetClass = theme.getClass('widget');\r\n            _this.theme = theme;\r\n            if (widgetClass) {\r\n                el.addClass(widgetClass);\r\n            }\r\n        }, function () {\r\n            var widgetClass = _this.theme.getClass('widget');\r\n            _this.theme = null;\r\n            if (widgetClass) {\r\n                el.removeClass(widgetClass);\r\n            }\r\n        });\r\n        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {\r\n            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);\r\n            if (_this.view) {\r\n                _this.view.set('businessHourGenerator', _this.businessHourGenerator);\r\n            }\r\n        }, function () {\r\n            _this.businessHourGenerator = null;\r\n        });\r\n        // called immediately, and upon option change.\r\n        // HACK: locale often affects isRTL, so we explicitly listen to that too.\r\n        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {\r\n            el.toggleClass('fc-ltr', !opts.isRTL);\r\n            el.toggleClass('fc-rtl', opts.isRTL);\r\n        });\r\n        this.contentEl = $(\"<div class='fc-view-container'/>\").prependTo(el);\r\n        this.initToolbars();\r\n        this.renderHeader();\r\n        this.renderFooter();\r\n        this.renderView(this.opt('defaultView'));\r\n        if (this.opt('handleWindowResize')) {\r\n            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls\r\n            this.windowResize.bind(this), this.opt('windowResizeDelay')));\r\n        }\r\n    };\r\n    Calendar.prototype.destroy = function () {\r\n        if (this.view) {\r\n            this.clearView();\r\n        }\r\n        this.toolbarsManager.proxyCall('removeElement');\r\n        this.contentEl.remove();\r\n        this.el.removeClass('fc fc-ltr fc-rtl');\r\n        // removes theme-related root className\r\n        this.optionsManager.unwatch('settingTheme');\r\n        this.optionsManager.unwatch('settingBusinessHourGenerator');\r\n        this.el.off('.fc'); // unbind nav link handlers\r\n        if (this.windowResizeProxy) {\r\n            $(window).unbind('resize', this.windowResizeProxy);\r\n            this.windowResizeProxy = null;\r\n        }\r\n        GlobalEmitter_1.default.unneeded();\r\n    };\r\n    Calendar.prototype.elementVisible = function () {\r\n        return this.el.is(':visible');\r\n    };\r\n    // Render Queue\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.bindViewHandlers = function (view) {\r\n        var _this = this;\r\n        view.watch('titleForCalendar', ['title'], function (deps) {\r\n            if (view === _this.view) {\r\n                _this.setToolbarsTitle(deps.title);\r\n            }\r\n        });\r\n        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {\r\n            if (view === _this.view) {\r\n                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates\r\n                _this.updateToolbarButtons(deps.dateProfile);\r\n            }\r\n        });\r\n    };\r\n    Calendar.prototype.unbindViewHandlers = function (view) {\r\n        view.unwatch('titleForCalendar');\r\n        view.unwatch('dateProfileForCalendar');\r\n    };\r\n    // View Rendering\r\n    // -----------------------------------------------------------------------------------\r\n    // Renders a view because of a date change, view-type change, or for the first time.\r\n    // If not given a viewType, keep the current view but render different dates.\r\n    // Accepts an optional scroll state to restore to.\r\n    Calendar.prototype.renderView = function (viewType) {\r\n        var oldView = this.view;\r\n        var newView;\r\n        this.freezeContentHeight();\r\n        if (oldView && viewType && oldView.type !== viewType) {\r\n            this.clearView();\r\n        }\r\n        // if viewType changed, or the view was never created, create a fresh view\r\n        if (!this.view && viewType) {\r\n            newView = this.view =\r\n                this.viewsByType[viewType] ||\r\n                    (this.viewsByType[viewType] = this.instantiateView(viewType));\r\n            this.bindViewHandlers(newView);\r\n            newView.startBatchRender(); // so that setElement+setDate rendering are joined\r\n            newView.setElement($(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(this.contentEl));\r\n            this.toolbarsManager.proxyCall('activateButton', viewType);\r\n        }\r\n        if (this.view) {\r\n            // prevent unnecessary change firing\r\n            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {\r\n                this.view.set('businessHourGenerator', this.businessHourGenerator);\r\n            }\r\n            this.view.setDate(this.currentDate);\r\n            if (newView) {\r\n                newView.stopBatchRender();\r\n            }\r\n        }\r\n        this.thawContentHeight();\r\n    };\r\n    // Unrenders the current view and reflects this change in the Header.\r\n    // Unregsiters the `view`, but does not remove from viewByType hash.\r\n    Calendar.prototype.clearView = function () {\r\n        var currentView = this.view;\r\n        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);\r\n        this.unbindViewHandlers(currentView);\r\n        currentView.removeElement();\r\n        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time\r\n        this.view = null;\r\n    };\r\n    // Destroys the view, including the view object. Then, re-instantiates it and renders it.\r\n    // Maintains the same scroll state.\r\n    // TODO: maintain any other user-manipulated state.\r\n    Calendar.prototype.reinitView = function () {\r\n        var oldView = this.view;\r\n        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll\r\n        this.freezeContentHeight();\r\n        this.clearView();\r\n        this.calcSize();\r\n        this.renderView(oldView.type); // needs the type to freshly render\r\n        this.view.applyScroll(scroll);\r\n        this.thawContentHeight();\r\n    };\r\n    // Resizing\r\n    // -----------------------------------------------------------------------------------\r\n    Calendar.prototype.getSuggestedViewHeight = function () {\r\n        if (this.suggestedViewHeight == null) {\r\n            this.calcSize();\r\n        }\r\n        return this.suggestedViewHeight;\r\n    };\r\n    Calendar.prototype.isHeightAuto = function () {\r\n        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\r\n    };\r\n    Calendar.prototype.updateViewSize = function (isResize) {\r\n        if (isResize === void 0) { isResize = false; }\r\n        var view = this.view;\r\n        var scroll;\r\n        if (!this.ignoreUpdateViewSize && view) {\r\n            if (isResize) {\r\n                this.calcSize();\r\n                scroll = view.queryScroll();\r\n            }\r\n            this.ignoreUpdateViewSize++;\r\n            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);\r\n            this.ignoreUpdateViewSize--;\r\n            if (isResize) {\r\n                view.applyScroll(scroll);\r\n            }\r\n            return true; // signal success\r\n        }\r\n    };\r\n    Calendar.prototype.calcSize = function () {\r\n        if (this.elementVisible()) {\r\n            this._calcSize();\r\n        }\r\n    };\r\n    Calendar.prototype._calcSize = function () {\r\n        var contentHeightInput = this.opt('contentHeight');\r\n        var heightInput = this.opt('height');\r\n        if (typeof contentHeightInput === 'number') {\r\n            this.suggestedViewHeight = contentHeightInput;\r\n        }\r\n        else if (typeof contentHeightInput === 'function') {\r\n            this.suggestedViewHeight = contentHeightInput();\r\n        }\r\n        else if (typeof heightInput === 'number') {\r\n            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\r\n        }\r\n        else if (typeof heightInput === 'function') {\r\n            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\r\n        }\r\n        else if (heightInput === 'parent') {\r\n            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\r\n        }\r\n        else {\r\n            this.suggestedViewHeight = Math.round(this.contentEl.width() /\r\n                Math.max(this.opt('aspectRatio'), .5));\r\n        }\r\n    };\r\n    Calendar.prototype.windowResize = function (ev) {\r\n        if (\r\n        // the purpose: so we don't process jqui \"resize\" events that have bubbled up\r\n        // cast to any because .target, which is Element, can't be compared to window for some reason.\r\n        ev.target === window &&\r\n            this.view &&\r\n            this.view.isDatesRendered) {\r\n            if (this.updateViewSize(true)) {\r\n                this.publiclyTrigger('windowResize', [this.view]);\r\n            }\r\n        }\r\n    };\r\n    /* Height \"Freezing\"\r\n    -----------------------------------------------------------------------------*/\r\n    Calendar.prototype.freezeContentHeight = function () {\r\n        if (!(this.freezeContentHeightDepth++)) {\r\n            this.forceFreezeContentHeight();\r\n        }\r\n    };\r\n    Calendar.prototype.forceFreezeContentHeight = function () {\r\n        this.contentEl.css({\r\n            width: '100%',\r\n            height: this.contentEl.height(),\r\n            overflow: 'hidden'\r\n        });\r\n    };\r\n    Calendar.prototype.thawContentHeight = function () {\r\n        this.freezeContentHeightDepth--;\r\n        // always bring back to natural height\r\n        this.contentEl.css({\r\n            width: '',\r\n            height: '',\r\n            overflow: ''\r\n        });\r\n        // but if there are future thaws, re-freeze\r\n        if (this.freezeContentHeightDepth) {\r\n            this.forceFreezeContentHeight();\r\n        }\r\n    };\r\n    // Toolbar\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initToolbars = function () {\r\n        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());\r\n        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());\r\n        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);\r\n    };\r\n    Calendar.prototype.computeHeaderOptions = function () {\r\n        return {\r\n            extraClasses: 'fc-header-toolbar',\r\n            layout: this.opt('header')\r\n        };\r\n    };\r\n    Calendar.prototype.computeFooterOptions = function () {\r\n        return {\r\n            extraClasses: 'fc-footer-toolbar',\r\n            layout: this.opt('footer')\r\n        };\r\n    };\r\n    // can be called repeatedly and Header will rerender\r\n    Calendar.prototype.renderHeader = function () {\r\n        var header = this.header;\r\n        header.setToolbarOptions(this.computeHeaderOptions());\r\n        header.render();\r\n        if (header.el) {\r\n            this.el.prepend(header.el);\r\n        }\r\n    };\r\n    // can be called repeatedly and Footer will rerender\r\n    Calendar.prototype.renderFooter = function () {\r\n        var footer = this.footer;\r\n        footer.setToolbarOptions(this.computeFooterOptions());\r\n        footer.render();\r\n        if (footer.el) {\r\n            this.el.append(footer.el);\r\n        }\r\n    };\r\n    Calendar.prototype.setToolbarsTitle = function (title) {\r\n        this.toolbarsManager.proxyCall('updateTitle', title);\r\n    };\r\n    Calendar.prototype.updateToolbarButtons = function (dateProfile) {\r\n        var now = this.getNow();\r\n        var view = this.view;\r\n        var todayInfo = view.dateProfileGenerator.build(now);\r\n        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));\r\n        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));\r\n        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?\r\n            'enableButton' :\r\n            'disableButton', 'today');\r\n        this.toolbarsManager.proxyCall(prevInfo.isValid ?\r\n            'enableButton' :\r\n            'disableButton', 'prev');\r\n        this.toolbarsManager.proxyCall(nextInfo.isValid ?\r\n            'enableButton' :\r\n            'disableButton', 'next');\r\n    };\r\n    Calendar.prototype.queryToolbarsHeight = function () {\r\n        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {\r\n            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\r\n            return accumulator + toolbarHeight;\r\n        }, 0);\r\n    };\r\n    // Selection\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    // this public method receives start/end dates in any format, with any timezone\r\n    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {\r\n        this.view.select(this.buildSelectFootprint.apply(this, arguments));\r\n    };\r\n    Calendar.prototype.unselect = function () {\r\n        if (this.view) {\r\n            this.view.unselect();\r\n        }\r\n    };\r\n    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\r\n    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {\r\n        var start = this.moment(zonedStartInput).stripZone();\r\n        var end;\r\n        if (zonedEndInput) {\r\n            end = this.moment(zonedEndInput).stripZone();\r\n        }\r\n        else if (start.hasTime()) {\r\n            end = start.clone().add(this.defaultTimedEventDuration);\r\n        }\r\n        else {\r\n            end = start.clone().add(this.defaultAllDayEventDuration);\r\n        }\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());\r\n    };\r\n    // Date Utils\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initMomentInternals = function () {\r\n        var _this = this;\r\n        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\r\n        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\r\n        // Called immediately, and when any of the options change.\r\n        // Happens before any internal objects rebuild or rerender, because this is very core.\r\n        this.optionsManager.watch('buildingMomentLocale', [\r\n            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\r\n            '?firstDay', '?weekNumberCalculation'\r\n        ], function (opts) {\r\n            var weekNumberCalculation = opts.weekNumberCalculation;\r\n            var firstDay = opts.firstDay;\r\n            var _week;\r\n            // normalize\r\n            if (weekNumberCalculation === 'iso') {\r\n                weekNumberCalculation = 'ISO'; // normalize\r\n            }\r\n            var localeData = Object.create(// make a cheap copy\r\n            locale_1.getMomentLocaleData(opts.locale) // will fall back to en\r\n            );\r\n            if (opts.monthNames) {\r\n                localeData._months = opts.monthNames;\r\n            }\r\n            if (opts.monthNamesShort) {\r\n                localeData._monthsShort = opts.monthNamesShort;\r\n            }\r\n            if (opts.dayNames) {\r\n                localeData._weekdays = opts.dayNames;\r\n            }\r\n            if (opts.dayNamesShort) {\r\n                localeData._weekdaysShort = opts.dayNamesShort;\r\n            }\r\n            if (firstDay == null && weekNumberCalculation === 'ISO') {\r\n                firstDay = 1;\r\n            }\r\n            if (firstDay != null) {\r\n                _week = Object.create(localeData._week); // _week: { dow: # }\r\n                _week.dow = firstDay;\r\n                localeData._week = _week;\r\n            }\r\n            if (weekNumberCalculation === 'ISO' ||\r\n                weekNumberCalculation === 'local' ||\r\n                typeof weekNumberCalculation === 'function') {\r\n                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\r\n            }\r\n            _this.localeData = localeData;\r\n            // If the internal current date object already exists, move to new locale.\r\n            // We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\r\n            if (_this.currentDate) {\r\n                _this.localizeMoment(_this.currentDate); // sets to localeData\r\n            }\r\n        });\r\n    };\r\n    // Builds a moment using the settings of the current calendar: timezone and locale.\r\n    // Accepts anything the vanilla moment() constructor accepts.\r\n    Calendar.prototype.moment = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var mom;\r\n        if (this.opt('timezone') === 'local') {\r\n            mom = moment_ext_1.default.apply(null, args);\r\n            // Force the moment to be local, because momentExt doesn't guarantee it.\r\n            if (mom.hasTime()) {\r\n                mom.local();\r\n            }\r\n        }\r\n        else if (this.opt('timezone') === 'UTC') {\r\n            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC\r\n        }\r\n        else {\r\n            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone\r\n        }\r\n        this.localizeMoment(mom); // TODO\r\n        return mom;\r\n    };\r\n    Calendar.prototype.msToMoment = function (ms, forceAllDay) {\r\n        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\r\n        if (forceAllDay) {\r\n            mom.stripTime();\r\n        }\r\n        else {\r\n            mom = this.applyTimezone(mom); // may or may not apply locale\r\n        }\r\n        this.localizeMoment(mom);\r\n        return mom;\r\n    };\r\n    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {\r\n        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC\r\n        if (forceAllDay) {\r\n            mom.stripTime();\r\n        }\r\n        this.localizeMoment(mom);\r\n        return mom;\r\n    };\r\n    // Updates the given moment's locale settings to the current calendar locale settings.\r\n    Calendar.prototype.localizeMoment = function (mom) {\r\n        mom._locale = this.localeData;\r\n    };\r\n    // Returns a boolean about whether or not the calendar knows how to calculate\r\n    // the timezone offset of arbitrary dates in the current timezone.\r\n    Calendar.prototype.getIsAmbigTimezone = function () {\r\n        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\r\n    };\r\n    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.\r\n    Calendar.prototype.applyTimezone = function (date) {\r\n        if (!date.hasTime()) {\r\n            return date.clone();\r\n        }\r\n        var zonedDate = this.moment(date.toArray());\r\n        var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();\r\n        var adjustedZonedDate;\r\n        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\r\n        if (timeAdjust) {\r\n            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\r\n            if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) {\r\n                zonedDate = adjustedZonedDate;\r\n            }\r\n        }\r\n        return zonedDate;\r\n    };\r\n    /*\r\n    Assumes the footprint is non-open-ended.\r\n    */\r\n    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {\r\n        if (ignoreEnd === void 0) { ignoreEnd = false; }\r\n        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);\r\n        var end;\r\n        if (!ignoreEnd) {\r\n            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);\r\n        }\r\n        if (componentFootprint.isAllDay) {\r\n            start.stripTime();\r\n            if (end) {\r\n                end.stripTime();\r\n            }\r\n        }\r\n        else {\r\n            start = this.applyTimezone(start);\r\n            if (end) {\r\n                end = this.applyTimezone(end);\r\n            }\r\n        }\r\n        return new EventDateProfile_1.default(start, end, this);\r\n    };\r\n    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.\r\n    // Will return an moment with an ambiguous timezone.\r\n    Calendar.prototype.getNow = function () {\r\n        var now = this.opt('now');\r\n        if (typeof now === 'function') {\r\n            now = now();\r\n        }\r\n        return this.moment(now).stripZone();\r\n    };\r\n    // Produces a human-readable string for the given duration.\r\n    // Side-effect: changes the locale of the given duration.\r\n    Calendar.prototype.humanizeDuration = function (duration) {\r\n        return duration.locale(this.opt('locale')).humanize();\r\n    };\r\n    // will return `null` if invalid range\r\n    Calendar.prototype.parseUnzonedRange = function (rangeInput) {\r\n        var start = null;\r\n        var end = null;\r\n        if (rangeInput.start) {\r\n            start = this.moment(rangeInput.start).stripZone();\r\n        }\r\n        if (rangeInput.end) {\r\n            end = this.moment(rangeInput.end).stripZone();\r\n        }\r\n        if (!start && !end) {\r\n            return null;\r\n        }\r\n        if (start && end && end.isBefore(start)) {\r\n            return null;\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Event-Date Utilities\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.initEventManager = function () {\r\n        var _this = this;\r\n        var eventManager = new EventManager_1.default(this);\r\n        var rawSources = this.opt('eventSources') || [];\r\n        var singleRawSource = this.opt('events');\r\n        this.eventManager = eventManager;\r\n        if (singleRawSource) {\r\n            rawSources.unshift(singleRawSource);\r\n        }\r\n        eventManager.on('release', function (eventsPayload) {\r\n            _this.trigger('eventsReset', eventsPayload);\r\n        });\r\n        eventManager.freeze();\r\n        rawSources.forEach(function (rawSource) {\r\n            var source = EventSourceParser_1.default.parse(rawSource, _this);\r\n            if (source) {\r\n                eventManager.addSource(source);\r\n            }\r\n        });\r\n        eventManager.thaw();\r\n    };\r\n    Calendar.prototype.requestEvents = function (start, end) {\r\n        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));\r\n    };\r\n    // Get an event's normalized end date. If not present, calculate it from the defaults.\r\n    Calendar.prototype.getEventEnd = function (event) {\r\n        if (event.end) {\r\n            return event.end.clone();\r\n        }\r\n        else {\r\n            return this.getDefaultEventEnd(event.allDay, event.start);\r\n        }\r\n    };\r\n    // Given an event's allDay status and start date, return what its fallback end date should be.\r\n    // TODO: rename to computeDefaultEventEnd\r\n    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {\r\n        var end = zonedStart.clone();\r\n        if (allDay) {\r\n            end.stripTime().add(this.defaultAllDayEventDuration);\r\n        }\r\n        else {\r\n            end.add(this.defaultTimedEventDuration);\r\n        }\r\n        if (this.getIsAmbigTimezone()) {\r\n            end.stripZone(); // we don't know what the tzo should be\r\n        }\r\n        return end;\r\n    };\r\n    // Public Events API\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Calendar.prototype.rerenderEvents = function () {\r\n        this.view.flash('displayingEvents');\r\n    };\r\n    Calendar.prototype.refetchEvents = function () {\r\n        this.eventManager.refetchAllSources();\r\n    };\r\n    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {\r\n        this.eventManager.freeze();\r\n        for (var i = 0; i < eventInputs.length; i++) {\r\n            this.renderEvent(eventInputs[i], isSticky);\r\n        }\r\n        this.eventManager.thaw();\r\n    };\r\n    Calendar.prototype.renderEvent = function (eventInput, isSticky) {\r\n        if (isSticky === void 0) { isSticky = false; }\r\n        var eventManager = this.eventManager;\r\n        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);\r\n        if (eventDef) {\r\n            eventManager.addEventDef(eventDef, isSticky);\r\n        }\r\n    };\r\n    // legacyQuery operates on legacy event instance objects\r\n    Calendar.prototype.removeEvents = function (legacyQuery) {\r\n        var eventManager = this.eventManager;\r\n        var legacyInstances = [];\r\n        var idMap = {};\r\n        var eventDef;\r\n        var i;\r\n        if (legacyQuery == null) {\r\n            eventManager.removeAllEventDefs(); // persist=true\r\n        }\r\n        else {\r\n            eventManager.getEventInstances().forEach(function (eventInstance) {\r\n                legacyInstances.push(eventInstance.toLegacy());\r\n            });\r\n            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);\r\n            // compute unique IDs\r\n            for (i = 0; i < legacyInstances.length; i++) {\r\n                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);\r\n                idMap[eventDef.id] = true;\r\n            }\r\n            eventManager.freeze();\r\n            for (i in idMap) {\r\n                eventManager.removeEventDefsById(i); // persist=true\r\n            }\r\n            eventManager.thaw();\r\n        }\r\n    };\r\n    // legacyQuery operates on legacy event instance objects\r\n    Calendar.prototype.clientEvents = function (legacyQuery) {\r\n        var legacyEventInstances = [];\r\n        this.eventManager.getEventInstances().forEach(function (eventInstance) {\r\n            legacyEventInstances.push(eventInstance.toLegacy());\r\n        });\r\n        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);\r\n    };\r\n    Calendar.prototype.updateEvents = function (eventPropsArray) {\r\n        this.eventManager.freeze();\r\n        for (var i = 0; i < eventPropsArray.length; i++) {\r\n            this.updateEvent(eventPropsArray[i]);\r\n        }\r\n        this.eventManager.thaw();\r\n    };\r\n    Calendar.prototype.updateEvent = function (eventProps) {\r\n        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);\r\n        var eventInstance;\r\n        var eventDefMutation;\r\n        if (eventDef instanceof SingleEventDef_1.default) {\r\n            eventInstance = eventDef.buildInstance();\r\n            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props\r\n            null // largeUnit -- who uses it?\r\n            );\r\n            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release\r\n        }\r\n    };\r\n    // Public Event Sources API\r\n    // ------------------------------------------------------------------------------------\r\n    Calendar.prototype.getEventSources = function () {\r\n        return this.eventManager.otherSources.slice(); // clone\r\n    };\r\n    Calendar.prototype.getEventSourceById = function (id) {\r\n        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));\r\n    };\r\n    Calendar.prototype.addEventSource = function (sourceInput) {\r\n        var source = EventSourceParser_1.default.parse(sourceInput, this);\r\n        if (source) {\r\n            this.eventManager.addSource(source);\r\n        }\r\n    };\r\n    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources;\r\n        var i;\r\n        if (sourceMultiQuery == null) {\r\n            this.eventManager.removeAllSources();\r\n        }\r\n        else {\r\n            sources = eventManager.multiQuerySources(sourceMultiQuery);\r\n            eventManager.freeze();\r\n            for (i = 0; i < sources.length; i++) {\r\n                eventManager.removeSource(sources[i]);\r\n            }\r\n            eventManager.thaw();\r\n        }\r\n    };\r\n    Calendar.prototype.removeEventSource = function (sourceQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources = eventManager.querySources(sourceQuery);\r\n        var i;\r\n        eventManager.freeze();\r\n        for (i = 0; i < sources.length; i++) {\r\n            eventManager.removeSource(sources[i]);\r\n        }\r\n        eventManager.thaw();\r\n    };\r\n    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {\r\n        var eventManager = this.eventManager;\r\n        var sources = eventManager.multiQuerySources(sourceMultiQuery);\r\n        var i;\r\n        eventManager.freeze();\r\n        for (i = 0; i < sources.length; i++) {\r\n            eventManager.refetchSource(sources[i]);\r\n        }\r\n        eventManager.thaw();\r\n    };\r\n    // not for internal use. use options module directly instead.\r\n    Calendar.defaults = options_1.globalDefaults;\r\n    Calendar.englishDefaults = options_1.englishDefaults;\r\n    Calendar.rtlDefaults = options_1.rtlDefaults;\r\n    return Calendar;\r\n}());\r\nexports.default = Calendar;\r\nEmitterMixin_1.default.mixInto(Calendar);\r\nListenerMixin_1.default.mixInto(Calendar);\r\nfunction filterLegacyEventInstances(legacyEventInstances, legacyQuery) {\r\n    if (legacyQuery == null) {\r\n        return legacyEventInstances;\r\n    }\r\n    else if ($.isFunction(legacyQuery)) {\r\n        return legacyEventInstances.filter(legacyQuery);\r\n    }\r\n    else {\r\n        legacyQuery += ''; // normalize to string\r\n        return legacyEventInstances.filter(function (legacyEventInstance) {\r\n            // soft comparison because id not be normalized to string\r\n            // tslint:disable-next-line\r\n            return legacyEventInstance.id == legacyQuery ||\r\n                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match\r\n        });\r\n    }\r\n}\r\n\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar DateProfileGenerator = /** @class */ (function () {\r\n    function DateProfileGenerator(_view) {\r\n        this._view = _view;\r\n    }\r\n    DateProfileGenerator.prototype.opt = function (name) {\r\n        return this._view.opt(name);\r\n    };\r\n    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {\r\n        return this._view.trimHiddenDays(unzonedRange);\r\n    };\r\n    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {\r\n        return this._view.calendar.msToUtcMoment(ms, forceAllDay);\r\n    };\r\n    /* Date Range Computation\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\r\n    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {\r\n        var prevDate = currentDateProfile.date.clone()\r\n            .startOf(currentDateProfile.currentRangeUnit)\r\n            .subtract(currentDateProfile.dateIncrement);\r\n        return this.build(prevDate, -1);\r\n    };\r\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\r\n    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {\r\n        var nextDate = currentDateProfile.date.clone()\r\n            .startOf(currentDateProfile.currentRangeUnit)\r\n            .add(currentDateProfile.dateIncrement);\r\n        return this.build(nextDate, 1);\r\n    };\r\n    // Builds a structure holding dates/ranges for rendering around the given date.\r\n    // Optional direction param indicates whether the date is being incremented/decremented\r\n    // from its previous value. decremented = -1, incremented = 1 (default).\r\n    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {\r\n        if (forceToValid === void 0) { forceToValid = false; }\r\n        var isDateAllDay = !date.hasTime();\r\n        var validUnzonedRange;\r\n        var minTime = null;\r\n        var maxTime = null;\r\n        var currentInfo;\r\n        var isRangeAllDay;\r\n        var renderUnzonedRange;\r\n        var activeUnzonedRange;\r\n        var isValid;\r\n        validUnzonedRange = this.buildValidRange();\r\n        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);\r\n        if (forceToValid) {\r\n            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS\r\n            isDateAllDay);\r\n        }\r\n        currentInfo = this.buildCurrentRangeInfo(date, direction);\r\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\r\n        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);\r\n        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);\r\n        activeUnzonedRange = renderUnzonedRange.clone();\r\n        if (!this.opt('showNonCurrentDates')) {\r\n            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);\r\n        }\r\n        minTime = moment.duration(this.opt('minTime'));\r\n        maxTime = moment.duration(this.opt('maxTime'));\r\n        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);\r\n        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null\r\n        if (activeUnzonedRange) {\r\n            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS\r\n            isDateAllDay);\r\n        }\r\n        // it's invalid if the originally requested date is not contained,\r\n        // or if the range is completely outside of the valid range.\r\n        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);\r\n        return {\r\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\r\n            // an object with optional start and end properties.\r\n            validUnzonedRange: validUnzonedRange,\r\n            // range the view is formally responsible for.\r\n            // for example, a month view might have 1st-31st, excluding padded dates\r\n            currentUnzonedRange: currentInfo.unzonedRange,\r\n            // name of largest unit being displayed, like \"month\" or \"week\"\r\n            currentRangeUnit: currentInfo.unit,\r\n            isRangeAllDay: isRangeAllDay,\r\n            // dates that display events and accept drag-n-drop\r\n            // will be `null` if no dates accept events\r\n            activeUnzonedRange: activeUnzonedRange,\r\n            // date range with a rendered skeleton\r\n            // includes not-active days that need some sort of DOM\r\n            renderUnzonedRange: renderUnzonedRange,\r\n            // Duration object that denotes the first visible time of any given day\r\n            minTime: minTime,\r\n            // Duration object that denotes the exclusive visible end time of any given day\r\n            maxTime: maxTime,\r\n            isValid: isValid,\r\n            date: date,\r\n            // how far the current date will move for a prev/next operation\r\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\r\n            // pass a fallback (might be null) ^\r\n        };\r\n    };\r\n    // Builds an object with optional start/end properties.\r\n    // Indicates the minimum/maximum dates to display.\r\n    // not responsible for trimming hidden days.\r\n    DateProfileGenerator.prototype.buildValidRange = function () {\r\n        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||\r\n            new UnzonedRange_1.default(); // completely open-ended\r\n    };\r\n    // Builds a structure with info about the \"current\" range, the range that is\r\n    // highlighted as being the current month for example.\r\n    // See build() for a description of `direction`.\r\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\r\n        var viewSpec = this._view.viewSpec;\r\n        var duration = null;\r\n        var unit = null;\r\n        var unzonedRange = null;\r\n        var dayCount;\r\n        if (viewSpec.duration) {\r\n            duration = viewSpec.duration;\r\n            unit = viewSpec.durationUnit;\r\n            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n        }\r\n        else if ((dayCount = this.opt('dayCount'))) {\r\n            unit = 'day';\r\n            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);\r\n        }\r\n        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {\r\n            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());\r\n        }\r\n        else {\r\n            duration = this.getFallbackDuration();\r\n            unit = util_1.computeGreatestUnit(duration);\r\n            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n        }\r\n        return { duration: duration, unit: unit, unzonedRange: unzonedRange };\r\n    };\r\n    DateProfileGenerator.prototype.getFallbackDuration = function () {\r\n        return moment.duration({ days: 1 });\r\n    };\r\n    // Returns a new activeUnzonedRange to have time values (un-ambiguate)\r\n    // minTime or maxTime causes the range to expand.\r\n    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {\r\n        var start = unzonedRange.getStart();\r\n        var end = unzonedRange.getEnd();\r\n        if (this._view.usesMinMaxTime) {\r\n            if (minTime < 0) {\r\n                start.time(0).add(minTime);\r\n            }\r\n            if (maxTime > 24 * 60 * 60 * 1000) {\r\n                end.time(maxTime - (24 * 60 * 60 * 1000));\r\n            }\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Builds the \"current\" range when it is specified as an explicit duration.\r\n    // `unit` is the already-computed computeGreatestUnit value of duration.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\r\n        var alignment = this.opt('dateAlignment');\r\n        var dateIncrementInput;\r\n        var dateIncrementDuration;\r\n        var start;\r\n        var end;\r\n        var res;\r\n        // compute what the alignment should be\r\n        if (!alignment) {\r\n            dateIncrementInput = this.opt('dateIncrement');\r\n            if (dateIncrementInput) {\r\n                dateIncrementDuration = moment.duration(dateIncrementInput);\r\n                // use the smaller of the two units\r\n                if (dateIncrementDuration < duration) {\r\n                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\r\n                }\r\n                else {\r\n                    alignment = unit;\r\n                }\r\n            }\r\n            else {\r\n                alignment = unit;\r\n            }\r\n        }\r\n        // if the view displays a single day or smaller\r\n        if (duration.as('days') <= 1) {\r\n            if (this._view.isHiddenDay(start)) {\r\n                start = this._view.skipHiddenDays(start, direction);\r\n                start.startOf('day');\r\n            }\r\n        }\r\n        function computeRes() {\r\n            start = date.clone().startOf(alignment);\r\n            end = start.clone().add(duration);\r\n            res = new UnzonedRange_1.default(start, end);\r\n        }\r\n        computeRes();\r\n        // if range is completely enveloped by hidden days, go past the hidden days\r\n        if (!this.trimHiddenDays(res)) {\r\n            date = this._view.skipHiddenDays(date, direction);\r\n            computeRes();\r\n        }\r\n        return res;\r\n    };\r\n    // Builds the \"current\" range when a dayCount is specified.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\r\n        var customAlignment = this.opt('dateAlignment');\r\n        var runningCount = 0;\r\n        var start = date.clone();\r\n        var end;\r\n        if (customAlignment) {\r\n            start.startOf(customAlignment);\r\n        }\r\n        start.startOf('day');\r\n        start = this._view.skipHiddenDays(start, direction);\r\n        end = start.clone();\r\n        do {\r\n            end.add(1, 'day');\r\n            if (!this._view.isHiddenDay(end)) {\r\n                runningCount++;\r\n            }\r\n        } while (runningCount < dayCount);\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    // Builds a normalized range object for the \"visible\" range,\r\n    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.\r\n    // TODO: accept a MS-time instead of a moment `date`?\r\n    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\r\n        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations\r\n        );\r\n        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {\r\n            return null;\r\n        }\r\n        return visibleUnzonedRange;\r\n    };\r\n    // Computes the range that will represent the element/cells for *rendering*,\r\n    // but which may have voided days/times.\r\n    // not responsible for trimming hidden days.\r\n    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        return currentUnzonedRange.clone();\r\n    };\r\n    // Compute the duration value that should be added/substracted to the current date\r\n    // when a prev/next operation happens.\r\n    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\r\n        var dateIncrementInput = this.opt('dateIncrement');\r\n        var customAlignment;\r\n        if (dateIncrementInput) {\r\n            return moment.duration(dateIncrementInput);\r\n        }\r\n        else if ((customAlignment = this.opt('dateAlignment'))) {\r\n            return moment.duration(1, customAlignment);\r\n        }\r\n        else if (fallback) {\r\n            return fallback;\r\n        }\r\n        else {\r\n            return moment.duration({ days: 1 });\r\n        }\r\n    };\r\n    return DateProfileGenerator;\r\n}());\r\nexports.default = DateProfileGenerator;\r\n\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar exportHooks = __webpack_require__(16);\r\nvar util_1 = __webpack_require__(4);\r\nvar moment_ext_1 = __webpack_require__(10);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar ExternalDropping = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExternalDropping, _super);\r\n    function ExternalDropping() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.isDragging = false; // jqui-dragging an external element? boolean\r\n        return _this;\r\n    }\r\n    /*\r\n    component impements:\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n      - isExternalInstanceGroupAllowed\r\n      - renderDrag\r\n      - unrenderDrag\r\n    */\r\n    ExternalDropping.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    ExternalDropping.prototype.bindToDocument = function () {\r\n        this.listenTo($(document), {\r\n            dragstart: this.handleDragStart,\r\n            sortstart: this.handleDragStart // jqui\r\n        });\r\n    };\r\n    ExternalDropping.prototype.unbindFromDocument = function () {\r\n        this.stopListeningTo($(document));\r\n    };\r\n    // Called when a jQuery UI drag is initiated anywhere in the DOM\r\n    ExternalDropping.prototype.handleDragStart = function (ev, ui) {\r\n        var el;\r\n        var accept;\r\n        if (this.opt('droppable')) {\r\n            el = $((ui ? ui.item : null) || ev.target);\r\n            // Test that the dragged element passes the dropAccept selector or filter function.\r\n            // FYI, the default is \"*\" (matches all)\r\n            accept = this.opt('dropAccept');\r\n            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\r\n                if (!this.isDragging) {\r\n                    this.listenToExternalDrag(el, ev, ui);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Called when a jQuery UI drag starts and it needs to be monitored for dropping\r\n    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\r\n        var singleEventDef; // a null value signals an unsuccessful drag\r\n        // listener that tracks mouse movement over date-associated pixel regions\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(component, {\r\n            interactionStart: function () {\r\n                _this.isDragging = true;\r\n            },\r\n            hitOver: function (hit) {\r\n                var isAllowed = true;\r\n                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid\r\n                var mutatedEventInstanceGroup;\r\n                if (hitFootprint) {\r\n                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);\r\n                    if (singleEventDef) {\r\n                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());\r\n                        isAllowed = meta.eventProps ? // isEvent?\r\n                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :\r\n                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    singleEventDef = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                if (singleEventDef) {\r\n                    component.renderDrag(// called without a seg parameter\r\n                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                singleEventDef = null; // signal unsuccessful\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n                component.unrenderDrag();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                if (singleEventDef) {\r\n                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent\r\n                    Boolean(meta.stick), // isSticky\r\n                    el, ev, ui);\r\n                }\r\n                _this.isDragging = false;\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        dragListener.startDrag(ev); // start listening immediately\r\n    };\r\n    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\r\n    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\r\n    // Returning a null value signals an invalid drop hit.\r\n    // DOES NOT consider overlap/constraint.\r\n    // Assumes both footprints are non-open-ended.\r\n    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {\r\n        var calendar = this.view.calendar;\r\n        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();\r\n        var end;\r\n        var eventDef;\r\n        if (componentFootprint.isAllDay) {\r\n            // if dropped on an all-day span, and element's metadata specified a time, set it\r\n            if (meta.startTime) {\r\n                start.time(meta.startTime);\r\n            }\r\n            else {\r\n                start.stripTime();\r\n            }\r\n        }\r\n        if (meta.duration) {\r\n            end = start.clone().add(meta.duration);\r\n        }\r\n        start = calendar.applyTimezone(start);\r\n        if (end) {\r\n            end = calendar.applyTimezone(end);\r\n        }\r\n        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {\r\n            start: start,\r\n            end: end\r\n        }), new EventSource_1.default(calendar));\r\n        return eventDef;\r\n    };\r\n    return ExternalDropping;\r\n}(Interaction_1.default));\r\nexports.default = ExternalDropping;\r\nListenerMixin_1.default.mixInto(ExternalDropping);\r\n/* External-Dragging-Element Data\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\r\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\r\nexportHooks.dataAttrPrefix = '';\r\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\r\n// to be used for Event Object creation.\r\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\r\nfunction getDraggedElMeta(el) {\r\n    var prefix = exportHooks.dataAttrPrefix;\r\n    var eventProps; // properties for creating the event, not related to date/time\r\n    var startTime; // a Duration\r\n    var duration;\r\n    var stick;\r\n    if (prefix) {\r\n        prefix += '-';\r\n    }\r\n    eventProps = el.data(prefix + 'event') || null;\r\n    if (eventProps) {\r\n        if (typeof eventProps === 'object') {\r\n            eventProps = $.extend({}, eventProps); // make a copy\r\n        }\r\n        else {\r\n            eventProps = {};\r\n        }\r\n        // pluck special-cased date/time properties\r\n        startTime = eventProps.start;\r\n        if (startTime == null) {\r\n            startTime = eventProps.time;\r\n        } // accept 'time' as well\r\n        duration = eventProps.duration;\r\n        stick = eventProps.stick;\r\n        delete eventProps.start;\r\n        delete eventProps.time;\r\n        delete eventProps.duration;\r\n        delete eventProps.stick;\r\n    }\r\n    // fallback to standalone attribute values for each of the date/time properties\r\n    if (startTime == null) {\r\n        startTime = el.data(prefix + 'start');\r\n    }\r\n    if (startTime == null) {\r\n        startTime = el.data(prefix + 'time');\r\n    } // accept 'time' as well\r\n    if (duration == null) {\r\n        duration = el.data(prefix + 'duration');\r\n    }\r\n    if (stick == null) {\r\n        stick = el.data(prefix + 'stick');\r\n    }\r\n    // massage into correct data types\r\n    startTime = startTime != null ? moment.duration(startTime) : null;\r\n    duration = duration != null ? moment.duration(duration) : null;\r\n    stick = Boolean(stick);\r\n    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\r\n}\r\n\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventResizing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventResizing, _super);\r\n    /*\r\n    component impements:\r\n      - bindSegHandlerToEl\r\n      - publiclyTrigger\r\n      - diffDates\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n      - getSafeHitFootprint\r\n    */\r\n    function EventResizing(component, eventPointing) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.isResizing = false;\r\n        _this.eventPointing = eventPointing;\r\n        return _this;\r\n    }\r\n    EventResizing.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    EventResizing.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));\r\n        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n    };\r\n    EventResizing.prototype.handleMouseDown = function (seg, ev) {\r\n        if (this.component.canStartResize(seg, ev)) {\r\n            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n                .startInteraction(ev, { distance: 5 });\r\n        }\r\n    };\r\n    EventResizing.prototype.handleTouchStart = function (seg, ev) {\r\n        if (this.component.canStartResize(seg, ev)) {\r\n            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n                .startInteraction(ev);\r\n        }\r\n    };\r\n    // Creates a listener that tracks the user as they resize an event segment.\r\n    // Generic enough to work with any type of Grid.\r\n    EventResizing.prototype.buildDragListener = function (seg, isStart) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var eventManager = calendar.eventManager;\r\n        var el = seg.el;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance;\r\n        var isDragging;\r\n        var resizeMutation; // zoned event date properties. falsy if invalid resize\r\n        // Tracks mouse movement over the *grid's* coordinate map\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            subjectEl: el,\r\n            interactionStart: function () {\r\n                isDragging = false;\r\n            },\r\n            dragStart: function (ev) {\r\n                isDragging = true;\r\n                // ensure a mouseout on the manipulated event has been reported\r\n                _this.eventPointing.handleMouseout(seg, ev);\r\n                _this.segResizeStart(seg, ev);\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var isAllowed = true;\r\n                var origHitFootprint = component.getSafeHitFootprint(origHit);\r\n                var hitFootprint = component.getSafeHitFootprint(hit);\r\n                var mutatedEventInstanceGroup;\r\n                if (origHitFootprint && hitFootprint) {\r\n                    resizeMutation = isStart ?\r\n                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :\r\n                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);\r\n                    if (resizeMutation) {\r\n                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);\r\n                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    resizeMutation = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                else if (resizeMutation.isEmpty()) {\r\n                    // no change. (FYI, event dates might have zones)\r\n                    resizeMutation = null;\r\n                }\r\n                if (resizeMutation) {\r\n                    view.hideEventsWithId(seg.footprint.eventDef.id);\r\n                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                resizeMutation = null;\r\n            },\r\n            hitDone: function () {\r\n                view.unrenderEventResize(seg);\r\n                view.showEventsWithId(seg.footprint.eventDef.id);\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                if (isDragging) {\r\n                    _this.segResizeStop(seg, ev);\r\n                }\r\n                if (resizeMutation) {\r\n                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n                    view.reportEventResize(eventInstance, resizeMutation, el, ev);\r\n                }\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Called before event segment resizing starts\r\n    EventResizing.prototype.segResizeStart = function (seg, ev) {\r\n        this.isResizing = true;\r\n        this.component.publiclyTrigger('eventResizeStart', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Called after event segment resizing stops\r\n    EventResizing.prototype.segResizeStop = function (seg, ev) {\r\n        this.isResizing = false;\r\n        this.component.publiclyTrigger('eventResizeStop', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Returns new date-information for an event segment being resized from its start\r\n    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\r\n        var origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());\r\n        var dateMutation;\r\n        var eventDefMutation;\r\n        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {\r\n            dateMutation = new EventDefDateMutation_1.default();\r\n            dateMutation.setStartDelta(startDelta);\r\n            eventDefMutation = new EventDefMutation_1.default();\r\n            eventDefMutation.setDateMutation(dateMutation);\r\n            return eventDefMutation;\r\n        }\r\n        return false;\r\n    };\r\n    // Returns new date-information for an event segment being resized from its end\r\n    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {\r\n        var origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());\r\n        var dateMutation;\r\n        var eventDefMutation;\r\n        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {\r\n            dateMutation = new EventDefDateMutation_1.default();\r\n            dateMutation.setEndDelta(endDelta);\r\n            eventDefMutation = new EventDefMutation_1.default();\r\n            eventDefMutation.setDateMutation(dateMutation);\r\n            return eventDefMutation;\r\n        }\r\n        return false;\r\n    };\r\n    return EventResizing;\r\n}(Interaction_1.default));\r\nexports.default = EventResizing;\r\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventDefMutation_1 = __webpack_require__(37);\r\nvar EventDefDateMutation_1 = __webpack_require__(50);\r\nvar DragListener_1 = __webpack_require__(54);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar MouseFollower_1 = __webpack_require__(244);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar EventDragging = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EventDragging, _super);\r\n    /*\r\n    component implements:\r\n      - bindSegHandlerToEl\r\n      - publiclyTrigger\r\n      - diffDates\r\n      - eventRangesToEventFootprints\r\n      - isEventInstanceGroupAllowed\r\n    */\r\n    function EventDragging(component, eventPointing) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.isDragging = false;\r\n        _this.eventPointing = eventPointing;\r\n        return _this;\r\n    }\r\n    EventDragging.prototype.end = function () {\r\n        if (this.dragListener) {\r\n            this.dragListener.endInteraction();\r\n        }\r\n    };\r\n    EventDragging.prototype.getSelectionDelay = function () {\r\n        var delay = this.opt('eventLongPressDelay');\r\n        if (delay == null) {\r\n            delay = this.opt('longPressDelay'); // fallback\r\n        }\r\n        return delay;\r\n    };\r\n    EventDragging.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));\r\n        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n    };\r\n    EventDragging.prototype.handleMousedown = function (seg, ev) {\r\n        if (!this.component.shouldIgnoreMouse() &&\r\n            this.component.canStartDrag(seg, ev)) {\r\n            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });\r\n        }\r\n    };\r\n    EventDragging.prototype.handleTouchStart = function (seg, ev) {\r\n        var component = this.component;\r\n        var settings = {\r\n            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?\r\n                0 : this.getSelectionDelay()\r\n        };\r\n        if (component.canStartDrag(seg, ev)) {\r\n            this.buildDragListener(seg).startInteraction(ev, settings);\r\n        }\r\n        else if (component.canStartSelection(seg, ev)) {\r\n            this.buildSelectListener(seg).startInteraction(ev, settings);\r\n        }\r\n    };\r\n    // seg isn't draggable, but let's use a generic DragListener\r\n    // simply for the delay, so it can be selected.\r\n    // Has side effect of setting/unsetting `dragListener`\r\n    EventDragging.prototype.buildSelectListener = function (seg) {\r\n        var _this = this;\r\n        var view = this.view;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n        if (this.dragListener) {\r\n            return this.dragListener;\r\n        }\r\n        var dragListener = this.dragListener = new DragListener_1.default({\r\n            dragStart: function (ev) {\r\n                if (dragListener.isTouch &&\r\n                    !view.isEventDefSelected(eventDef) &&\r\n                    eventInstance) {\r\n                    // if not previously selected, will fire after a delay. then, select the event\r\n                    view.selectEventInstance(eventInstance);\r\n                }\r\n            },\r\n            interactionEnd: function (ev) {\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Builds a listener that will track user-dragging on an event segment.\r\n    // Generic enough to work with any type of Grid.\r\n    // Has side effect of setting/unsetting `dragListener`\r\n    EventDragging.prototype.buildDragListener = function (seg) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var eventManager = calendar.eventManager;\r\n        var el = seg.el;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n        var isDragging;\r\n        var mouseFollower; // A clone of the original element that will move with the mouse\r\n        var eventDefMutation;\r\n        if (this.dragListener) {\r\n            return this.dragListener;\r\n        }\r\n        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\r\n        // of the view.\r\n        var dragListener = this.dragListener = new HitDragListener_1.default(view, {\r\n            scroll: this.opt('dragScroll'),\r\n            subjectEl: el,\r\n            subjectCenter: true,\r\n            interactionStart: function (ev) {\r\n                seg.component = component; // for renderDrag\r\n                isDragging = false;\r\n                mouseFollower = new MouseFollower_1.default(seg.el, {\r\n                    additionalClass: 'fc-dragging',\r\n                    parentEl: view.el,\r\n                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),\r\n                    revertDuration: _this.opt('dragRevertDuration'),\r\n                    zIndex: 2 // one above the .fc-view\r\n                });\r\n                mouseFollower.hide(); // don't show until we know this is a real drag\r\n                mouseFollower.start(ev);\r\n            },\r\n            dragStart: function (ev) {\r\n                if (dragListener.isTouch &&\r\n                    !view.isEventDefSelected(eventDef) &&\r\n                    eventInstance) {\r\n                    // if not previously selected, will fire after a delay. then, select the event\r\n                    view.selectEventInstance(eventInstance);\r\n                }\r\n                isDragging = true;\r\n                // ensure a mouseout on the manipulated event has been reported\r\n                _this.eventPointing.handleMouseout(seg, ev);\r\n                _this.segDragStart(seg, ev);\r\n                view.hideEventsWithId(seg.footprint.eventDef.id);\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var isAllowed = true;\r\n                var origFootprint;\r\n                var footprint;\r\n                var mutatedEventInstanceGroup;\r\n                // starting hit could be forced (DayGrid.limit)\r\n                if (seg.hit) {\r\n                    origHit = seg.hit;\r\n                }\r\n                // hit might not belong to this grid, so query origin grid\r\n                origFootprint = origHit.component.getSafeHitFootprint(origHit);\r\n                footprint = hit.component.getSafeHitFootprint(hit);\r\n                if (origFootprint && footprint) {\r\n                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);\r\n                    if (eventDefMutation) {\r\n                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);\r\n                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n                    }\r\n                    else {\r\n                        isAllowed = false;\r\n                    }\r\n                }\r\n                else {\r\n                    isAllowed = false;\r\n                }\r\n                if (!isAllowed) {\r\n                    eventDefMutation = null;\r\n                    util_1.disableCursor();\r\n                }\r\n                // if a valid drop location, have the subclass render a visual indication\r\n                if (eventDefMutation &&\r\n                    view.renderDrag(// truthy if rendered something\r\n                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {\r\n                    mouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\r\n                }\r\n                else {\r\n                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\r\n                }\r\n                if (isOrig) {\r\n                    // needs to have moved hits to be a valid drop\r\n                    eventDefMutation = null;\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                view.unrenderDrag(seg); // unrender whatever was done in renderDrag\r\n                mouseFollower.show(); // show in case we are moving out of all hits\r\n                eventDefMutation = null;\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev) {\r\n                delete seg.component; // prevent side effects\r\n                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\r\n                mouseFollower.stop(!eventDefMutation, function () {\r\n                    if (isDragging) {\r\n                        view.unrenderDrag(seg);\r\n                        _this.segDragStop(seg, ev);\r\n                    }\r\n                    view.showEventsWithId(seg.footprint.eventDef.id);\r\n                    if (eventDefMutation) {\r\n                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);\r\n                    }\r\n                });\r\n                _this.dragListener = null;\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Called before event segment dragging starts\r\n    EventDragging.prototype.segDragStart = function (seg, ev) {\r\n        this.isDragging = true;\r\n        this.component.publiclyTrigger('eventDragStart', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // Called after event segment dragging stops\r\n    EventDragging.prototype.segDragStop = function (seg, ev) {\r\n        this.isDragging = false;\r\n        this.component.publiclyTrigger('eventDragStop', {\r\n            context: seg.el[0],\r\n            args: [\r\n                seg.footprint.getEventLegacy(),\r\n                ev,\r\n                {},\r\n                this.view\r\n            ]\r\n        });\r\n    };\r\n    // DOES NOT consider overlap/constraint\r\n    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {\r\n        var eventDefMutation = new EventDefMutation_1.default();\r\n        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));\r\n        return eventDefMutation;\r\n    };\r\n    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {\r\n        var date0 = startFootprint.unzonedRange.getStart();\r\n        var date1 = endFootprint.unzonedRange.getStart();\r\n        var clearEnd = false;\r\n        var forceTimed = false;\r\n        var forceAllDay = false;\r\n        var dateDelta;\r\n        var dateMutation;\r\n        if (startFootprint.isAllDay !== endFootprint.isAllDay) {\r\n            clearEnd = true;\r\n            if (endFootprint.isAllDay) {\r\n                forceAllDay = true;\r\n                date0.stripTime();\r\n            }\r\n            else {\r\n                forceTimed = true;\r\n            }\r\n        }\r\n        dateDelta = this.component.diffDates(date1, date0);\r\n        dateMutation = new EventDefDateMutation_1.default();\r\n        dateMutation.clearEnd = clearEnd;\r\n        dateMutation.forceTimed = forceTimed;\r\n        dateMutation.forceAllDay = forceAllDay;\r\n        dateMutation.setDateDelta(dateDelta);\r\n        return dateMutation;\r\n    };\r\n    return EventDragging;\r\n}(Interaction_1.default));\r\nexports.default = EventDragging;\r\n\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar DateSelecting = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateSelecting, _super);\r\n    /*\r\n    component must implement:\r\n      - bindDateHandlerToEl\r\n      - getSafeHitFootprint\r\n      - renderHighlight\r\n      - unrenderHighlight\r\n    */\r\n    function DateSelecting(component) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.dragListener = _this.buildDragListener();\r\n        return _this;\r\n    }\r\n    DateSelecting.prototype.end = function () {\r\n        this.dragListener.endInteraction();\r\n    };\r\n    DateSelecting.prototype.getDelay = function () {\r\n        var delay = this.opt('selectLongPressDelay');\r\n        if (delay == null) {\r\n            delay = this.opt('longPressDelay'); // fallback\r\n        }\r\n        return delay;\r\n    };\r\n    DateSelecting.prototype.bindToEl = function (el) {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var dragListener = this.dragListener;\r\n        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\r\n            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {\r\n                dragListener.startInteraction(ev, {\r\n                    distance: _this.opt('selectMinDistance')\r\n                });\r\n            }\r\n        });\r\n        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\r\n            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {\r\n                dragListener.startInteraction(ev, {\r\n                    delay: _this.getDelay()\r\n                });\r\n            }\r\n        });\r\n        util_1.preventSelection(el);\r\n    };\r\n    // Creates a listener that tracks the user's drag across day elements, for day selecting.\r\n    DateSelecting.prototype.buildDragListener = function () {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var selectionFootprint; // null if invalid selection\r\n        var dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            interactionStart: function () {\r\n                selectionFootprint = null;\r\n            },\r\n            dragStart: function (ev) {\r\n                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                var origHitFootprint;\r\n                var hitFootprint;\r\n                if (origHit) {\r\n                    origHitFootprint = component.getSafeHitFootprint(origHit);\r\n                    hitFootprint = component.getSafeHitFootprint(hit);\r\n                    if (origHitFootprint && hitFootprint) {\r\n                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);\r\n                    }\r\n                    else {\r\n                        selectionFootprint = null;\r\n                    }\r\n                    if (selectionFootprint) {\r\n                        component.renderSelectionFootprint(selectionFootprint);\r\n                    }\r\n                    else if (selectionFootprint === false) {\r\n                        util_1.disableCursor();\r\n                    }\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                selectionFootprint = null;\r\n                component.unrenderSelection();\r\n            },\r\n            hitDone: function () {\r\n                util_1.enableCursor();\r\n            },\r\n            interactionEnd: function (ev, isCancelled) {\r\n                if (!isCancelled && selectionFootprint) {\r\n                    // the selection will already have been rendered. just report it\r\n                    _this.view.reportSelection(selectionFootprint, ev);\r\n                }\r\n            }\r\n        });\r\n        return dragListener;\r\n    };\r\n    // Given the first and last date-spans of a selection, returns another date-span object.\r\n    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().\r\n    // Will return false if the selection is invalid and this should be indicated to the user.\r\n    // Will return null/undefined if a selection invalid but no error should be reported.\r\n    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {\r\n        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);\r\n        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {\r\n            return false;\r\n        }\r\n        return wholeFootprint;\r\n    };\r\n    // Given two spans, must return the combination of the two.\r\n    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\r\n    // Assumes both footprints are non-open-ended.\r\n    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {\r\n        var ms = [\r\n            footprint0.unzonedRange.startMs,\r\n            footprint0.unzonedRange.endMs,\r\n            footprint1.unzonedRange.startMs,\r\n            footprint1.unzonedRange.endMs\r\n        ];\r\n        ms.sort(util_1.compareNumbers);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);\r\n    };\r\n    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {\r\n        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&\r\n            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);\r\n    };\r\n    return DateSelecting;\r\n}(Interaction_1.default));\r\nexports.default = DateSelecting;\r\n\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar View_1 = __webpack_require__(41);\r\nvar TimeGrid_1 = __webpack_require__(227);\r\nvar DayGrid_1 = __webpack_require__(61);\r\nvar AGENDA_ALL_DAY_EVENT_LIMIT = 5;\r\nvar agendaTimeGridMethods;\r\nvar agendaDayGridMethods;\r\n/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\r\n// Responsible for managing width/height.\r\nvar AgendaView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AgendaView, _super);\r\n    function AgendaView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering\r\n        _this.timeGrid = _this.instantiateTimeGrid();\r\n        _this.addChild(_this.timeGrid);\r\n        if (_this.opt('allDaySlot')) {\r\n            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view\r\n            _this.addChild(_this.dayGrid);\r\n        }\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\r\n    AgendaView.prototype.instantiateTimeGrid = function () {\r\n        var timeGrid = new this.timeGridClass(this);\r\n        util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);\r\n        return timeGrid;\r\n    };\r\n    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\r\n    AgendaView.prototype.instantiateDayGrid = function () {\r\n        var dayGrid = new this.dayGridClass(this);\r\n        util_1.copyOwnProps(agendaDayGridMethods, dayGrid);\r\n        return dayGrid;\r\n    };\r\n    /* Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.renderSkeleton = function () {\r\n        var timeGridWrapEl;\r\n        var timeGridEl;\r\n        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\r\n        this.scroller.render();\r\n        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\r\n        timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\r\n        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);\r\n        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');\r\n        this.timeGrid.setElement(timeGridEl);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.setElement(this.el.find('.fc-day-grid'));\r\n            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\r\n            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\r\n        }\r\n    };\r\n    AgendaView.prototype.unrenderSkeleton = function () {\r\n        this.timeGrid.removeElement();\r\n        if (this.dayGrid) {\r\n            this.dayGrid.removeElement();\r\n        }\r\n        this.scroller.destroy();\r\n    };\r\n    // Builds the HTML skeleton for the view.\r\n    // The day-grid and time-grid components will render inside containers defined by this HTML.\r\n    AgendaView.prototype.renderSkeletonHtml = function () {\r\n        var theme = this.calendar.theme;\r\n        return '' +\r\n            '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            (this.opt('columnHeader') ?\r\n                '<thead class=\"fc-head\">' +\r\n                    '<tr>' +\r\n                    '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n                    '</tr>' +\r\n                    '</thead>' :\r\n                '') +\r\n            '<tbody class=\"fc-body\">' +\r\n            '<tr>' +\r\n            '<td class=\"' + theme.getClass('widgetContent') + '\">' +\r\n            (this.dayGrid ?\r\n                '<div class=\"fc-day-grid\"/>' +\r\n                    '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\"/>' :\r\n                '') +\r\n            '</td>' +\r\n            '</tr>' +\r\n            '</tbody>' +\r\n            '</table>';\r\n    };\r\n    // Generates an HTML attribute string for setting the width of the axis, if it is known\r\n    AgendaView.prototype.axisStyleAttr = function () {\r\n        if (this.axisWidth != null) {\r\n            return 'style=\"width:' + this.axisWidth + 'px\"';\r\n        }\r\n        return '';\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.getNowIndicatorUnit = function () {\r\n        return this.timeGrid.getNowIndicatorUnit();\r\n    };\r\n    /* Dimensions\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Adjusts the vertical dimensions of the view to the specified values\r\n    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        var eventLimit;\r\n        var scrollerHeight;\r\n        var scrollbarWidths;\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        // make all axis cells line up, and record the width so newly created axis cells will have it\r\n        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));\r\n        // hack to give the view some height prior to timeGrid's columns being rendered\r\n        // TODO: separate setting height from scroller VS timeGrid.\r\n        if (!this.timeGrid.colEls) {\r\n            if (!isAuto) {\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            return;\r\n        }\r\n        // set of fake row elements that must compensate when scroller has scrollbars\r\n        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');\r\n        // reset all dimensions back to the original state\r\n        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\r\n        this.scroller.clear(); // sets height to 'auto' and clears overflow\r\n        util_1.uncompensateScroll(noScrollRowEls);\r\n        // limit number of events in the all-day area\r\n        if (this.dayGrid) {\r\n            this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n            eventLimit = this.opt('eventLimit');\r\n            if (eventLimit && typeof eventLimit !== 'number') {\r\n                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\r\n            }\r\n            if (eventLimit) {\r\n                this.dayGrid.limitRows(eventLimit);\r\n            }\r\n        }\r\n        if (!isAuto) {\r\n            scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n            this.scroller.setHeight(scrollerHeight);\r\n            scrollbarWidths = this.scroller.getScrollbarWidths();\r\n            if (scrollbarWidths.left || scrollbarWidths.right) {\r\n                // make the all-day and header rows lines up\r\n                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);\r\n                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\r\n                // and reapply the desired height to the scroller.\r\n                scrollerHeight = this.computeScrollerHeight(totalHeight);\r\n                this.scroller.setHeight(scrollerHeight);\r\n            }\r\n            // guarantees the same scrollbar widths\r\n            this.scroller.lockOverflow(scrollbarWidths);\r\n            // if there's any space below the slats, show the horizontal rule.\r\n            // this won't cause any new overflow, because lockOverflow already called.\r\n            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\r\n                this.timeGrid.bottomRuleEl.show();\r\n            }\r\n        }\r\n    };\r\n    // given a desired total height of the view, returns what the height of the scroller should be\r\n    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    /* Scroll\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Computes the initial pre-configured scroll state prior to allowing the user to change it\r\n    AgendaView.prototype.computeInitialDateScroll = function () {\r\n        var scrollTime = moment.duration(this.opt('scrollTime'));\r\n        var top = this.timeGrid.computeTimeTop(scrollTime);\r\n        // zoom can give weird floating-point values. rather scroll a little bit further\r\n        top = Math.ceil(top);\r\n        if (top) {\r\n            top++; // to overcome top border that slots beyond the first have. looks better\r\n        }\r\n        return { top: top };\r\n    };\r\n    AgendaView.prototype.queryDateScroll = function () {\r\n        return { top: this.scroller.getScrollTop() };\r\n    };\r\n    AgendaView.prototype.applyDateScroll = function (scroll) {\r\n        if (scroll.top !== undefined) {\r\n            this.scroller.setScrollTop(scroll.top);\r\n        }\r\n    };\r\n    /* Hit Areas\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // forward all hit-related method calls to the grids (dayGrid might not be defined)\r\n    AgendaView.prototype.getHitFootprint = function (hit) {\r\n        // TODO: hit.component is set as a hack to identify where the hit came from\r\n        return hit.component.getHitFootprint(hit);\r\n    };\r\n    AgendaView.prototype.getHitEl = function (hit) {\r\n        // TODO: hit.component is set as a hack to identify where the hit came from\r\n        return hit.component.getHitEl(hit);\r\n    };\r\n    /* Event Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    AgendaView.prototype.executeEventRender = function (eventsPayload) {\r\n        var dayEventsPayload = {};\r\n        var timedEventsPayload = {};\r\n        var id;\r\n        var eventInstanceGroup;\r\n        // separate the events into all-day and timed\r\n        for (id in eventsPayload) {\r\n            eventInstanceGroup = eventsPayload[id];\r\n            if (eventInstanceGroup.getEventDef().isAllDay()) {\r\n                dayEventsPayload[id] = eventInstanceGroup;\r\n            }\r\n            else {\r\n                timedEventsPayload[id] = eventInstanceGroup;\r\n            }\r\n        }\r\n        this.timeGrid.executeEventRender(timedEventsPayload);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.executeEventRender(dayEventsPayload);\r\n        }\r\n    };\r\n    /* Dragging/Resizing Routing\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var groups = groupEventFootprintsByAllDay(eventFootprints);\r\n        var renderedHelper = false;\r\n        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);\r\n        if (this.dayGrid) {\r\n            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;\r\n        }\r\n        return renderedHelper;\r\n    };\r\n    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        var groups = groupEventFootprintsByAllDay(eventFootprints);\r\n        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);\r\n        if (this.dayGrid) {\r\n            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);\r\n        }\r\n    };\r\n    /* Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of a selection\r\n    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        if (!componentFootprint.isAllDay) {\r\n            this.timeGrid.renderSelectionFootprint(componentFootprint);\r\n        }\r\n        else if (this.dayGrid) {\r\n            this.dayGrid.renderSelectionFootprint(componentFootprint);\r\n        }\r\n    };\r\n    return AgendaView;\r\n}(View_1.default));\r\nexports.default = AgendaView;\r\nAgendaView.prototype.timeGridClass = TimeGrid_1.default;\r\nAgendaView.prototype.dayGridClass = DayGrid_1.default;\r\n// Will customize the rendering behavior of the AgendaView's timeGrid\r\nagendaTimeGridMethods = {\r\n    // Generates the HTML that will go before the day-of week header cells\r\n    renderHeadIntroHtml: function () {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);\r\n        var weekText;\r\n        if (this.opt('weekNumbers')) {\r\n            weekText = weekStart.format(this.opt('smallWeekFormat'));\r\n            return '' +\r\n                '<th class=\"fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '>' +\r\n                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths\r\n                { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML\r\n                ) +\r\n                '</th>';\r\n        }\r\n        else {\r\n            return '<th class=\"fc-axis ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '></th>';\r\n        }\r\n    },\r\n    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\r\n    renderBgIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '></td>';\r\n    },\r\n    // Generates the HTML that goes before all other types of cells.\r\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n    renderIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n    }\r\n};\r\n// Will customize the rendering behavior of the AgendaView's dayGrid\r\nagendaDayGridMethods = {\r\n    // Generates the HTML that goes before the all-day cells\r\n    renderBgIntroHtml: function () {\r\n        var view = this.view;\r\n        return '' +\r\n            '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n            '<span>' + // needed for matchCellWidths\r\n            view.getAllDayHtml() +\r\n            '</span>' +\r\n            '</td>';\r\n    },\r\n    // Generates the HTML that goes before all other types of cells.\r\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n    renderIntroHtml: function () {\r\n        var view = this.view;\r\n        return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n    }\r\n};\r\nfunction groupEventFootprintsByAllDay(eventFootprints) {\r\n    var allDay = [];\r\n    var timed = [];\r\n    var i;\r\n    for (i = 0; i < eventFootprints.length; i++) {\r\n        if (eventFootprints[i].componentFootprint.isAllDay) {\r\n            allDay.push(eventFootprints[i]);\r\n        }\r\n        else {\r\n            timed.push(eventFootprints[i]);\r\n        }\r\n    }\r\n    return { allDay: allDay, timed: timed };\r\n}\r\n\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar InteractiveDateComponent_1 = __webpack_require__(40);\r\nvar BusinessHourRenderer_1 = __webpack_require__(56);\r\nvar StandardInteractionsMixin_1 = __webpack_require__(60);\r\nvar DayTableMixin_1 = __webpack_require__(55);\r\nvar CoordCache_1 = __webpack_require__(53);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar ComponentFootprint_1 = __webpack_require__(12);\r\nvar TimeGridEventRenderer_1 = __webpack_require__(246);\r\nvar TimeGridHelperRenderer_1 = __webpack_require__(247);\r\nvar TimeGridFillRenderer_1 = __webpack_require__(248);\r\n/* A component that renders one or more columns of vertical time slots\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// We mixin DayTable, even though there is only a single row of days\r\n// potential nice values for the slot-duration and interval-duration\r\n// from largest to smallest\r\nvar AGENDA_STOCK_SUB_DURATIONS = [\r\n    { hours: 1 },\r\n    { minutes: 30 },\r\n    { minutes: 15 },\r\n    { seconds: 30 },\r\n    { seconds: 15 }\r\n];\r\nvar TimeGrid = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGrid, _super);\r\n    function TimeGrid(view) {\r\n        var _this = _super.call(this, view) || this;\r\n        _this.processOptions();\r\n        return _this;\r\n    }\r\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {\r\n        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);\r\n        var i;\r\n        for (i = 0; i < segs.length; i++) {\r\n            if (this.isRTL) {\r\n                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\r\n            }\r\n            else {\r\n                segs[i].col = segs[i].dayIndex;\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Date Handling\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {\r\n        var segs = [];\r\n        var segRange;\r\n        var dayIndex;\r\n        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\r\n            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);\r\n            if (segRange) {\r\n                segs.push({\r\n                    startMs: segRange.startMs,\r\n                    endMs: segRange.endMs,\r\n                    isStart: segRange.isStart,\r\n                    isEnd: segRange.isEnd,\r\n                    dayIndex: dayIndex\r\n                });\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    /* Options\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Parses various options into properties of this object\r\n    TimeGrid.prototype.processOptions = function () {\r\n        var slotDuration = this.opt('slotDuration');\r\n        var snapDuration = this.opt('snapDuration');\r\n        var input;\r\n        slotDuration = moment.duration(slotDuration);\r\n        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\r\n        this.slotDuration = slotDuration;\r\n        this.snapDuration = snapDuration;\r\n        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\r\n        // might be an array value (for TimelineView).\r\n        // if so, getting the most granular entry (the last one probably).\r\n        input = this.opt('slotLabelFormat');\r\n        if ($.isArray(input)) {\r\n            input = input[input.length - 1];\r\n        }\r\n        this.labelFormat = input ||\r\n            this.opt('smallTimeFormat'); // the computed default\r\n        input = this.opt('slotLabelInterval');\r\n        this.labelInterval = input ?\r\n            moment.duration(input) :\r\n            this.computeLabelInterval(slotDuration);\r\n    };\r\n    // Computes an automatic value for slotLabelInterval\r\n    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {\r\n        var i;\r\n        var labelInterval;\r\n        var slotsPerLabel;\r\n        // find the smallest stock label interval that results in more than one slots-per-label\r\n        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\r\n            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\r\n            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);\r\n            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {\r\n                return labelInterval;\r\n            }\r\n        }\r\n        return moment.duration(slotDuration); // fall back. clone\r\n    };\r\n    /* Date Rendering\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.renderDates = function (dateProfile) {\r\n        this.dateProfile = dateProfile;\r\n        this.updateDayTable();\r\n        this.renderSlats();\r\n        this.renderColumns();\r\n    };\r\n    TimeGrid.prototype.unrenderDates = function () {\r\n        // this.unrenderSlats(); // don't need this because repeated .html() calls clear\r\n        this.unrenderColumns();\r\n    };\r\n    TimeGrid.prototype.renderSkeleton = function () {\r\n        var theme = this.view.calendar.theme;\r\n        this.el.html('<div class=\"fc-bg\"></div>' +\r\n            '<div class=\"fc-slats\"></div>' +\r\n            '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" style=\"display:none\" />');\r\n        this.bottomRuleEl = this.el.find('hr');\r\n    };\r\n    TimeGrid.prototype.renderSlats = function () {\r\n        var theme = this.view.calendar.theme;\r\n        this.slatContainerEl = this.el.find('> .fc-slats')\r\n            .html(// avoids needing ::unrenderSlats()\r\n        '<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderSlatRowHtml() +\r\n            '</table>');\r\n        this.slatEls = this.slatContainerEl.find('tr');\r\n        this.slatCoordCache = new CoordCache_1.default({\r\n            els: this.slatEls,\r\n            isVertical: true\r\n        });\r\n    };\r\n    // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\r\n    TimeGrid.prototype.renderSlatRowHtml = function () {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var theme = calendar.theme;\r\n        var isRTL = this.isRTL;\r\n        var dateProfile = this.dateProfile;\r\n        var html = '';\r\n        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations\r\n        var slotIterator = moment.duration(0);\r\n        var slotDate; // will be on the view's first day, but we only care about its time\r\n        var isLabeled;\r\n        var axisHtml;\r\n        // Calculate the time for each slot\r\n        while (slotTime < dateProfile.maxTime) {\r\n            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);\r\n            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));\r\n            axisHtml =\r\n                '<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n                    (isLabeled ?\r\n                        '<span>' + // for matchCellWidths\r\n                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +\r\n                            '</span>' :\r\n                        '') +\r\n                    '</td>';\r\n            html +=\r\n                '<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\r\n                    (isLabeled ? '' : ' class=\"fc-minor\"') +\r\n                    '>' +\r\n                    (!isRTL ? axisHtml : '') +\r\n                    '<td class=\"' + theme.getClass('widgetContent') + '\"/>' +\r\n                    (isRTL ? axisHtml : '') +\r\n                    '</tr>';\r\n            slotTime.add(this.slotDuration);\r\n            slotIterator.add(this.slotDuration);\r\n        }\r\n        return html;\r\n    };\r\n    TimeGrid.prototype.renderColumns = function () {\r\n        var dateProfile = this.dateProfile;\r\n        var theme = this.view.calendar.theme;\r\n        this.dayRanges = this.dayDates.map(function (dayDate) {\r\n            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));\r\n        });\r\n        if (this.headContainerEl) {\r\n            this.headContainerEl.html(this.renderHeadHtml());\r\n        }\r\n        this.el.find('> .fc-bg').html('<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n            this.renderBgTrHtml(0) + // row=0\r\n            '</table>');\r\n        this.colEls = this.el.find('.fc-day, .fc-disabled-day');\r\n        this.colCoordCache = new CoordCache_1.default({\r\n            els: this.colEls,\r\n            isHorizontal: true\r\n        });\r\n        this.renderContentSkeleton();\r\n    };\r\n    TimeGrid.prototype.unrenderColumns = function () {\r\n        this.unrenderContentSkeleton();\r\n    };\r\n    /* Content Skeleton\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders the DOM that the view's content will live in\r\n    TimeGrid.prototype.renderContentSkeleton = function () {\r\n        var cellHtml = '';\r\n        var i;\r\n        var skeletonEl;\r\n        for (i = 0; i < this.colCnt; i++) {\r\n            cellHtml +=\r\n                '<td>' +\r\n                    '<div class=\"fc-content-col\">' +\r\n                    '<div class=\"fc-event-container fc-helper-container\"></div>' +\r\n                    '<div class=\"fc-event-container\"></div>' +\r\n                    '<div class=\"fc-highlight-container\"></div>' +\r\n                    '<div class=\"fc-bgevent-container\"></div>' +\r\n                    '<div class=\"fc-business-container\"></div>' +\r\n                    '</div>' +\r\n                    '</td>';\r\n        }\r\n        skeletonEl = this.contentSkeletonEl = $('<div class=\"fc-content-skeleton\">' +\r\n            '<table>' +\r\n            '<tr>' + cellHtml + '</tr>' +\r\n            '</table>' +\r\n            '</div>');\r\n        this.colContainerEls = skeletonEl.find('.fc-content-col');\r\n        this.helperContainerEls = skeletonEl.find('.fc-helper-container');\r\n        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\r\n        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\r\n        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\r\n        this.businessContainerEls = skeletonEl.find('.fc-business-container');\r\n        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\r\n        this.el.append(skeletonEl);\r\n    };\r\n    TimeGrid.prototype.unrenderContentSkeleton = function () {\r\n        if (this.contentSkeletonEl) {\r\n            this.contentSkeletonEl.remove();\r\n            this.contentSkeletonEl = null;\r\n            this.colContainerEls = null;\r\n            this.helperContainerEls = null;\r\n            this.fgContainerEls = null;\r\n            this.bgContainerEls = null;\r\n            this.highlightContainerEls = null;\r\n            this.businessContainerEls = null;\r\n        }\r\n    };\r\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\r\n    TimeGrid.prototype.groupSegsByCol = function (segs) {\r\n        var segsByCol = [];\r\n        var i;\r\n        for (i = 0; i < this.colCnt; i++) {\r\n            segsByCol.push([]);\r\n        }\r\n        for (i = 0; i < segs.length; i++) {\r\n            segsByCol[segs[i].col].push(segs[i]);\r\n        }\r\n        return segsByCol;\r\n    };\r\n    // Given segments grouped by column, insert the segments' elements into a parallel array of container\r\n    // elements, each living within a column.\r\n    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {\r\n        var col;\r\n        var segs;\r\n        var i;\r\n        for (col = 0; col < this.colCnt; col++) {\r\n            segs = segsByCol[col];\r\n            for (i = 0; i < segs.length; i++) {\r\n                containerEls.eq(col).append(segs[i].el);\r\n            }\r\n        }\r\n    };\r\n    /* Now Indicator\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.getNowIndicatorUnit = function () {\r\n        return 'minute'; // will refresh on the minute\r\n    };\r\n    TimeGrid.prototype.renderNowIndicator = function (date) {\r\n        // HACK: if date columns not ready for some reason (scheduler)\r\n        if (!this.colContainerEls) {\r\n            return;\r\n        }\r\n        // seg system might be overkill, but it handles scenario where line needs to be rendered\r\n        //  more than once because of columns with the same date (resources columns for example)\r\n        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range\r\n        false // all-day\r\n        ));\r\n        var top = this.computeDateTop(date, date);\r\n        var nodes = [];\r\n        var i;\r\n        // render lines within the columns\r\n        for (i = 0; i < segs.length; i++) {\r\n            nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\r\n                .css('top', top)\r\n                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);\r\n        }\r\n        // render an arrow over the axis\r\n        if (segs.length > 0) {\r\n            nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\r\n                .css('top', top)\r\n                .appendTo(this.el.find('.fc-content-skeleton'))[0]);\r\n        }\r\n        this.nowIndicatorEls = $(nodes);\r\n    };\r\n    TimeGrid.prototype.unrenderNowIndicator = function () {\r\n        if (this.nowIndicatorEls) {\r\n            this.nowIndicatorEls.remove();\r\n            this.nowIndicatorEls = null;\r\n        }\r\n    };\r\n    /* Coordinates\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        this.slatCoordCache.build();\r\n        if (isResize) {\r\n            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));\r\n        }\r\n    };\r\n    TimeGrid.prototype.getTotalSlatHeight = function () {\r\n        return this.slatContainerEl.outerHeight();\r\n    };\r\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\r\n    // `ms` can be a millisecond UTC time OR a UTC moment.\r\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\r\n    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {\r\n        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));\r\n    };\r\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\r\n    TimeGrid.prototype.computeTimeTop = function (time) {\r\n        var len = this.slatEls.length;\r\n        var dateProfile = this.dateProfile;\r\n        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered\r\n        var slatIndex;\r\n        var slatRemainder;\r\n        // compute a floating-point number for how many slats should be progressed through.\r\n        // from 0 to number of slats (inclusive)\r\n        // constrained because minTime/maxTime might be customized.\r\n        slatCoverage = Math.max(0, slatCoverage);\r\n        slatCoverage = Math.min(len, slatCoverage);\r\n        // an integer index of the furthest whole slat\r\n        // from 0 to number slats (*exclusive*, so len-1)\r\n        slatIndex = Math.floor(slatCoverage);\r\n        slatIndex = Math.min(slatIndex, len - 1);\r\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\r\n        // could be 1.0 if slatCoverage is covering *all* the slots\r\n        slatRemainder = slatCoverage - slatIndex;\r\n        return this.slatCoordCache.getTopPosition(slatIndex) +\r\n            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;\r\n    };\r\n    // Refreshes the CSS top/bottom coordinates for each segment element.\r\n    // Works when called after initial render, after a window resize/zoom for example.\r\n    TimeGrid.prototype.updateSegVerticals = function (segs) {\r\n        this.computeSegVerticals(segs);\r\n        this.assignSegVerticals(segs);\r\n    };\r\n    // For each segment in an array, computes and assigns its top and bottom properties\r\n    TimeGrid.prototype.computeSegVerticals = function (segs) {\r\n        var eventMinHeight = this.opt('agendaEventMinHeight');\r\n        var i;\r\n        var seg;\r\n        var dayDate;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            dayDate = this.dayDates[seg.dayIndex];\r\n            seg.top = this.computeDateTop(seg.startMs, dayDate);\r\n            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));\r\n        }\r\n    };\r\n    // Given segments that already have their top/bottom properties computed, applies those values to\r\n    // the segments' elements.\r\n    TimeGrid.prototype.assignSegVerticals = function (segs) {\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            seg.el.css(this.generateSegVerticalCss(seg));\r\n        }\r\n    };\r\n    // Generates an object with CSS properties for the top/bottom coordinates of a segment element\r\n    TimeGrid.prototype.generateSegVerticalCss = function (seg) {\r\n        return {\r\n            top: seg.top,\r\n            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\r\n        };\r\n    };\r\n    /* Hit System\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    TimeGrid.prototype.prepareHits = function () {\r\n        this.colCoordCache.build();\r\n        this.slatCoordCache.build();\r\n    };\r\n    TimeGrid.prototype.releaseHits = function () {\r\n        this.colCoordCache.clear();\r\n        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\r\n    };\r\n    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {\r\n        var snapsPerSlot = this.snapsPerSlot;\r\n        var colCoordCache = this.colCoordCache;\r\n        var slatCoordCache = this.slatCoordCache;\r\n        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\r\n            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);\r\n            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);\r\n            if (colIndex != null && slatIndex != null) {\r\n                var slatTop = slatCoordCache.getTopOffset(slatIndex);\r\n                var slatHeight = slatCoordCache.getHeight(slatIndex);\r\n                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\r\n                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\r\n                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\r\n                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\r\n                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\r\n                return {\r\n                    col: colIndex,\r\n                    snap: snapIndex,\r\n                    component: this,\r\n                    left: colCoordCache.getLeftOffset(colIndex),\r\n                    right: colCoordCache.getRightOffset(colIndex),\r\n                    top: snapTop,\r\n                    bottom: snapBottom\r\n                };\r\n            }\r\n        }\r\n    };\r\n    TimeGrid.prototype.getHitFootprint = function (hit) {\r\n        var start = this.getCellDate(0, hit.col); // row=0\r\n        var time = this.computeSnapTime(hit.snap); // pass in the snap-index\r\n        var end;\r\n        start.time(time);\r\n        end = start.clone().add(this.snapDuration);\r\n        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?\r\n        );\r\n    };\r\n    // Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\r\n    TimeGrid.prototype.computeSnapTime = function (snapIndex) {\r\n        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);\r\n    };\r\n    TimeGrid.prototype.getHitEl = function (hit) {\r\n        return this.colEls.eq(hit.col);\r\n    };\r\n    /* Event Drag Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being dragged over the specified date(s).\r\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {\r\n        var i;\r\n        if (seg) {\r\n            if (eventFootprints.length) {\r\n                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n                // signal that a helper has been rendered\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0; i < eventFootprints.length; i++) {\r\n                this.renderHighlight(eventFootprints[i].componentFootprint);\r\n            }\r\n        }\r\n    };\r\n    // Unrenders any visual indication of an event being dragged\r\n    TimeGrid.prototype.unrenderDrag = function () {\r\n        this.unrenderHighlight();\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Event Resize Visualization\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of an event being resized\r\n    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {\r\n        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n    };\r\n    // Unrenders any visual indication of an event being resized\r\n    TimeGrid.prototype.unrenderEventResize = function () {\r\n        this.helperRenderer.unrender();\r\n    };\r\n    /* Selection\r\n    ------------------------------------------------------------------------------------------------------------------*/\r\n    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\r\n    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {\r\n        if (this.opt('selectHelper')) {\r\n            this.helperRenderer.renderComponentFootprint(componentFootprint);\r\n        }\r\n        else {\r\n            this.renderHighlight(componentFootprint);\r\n        }\r\n    };\r\n    // Unrenders any visual indication of a selection\r\n    TimeGrid.prototype.unrenderSelection = function () {\r\n        this.helperRenderer.unrender();\r\n        this.unrenderHighlight();\r\n    };\r\n    return TimeGrid;\r\n}(InteractiveDateComponent_1.default));\r\nexports.default = TimeGrid;\r\nTimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;\r\nTimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;\r\nTimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;\r\nTimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;\r\nStandardInteractionsMixin_1.default.mixInto(TimeGrid);\r\nDayTableMixin_1.default.mixInto(TimeGrid);\r\n\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar DateProfileGenerator_1 = __webpack_require__(221);\r\nvar BasicViewDateProfileGenerator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BasicViewDateProfileGenerator, _super);\r\n    function BasicViewDateProfileGenerator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Computes the date range that will be rendered.\r\n    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange\r\n        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n        // year and month views should be aligned with weeks. this is already done for week\r\n        if (/^(year|month)$/.test(currentRangeUnit)) {\r\n            start.startOf('week');\r\n            // make end-of-week if not already\r\n            if (end.weekday()) {\r\n                end.add(1, 'week').startOf('week'); // exclusively move backwards\r\n            }\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    return BasicViewDateProfileGenerator;\r\n}(DateProfileGenerator_1.default));\r\nexports.default = BasicViewDateProfileGenerator;\r\n\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar moment = __webpack_require__(0);\r\nvar util_1 = __webpack_require__(4);\r\nvar BasicView_1 = __webpack_require__(62);\r\nvar MonthViewDateProfileGenerator_1 = __webpack_require__(253);\r\n/* A month view with day cells running in rows (one-per-week) and columns\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar MonthView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MonthView, _super);\r\n    function MonthView() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Overrides the default BasicView behavior to have special multi-week auto-height logic\r\n    MonthView.prototype.setGridHeight = function (height, isAuto) {\r\n        // if auto, make the height of each row the height that it would be if there were 6 weeks\r\n        if (isAuto) {\r\n            height *= this.dayGrid.rowCnt / 6;\r\n        }\r\n        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\r\n    };\r\n    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {\r\n        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize\r\n    };\r\n    return MonthView;\r\n}(BasicView_1.default));\r\nexports.default = MonthView;\r\nMonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator_1.default;\r\n\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar View_1 = __webpack_require__(41);\r\nvar Scroller_1 = __webpack_require__(39);\r\nvar ListEventRenderer_1 = __webpack_require__(254);\r\nvar ListEventPointing_1 = __webpack_require__(255);\r\n/*\r\nResponsible for the scroller, and forwarding event-related actions into the \"grid\".\r\n*/\r\nvar ListView = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListView, _super);\r\n    function ListView(calendar, viewSpec) {\r\n        var _this = _super.call(this, calendar, viewSpec) || this;\r\n        _this.segSelector = '.fc-list-item'; // which elements accept event actions\r\n        _this.scroller = new Scroller_1.default({\r\n            overflowX: 'hidden',\r\n            overflowY: 'auto'\r\n        });\r\n        return _this;\r\n    }\r\n    ListView.prototype.renderSkeleton = function () {\r\n        this.el.addClass('fc-list-view ' +\r\n            this.calendar.theme.getClass('listView'));\r\n        this.scroller.render();\r\n        this.scroller.el.appendTo(this.el);\r\n        this.contentEl = this.scroller.scrollEl; // shortcut\r\n    };\r\n    ListView.prototype.unrenderSkeleton = function () {\r\n        this.scroller.destroy(); // will remove the Grid too\r\n    };\r\n    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {\r\n        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);\r\n        this.scroller.clear(); // sets height to 'auto' and clears overflow\r\n        if (!isAuto) {\r\n            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));\r\n        }\r\n    };\r\n    ListView.prototype.computeScrollerHeight = function (totalHeight) {\r\n        return totalHeight -\r\n            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n    };\r\n    ListView.prototype.renderDates = function (dateProfile) {\r\n        var calendar = this.calendar;\r\n        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);\r\n        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);\r\n        var dayDates = [];\r\n        var dayRanges = [];\r\n        while (dayStart < viewEnd) {\r\n            dayDates.push(dayStart.clone());\r\n            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));\r\n            dayStart.add(1, 'day');\r\n        }\r\n        this.dayDates = dayDates;\r\n        this.dayRanges = dayRanges;\r\n        // all real rendering happens in EventRenderer\r\n    };\r\n    // slices by day\r\n    ListView.prototype.componentFootprintToSegs = function (footprint) {\r\n        var dayRanges = this.dayRanges;\r\n        var dayIndex;\r\n        var segRange;\r\n        var seg;\r\n        var segs = [];\r\n        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {\r\n            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);\r\n            if (segRange) {\r\n                seg = {\r\n                    startMs: segRange.startMs,\r\n                    endMs: segRange.endMs,\r\n                    isStart: segRange.isStart,\r\n                    isEnd: segRange.isEnd,\r\n                    dayIndex: dayIndex\r\n                };\r\n                segs.push(seg);\r\n                // detect when footprint won't go fully into the next day,\r\n                // and mutate the latest seg to the be the end.\r\n                if (!seg.isEnd && !footprint.isAllDay &&\r\n                    dayIndex + 1 < dayRanges.length &&\r\n                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {\r\n                    seg.endMs = footprint.unzonedRange.endMs;\r\n                    seg.isEnd = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return segs;\r\n    };\r\n    ListView.prototype.renderEmptyMessage = function () {\r\n        this.contentEl.html('<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\r\n            '<div class=\"fc-list-empty-wrap1\">' +\r\n            '<div class=\"fc-list-empty\">' +\r\n            util_1.htmlEscape(this.opt('noEventsMessage')) +\r\n            '</div>' +\r\n            '</div>' +\r\n            '</div>');\r\n    };\r\n    // render the event segments in the view\r\n    ListView.prototype.renderSegList = function (allSegs) {\r\n        var segsByDay = this.groupSegsByDay(allSegs); // sparse array\r\n        var dayIndex;\r\n        var daySegs;\r\n        var i;\r\n        var tableEl = $('<table class=\"fc-list-table ' + this.calendar.theme.getClass('tableList') + '\"><tbody/></table>');\r\n        var tbodyEl = tableEl.find('tbody');\r\n        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\r\n            daySegs = segsByDay[dayIndex];\r\n            if (daySegs) {\r\n                // append a day header\r\n                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));\r\n                this.eventRenderer.sortEventSegs(daySegs);\r\n                for (i = 0; i < daySegs.length; i++) {\r\n                    tbodyEl.append(daySegs[i].el); // append event row\r\n                }\r\n            }\r\n        }\r\n        this.contentEl.empty().append(tableEl);\r\n    };\r\n    // Returns a sparse array of arrays, segs grouped by their dayIndex\r\n    ListView.prototype.groupSegsByDay = function (segs) {\r\n        var segsByDay = []; // sparse array\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\r\n                .push(seg);\r\n        }\r\n        return segsByDay;\r\n    };\r\n    // generates the HTML for the day headers that live amongst the event rows\r\n    ListView.prototype.dayHeaderHtml = function (dayDate) {\r\n        var mainFormat = this.opt('listDayFormat');\r\n        var altFormat = this.opt('listDayAltFormat');\r\n        return '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\r\n            '<td class=\"' + (this.calendar.theme.getClass('tableListHeading') ||\r\n            this.calendar.theme.getClass('widgetHeader')) + '\" colspan=\"3\">' +\r\n            (mainFormat ?\r\n                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML\r\n                ) :\r\n                '') +\r\n            (altFormat ?\r\n                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML\r\n                ) :\r\n                '') +\r\n            '</td>' +\r\n            '</tr>';\r\n    };\r\n    return ListView;\r\n}(View_1.default));\r\nexports.default = ListView;\r\nListView.prototype.eventRendererClass = ListEventRenderer_1.default;\r\nListView.prototype.eventPointingClass = ListEventPointing_1.default;\r\n\n\n/***/ }),\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */,\n/* 235 */,\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(3);\r\nvar exportHooks = __webpack_require__(16);\r\nvar util_1 = __webpack_require__(4);\r\nvar Calendar_1 = __webpack_require__(220);\r\n// for intentional side-effects\r\n__webpack_require__(10);\r\n__webpack_require__(47);\r\n__webpack_require__(256);\r\n__webpack_require__(257);\r\n__webpack_require__(260);\r\n__webpack_require__(261);\r\n__webpack_require__(262);\r\n__webpack_require__(263);\r\n$.fullCalendar = exportHooks;\r\n$.fn.fullCalendar = function (options) {\r\n    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call\r\n    var res = this; // what this function will return (this jQuery object by default)\r\n    this.each(function (i, _element) {\r\n        var element = $(_element);\r\n        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\r\n        var singleRes; // the returned value of this single method call\r\n        // a method call\r\n        if (typeof options === 'string') {\r\n            if (options === 'getCalendar') {\r\n                if (!i) {\r\n                    res = calendar;\r\n                }\r\n            }\r\n            else if (options === 'destroy') {\r\n                if (calendar) {\r\n                    calendar.destroy();\r\n                    element.removeData('fullCalendar');\r\n                }\r\n            }\r\n            else if (!calendar) {\r\n                util_1.warn('Attempting to call a FullCalendar method on an element with no calendar.');\r\n            }\r\n            else if ($.isFunction(calendar[options])) {\r\n                singleRes = calendar[options].apply(calendar, args);\r\n                if (!i) {\r\n                    res = singleRes; // record the first method call result\r\n                }\r\n                if (options === 'destroy') {\r\n                    element.removeData('fullCalendar');\r\n                }\r\n            }\r\n            else {\r\n                util_1.warn(\"'\" + options + \"' is an unknown FullCalendar method.\");\r\n            }\r\n        }\r\n        else if (!calendar) {\r\n            calendar = new Calendar_1.default(element, options);\r\n            element.data('fullCalendar', calendar);\r\n            calendar.render();\r\n        }\r\n    });\r\n    return res;\r\n};\r\nmodule.exports = exportHooks;\r\n\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Model_1 = __webpack_require__(48);\r\nvar Component = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Component, _super);\r\n    function Component() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Component.prototype.setElement = function (el) {\r\n        this.el = el;\r\n        this.bindGlobalHandlers();\r\n        this.renderSkeleton();\r\n        this.set('isInDom', true);\r\n    };\r\n    Component.prototype.removeElement = function () {\r\n        this.unset('isInDom');\r\n        this.unrenderSkeleton();\r\n        this.unbindGlobalHandlers();\r\n        this.el.remove();\r\n        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.\r\n        // We don't null-out the View's other jQuery element references upon destroy,\r\n        //  so we shouldn't kill this.el either.\r\n    };\r\n    Component.prototype.bindGlobalHandlers = function () {\r\n        // subclasses can override\r\n    };\r\n    Component.prototype.unbindGlobalHandlers = function () {\r\n        // subclasses can override\r\n    };\r\n    /*\r\n    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender\r\n    */\r\n    // Renders the basic structure of the view before any content is rendered\r\n    Component.prototype.renderSkeleton = function () {\r\n        // subclasses should implement\r\n    };\r\n    // Unrenders the basic structure of the view\r\n    Component.prototype.unrenderSkeleton = function () {\r\n        // subclasses should implement\r\n    };\r\n    return Component;\r\n}(Model_1.default));\r\nexports.default = Component;\r\n\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Iterator = /** @class */ (function () {\r\n    function Iterator(items) {\r\n        this.items = items || [];\r\n    }\r\n    /* Calls a method on every item passing the arguments through */\r\n    Iterator.prototype.proxyCall = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var results = [];\r\n        this.items.forEach(function (item) {\r\n            results.push(item[methodName].apply(item, args));\r\n        });\r\n        return results;\r\n    };\r\n    return Iterator;\r\n}());\r\nexports.default = Iterator;\r\n\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\n/* Toolbar with buttons and title\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar Toolbar = /** @class */ (function () {\r\n    function Toolbar(calendar, toolbarOptions) {\r\n        this.el = null; // mirrors local `el`\r\n        this.viewsWithButtons = [];\r\n        this.calendar = calendar;\r\n        this.toolbarOptions = toolbarOptions;\r\n    }\r\n    // method to update toolbar-specific options, not calendar-wide options\r\n    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {\r\n        this.toolbarOptions = newToolbarOptions;\r\n    };\r\n    // can be called repeatedly and will rerender\r\n    Toolbar.prototype.render = function () {\r\n        var sections = this.toolbarOptions.layout;\r\n        var el = this.el;\r\n        if (sections) {\r\n            if (!el) {\r\n                el = this.el = $(\"<div class='fc-toolbar \" + this.toolbarOptions.extraClasses + \"'/>\");\r\n            }\r\n            else {\r\n                el.empty();\r\n            }\r\n            el.append(this.renderSection('left'))\r\n                .append(this.renderSection('right'))\r\n                .append(this.renderSection('center'))\r\n                .append('<div class=\"fc-clear\"/>');\r\n        }\r\n        else {\r\n            this.removeElement();\r\n        }\r\n    };\r\n    Toolbar.prototype.removeElement = function () {\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n    };\r\n    Toolbar.prototype.renderSection = function (position) {\r\n        var _this = this;\r\n        var calendar = this.calendar;\r\n        var theme = calendar.theme;\r\n        var optionsManager = calendar.optionsManager;\r\n        var viewSpecManager = calendar.viewSpecManager;\r\n        var sectionEl = $('<div class=\"fc-' + position + '\"/>');\r\n        var buttonStr = this.toolbarOptions.layout[position];\r\n        var calendarCustomButtons = optionsManager.get('customButtons') || {};\r\n        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};\r\n        var calendarButtonText = optionsManager.get('buttonText') || {};\r\n        if (buttonStr) {\r\n            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {\r\n                var groupChildren = $();\r\n                var isOnlyButtons = true;\r\n                var groupEl;\r\n                $.each(buttonGroupStr.split(','), function (j, buttonName) {\r\n                    var customButtonProps;\r\n                    var viewSpec;\r\n                    var buttonClick;\r\n                    var buttonIcon; // only one of these will be set\r\n                    var buttonText; // \"\r\n                    var buttonInnerHtml;\r\n                    var buttonClasses;\r\n                    var buttonEl;\r\n                    var buttonAriaAttr;\r\n                    if (buttonName === 'title') {\r\n                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\r\n                        isOnlyButtons = false;\r\n                    }\r\n                    else {\r\n                        if ((customButtonProps = calendarCustomButtons[buttonName])) {\r\n                            buttonClick = function (ev) {\r\n                                if (customButtonProps.click) {\r\n                                    customButtonProps.click.call(buttonEl[0], ev);\r\n                                }\r\n                            };\r\n                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = customButtonProps.text);\r\n                        }\r\n                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {\r\n                            _this.viewsWithButtons.push(buttonName);\r\n                            buttonClick = function () {\r\n                                calendar.changeView(buttonName);\r\n                            };\r\n                            (buttonText = viewSpec.buttonTextOverride) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = viewSpec.buttonTextDefault);\r\n                        }\r\n                        else if (calendar[buttonName]) {\r\n                            buttonClick = function () {\r\n                                calendar[buttonName]();\r\n                            };\r\n                            (buttonText = calendarButtonTextOverrides[buttonName]) ||\r\n                                (buttonIcon = theme.getIconClass(buttonName)) ||\r\n                                (buttonText = calendarButtonText[buttonName]);\r\n                            //            ^ everything else is considered default\r\n                        }\r\n                        if (buttonClick) {\r\n                            buttonClasses = [\r\n                                'fc-' + buttonName + '-button',\r\n                                theme.getClass('button'),\r\n                                theme.getClass('stateDefault')\r\n                            ];\r\n                            if (buttonText) {\r\n                                buttonInnerHtml = util_1.htmlEscape(buttonText);\r\n                                buttonAriaAttr = '';\r\n                            }\r\n                            else if (buttonIcon) {\r\n                                buttonInnerHtml = \"<span class='\" + buttonIcon + \"'></span>\";\r\n                                buttonAriaAttr = ' aria-label=\"' + buttonName + '\"';\r\n                            }\r\n                            buttonEl = $(// type=\"button\" so that it doesn't submit a form\r\n                            '<button type=\"button\" class=\"' + buttonClasses.join(' ') + '\"' +\r\n                                buttonAriaAttr +\r\n                                '>' + buttonInnerHtml + '</button>')\r\n                                .click(function (ev) {\r\n                                // don't process clicks for disabled buttons\r\n                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {\r\n                                    buttonClick(ev);\r\n                                    // after the click action, if the button becomes the \"active\" tab, or disabled,\r\n                                    // it should never have a hover class, so remove it now.\r\n                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||\r\n                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {\r\n                                        buttonEl.removeClass(theme.getClass('stateHover'));\r\n                                    }\r\n                                }\r\n                            })\r\n                                .mousedown(function () {\r\n                                // the *down* effect (mouse pressed in).\r\n                                // only on buttons that are not the \"active\" tab, or disabled\r\n                                buttonEl\r\n                                    .not('.' + theme.getClass('stateActive'))\r\n                                    .not('.' + theme.getClass('stateDisabled'))\r\n                                    .addClass(theme.getClass('stateDown'));\r\n                            })\r\n                                .mouseup(function () {\r\n                                // undo the *down* effect\r\n                                buttonEl.removeClass(theme.getClass('stateDown'));\r\n                            })\r\n                                .hover(function () {\r\n                                // the *hover* effect.\r\n                                // only on buttons that are not the \"active\" tab, or disabled\r\n                                buttonEl\r\n                                    .not('.' + theme.getClass('stateActive'))\r\n                                    .not('.' + theme.getClass('stateDisabled'))\r\n                                    .addClass(theme.getClass('stateHover'));\r\n                            }, function () {\r\n                                // undo the *hover* effect\r\n                                buttonEl\r\n                                    .removeClass(theme.getClass('stateHover'))\r\n                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup\r\n                            });\r\n                            groupChildren = groupChildren.add(buttonEl);\r\n                        }\r\n                    }\r\n                });\r\n                if (isOnlyButtons) {\r\n                    groupChildren\r\n                        .first().addClass(theme.getClass('cornerLeft')).end()\r\n                        .last().addClass(theme.getClass('cornerRight')).end();\r\n                }\r\n                if (groupChildren.length > 1) {\r\n                    groupEl = $('<div/>');\r\n                    if (isOnlyButtons) {\r\n                        groupEl.addClass(theme.getClass('buttonGroup'));\r\n                    }\r\n                    groupEl.append(groupChildren);\r\n                    sectionEl.append(groupEl);\r\n                }\r\n                else {\r\n                    sectionEl.append(groupChildren); // 1 or 0 children\r\n                }\r\n            });\r\n        }\r\n        return sectionEl;\r\n    };\r\n    Toolbar.prototype.updateTitle = function (text) {\r\n        if (this.el) {\r\n            this.el.find('h2').text(text);\r\n        }\r\n    };\r\n    Toolbar.prototype.activateButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .addClass(this.calendar.theme.getClass('stateActive'));\r\n        }\r\n    };\r\n    Toolbar.prototype.deactivateButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .removeClass(this.calendar.theme.getClass('stateActive'));\r\n        }\r\n    };\r\n    Toolbar.prototype.disableButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .prop('disabled', true)\r\n                .addClass(this.calendar.theme.getClass('stateDisabled'));\r\n        }\r\n    };\r\n    Toolbar.prototype.enableButton = function (buttonName) {\r\n        if (this.el) {\r\n            this.el.find('.fc-' + buttonName + '-button')\r\n                .prop('disabled', false)\r\n                .removeClass(this.calendar.theme.getClass('stateDisabled'));\r\n        }\r\n    };\r\n    Toolbar.prototype.getViewsWithButtons = function () {\r\n        return this.viewsWithButtons;\r\n    };\r\n    return Toolbar;\r\n}());\r\nexports.default = Toolbar;\r\n\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar locale_1 = __webpack_require__(31);\r\nvar Model_1 = __webpack_require__(48);\r\nvar OptionsManager = /** @class */ (function (_super) {\r\n    tslib_1.__extends(OptionsManager, _super);\r\n    function OptionsManager(_calendar, overrides) {\r\n        var _this = _super.call(this) || this;\r\n        _this._calendar = _calendar;\r\n        _this.overrides = $.extend({}, overrides); // make a copy\r\n        _this.dynamicOverrides = {};\r\n        _this.compute();\r\n        return _this;\r\n    }\r\n    OptionsManager.prototype.add = function (newOptionHash) {\r\n        var optionCnt = 0;\r\n        var optionName;\r\n        this.recordOverrides(newOptionHash); // will trigger this model's watchers\r\n        for (optionName in newOptionHash) {\r\n            optionCnt++;\r\n        }\r\n        // special-case handling of single option change.\r\n        // if only one option change, `optionName` will be its name.\r\n        if (optionCnt === 1) {\r\n            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\r\n                this._calendar.updateViewSize(true); // isResize=true\r\n                return;\r\n            }\r\n            else if (optionName === 'defaultDate') {\r\n                return; // can't change date this way. use gotoDate instead\r\n            }\r\n            else if (optionName === 'businessHours') {\r\n                return; // this model already reacts to this\r\n            }\r\n            else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {\r\n                return; // doesn't affect rendering. only interactions.\r\n            }\r\n            else if (optionName === 'timezone') {\r\n                this._calendar.view.flash('initialEvents');\r\n                return;\r\n            }\r\n        }\r\n        // catch-all. rerender the header and footer and rebuild/rerender the current view\r\n        this._calendar.renderHeader();\r\n        this._calendar.renderFooter();\r\n        // even non-current views will be affected by this option change. do before rerender\r\n        // TODO: detangle\r\n        this._calendar.viewsByType = {};\r\n        this._calendar.reinitView();\r\n    };\r\n    // Computes the flattened options hash for the calendar and assigns to `this.options`.\r\n    // Assumes this.overrides and this.dynamicOverrides have already been initialized.\r\n    OptionsManager.prototype.compute = function () {\r\n        var locale;\r\n        var localeDefaults;\r\n        var isRTL;\r\n        var dirDefaults;\r\n        var rawOptions;\r\n        locale = util_1.firstDefined(// explicit locale option given?\r\n        this.dynamicOverrides.locale, this.overrides.locale);\r\n        localeDefaults = locale_1.localeOptionHash[locale];\r\n        if (!localeDefaults) {\r\n            locale = options_1.globalDefaults.locale;\r\n            localeDefaults = locale_1.localeOptionHash[locale] || {};\r\n        }\r\n        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?\r\n        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);\r\n        dirDefaults = isRTL ? options_1.rtlDefaults : {};\r\n        this.dirDefaults = dirDefaults;\r\n        this.localeDefaults = localeDefaults;\r\n        rawOptions = options_1.mergeOptions([\r\n            options_1.globalDefaults,\r\n            dirDefaults,\r\n            localeDefaults,\r\n            this.overrides,\r\n            this.dynamicOverrides\r\n        ]);\r\n        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\r\n        this.reset(rawOptions);\r\n    };\r\n    // stores the new options internally, but does not rerender anything.\r\n    OptionsManager.prototype.recordOverrides = function (newOptionHash) {\r\n        var optionName;\r\n        for (optionName in newOptionHash) {\r\n            this.dynamicOverrides[optionName] = newOptionHash[optionName];\r\n        }\r\n        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it\r\n        this.compute(); // this.options needs to be recomputed after the dynamic override\r\n    };\r\n    return OptionsManager;\r\n}(Model_1.default));\r\nexports.default = OptionsManager;\r\n\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar moment = __webpack_require__(0);\r\nvar $ = __webpack_require__(3);\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar util_1 = __webpack_require__(4);\r\nvar options_1 = __webpack_require__(32);\r\nvar locale_1 = __webpack_require__(31);\r\nvar ViewSpecManager = /** @class */ (function () {\r\n    function ViewSpecManager(optionsManager, _calendar) {\r\n        this.optionsManager = optionsManager;\r\n        this._calendar = _calendar;\r\n        this.clearCache();\r\n    }\r\n    ViewSpecManager.prototype.clearCache = function () {\r\n        this.viewSpecCache = {};\r\n    };\r\n    // Gets information about how to create a view. Will use a cache.\r\n    ViewSpecManager.prototype.getViewSpec = function (viewType) {\r\n        var cache = this.viewSpecCache;\r\n        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\r\n    };\r\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\r\n    // Preference is given to views that have corresponding buttons.\r\n    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {\r\n        var viewTypes;\r\n        var i;\r\n        var spec;\r\n        if ($.inArray(unit, util_1.unitsDesc) !== -1) {\r\n            // put views that have buttons first. there will be duplicates, but oh well\r\n            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?\r\n            $.each(ViewRegistry_1.viewHash, function (viewType) {\r\n                viewTypes.push(viewType);\r\n            });\r\n            for (i = 0; i < viewTypes.length; i++) {\r\n                spec = this.getViewSpec(viewTypes[i]);\r\n                if (spec) {\r\n                    if (spec.singleUnit === unit) {\r\n                        return spec;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Builds an object with information on how to create a given view\r\n    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {\r\n        var viewOverrides = this.optionsManager.overrides.views || {};\r\n        var specChain = []; // for the view. lowest to highest priority\r\n        var defaultsChain = []; // for the view. lowest to highest priority\r\n        var overridesChain = []; // for the view. lowest to highest priority\r\n        var viewType = requestedViewType;\r\n        var spec; // for the view\r\n        var overrides; // for the view\r\n        var durationInput;\r\n        var duration;\r\n        var unit;\r\n        // iterate from the specific view definition to a more general one until we hit an actual View class\r\n        while (viewType) {\r\n            spec = ViewRegistry_1.viewHash[viewType];\r\n            overrides = viewOverrides[viewType];\r\n            viewType = null; // clear. might repopulate for another iteration\r\n            if (typeof spec === 'function') {\r\n                spec = { 'class': spec };\r\n            }\r\n            if (spec) {\r\n                specChain.unshift(spec);\r\n                defaultsChain.unshift(spec.defaults || {});\r\n                durationInput = durationInput || spec.duration;\r\n                viewType = viewType || spec.type;\r\n            }\r\n            if (overrides) {\r\n                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\r\n                durationInput = durationInput || overrides.duration;\r\n                viewType = viewType || overrides.type;\r\n            }\r\n        }\r\n        spec = util_1.mergeProps(specChain);\r\n        spec.type = requestedViewType;\r\n        if (!spec['class']) {\r\n            return false;\r\n        }\r\n        // fall back to top-level `duration` option\r\n        durationInput = durationInput ||\r\n            this.optionsManager.dynamicOverrides.duration ||\r\n            this.optionsManager.overrides.duration;\r\n        if (durationInput) {\r\n            duration = moment.duration(durationInput);\r\n            if (duration.valueOf()) {\r\n                unit = util_1.computeDurationGreatestUnit(duration, durationInput);\r\n                spec.duration = duration;\r\n                spec.durationUnit = unit;\r\n                // view is a single-unit duration, like \"week\" or \"day\"\r\n                // incorporate options for this. lowest priority\r\n                if (duration.as(unit) === 1) {\r\n                    spec.singleUnit = unit;\r\n                    overridesChain.unshift(viewOverrides[unit] || {});\r\n                }\r\n            }\r\n        }\r\n        spec.defaults = options_1.mergeOptions(defaultsChain);\r\n        spec.overrides = options_1.mergeOptions(overridesChain);\r\n        this.buildViewSpecOptions(spec);\r\n        this.buildViewSpecButtonText(spec, requestedViewType);\r\n        return spec;\r\n    };\r\n    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides\r\n    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {\r\n        var optionsManager = this.optionsManager;\r\n        spec.options = options_1.mergeOptions([\r\n            options_1.globalDefaults,\r\n            spec.defaults,\r\n            optionsManager.dirDefaults,\r\n            optionsManager.localeDefaults,\r\n            optionsManager.overrides,\r\n            spec.overrides,\r\n            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence\r\n        ]);\r\n        locale_1.populateInstanceComputableOptions(spec.options);\r\n    };\r\n    // Computes and assigns a view spec's buttonText-related options\r\n    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {\r\n        var optionsManager = this.optionsManager;\r\n        // given an options object with a possible `buttonText` hash, lookup the buttonText for the\r\n        // requested view, falling back to a generic unit entry like \"week\" or \"day\"\r\n        function queryButtonText(options) {\r\n            var buttonText = options.buttonText || {};\r\n            return buttonText[requestedViewType] ||\r\n                // view can decide to look up a certain key\r\n                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\r\n                // a key like \"month\"\r\n                (spec.singleUnit ? buttonText[spec.singleUnit] : null);\r\n        }\r\n        // highest to lowest priority\r\n        spec.buttonTextOverride =\r\n            queryButtonText(optionsManager.dynamicOverrides) ||\r\n                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence\r\n                spec.overrides.buttonText; // `buttonText` for view-specific options is a string\r\n        // highest to lowest priority. mirrors buildViewSpecOptions\r\n        spec.buttonTextDefault =\r\n            queryButtonText(optionsManager.localeDefaults) ||\r\n                queryButtonText(optionsManager.dirDefaults) ||\r\n                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults\r\n                queryButtonText(options_1.globalDefaults) ||\r\n                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like \"3 days\"\r\n                requestedViewType; // fall back to given view name\r\n    };\r\n    return ViewSpecManager;\r\n}());\r\nexports.default = ViewSpecManager;\r\n\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventPeriod_1 = __webpack_require__(243);\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nvar EventSource_1 = __webpack_require__(6);\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar SingleEventDef_1 = __webpack_require__(13);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar EventManager = /** @class */ (function () {\r\n    function EventManager(calendar) {\r\n        this.calendar = calendar;\r\n        this.stickySource = new ArrayEventSource_1.default(calendar);\r\n        this.otherSources = [];\r\n    }\r\n    EventManager.prototype.requestEvents = function (start, end, timezone, force) {\r\n        if (force ||\r\n            !this.currentPeriod ||\r\n            !this.currentPeriod.isWithinRange(start, end) ||\r\n            timezone !== this.currentPeriod.timezone) {\r\n            this.setPeriod(// will change this.currentPeriod\r\n            new EventPeriod_1.default(start, end, timezone));\r\n        }\r\n        return this.currentPeriod.whenReleased();\r\n    };\r\n    // Source Adding/Removing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.addSource = function (eventSource) {\r\n        this.otherSources.push(eventSource);\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.requestSource(eventSource); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeSource = function (doomedSource) {\r\n        util_1.removeExact(this.otherSources, doomedSource);\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.purgeSource(doomedSource); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeAllSources = function () {\r\n        this.otherSources = [];\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.purgeAllSources(); // might release\r\n        }\r\n    };\r\n    // Source Refetching\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.refetchSource = function (eventSource) {\r\n        var currentPeriod = this.currentPeriod;\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            currentPeriod.purgeSource(eventSource);\r\n            currentPeriod.requestSource(eventSource);\r\n            currentPeriod.thaw();\r\n        }\r\n    };\r\n    EventManager.prototype.refetchAllSources = function () {\r\n        var currentPeriod = this.currentPeriod;\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            currentPeriod.purgeAllSources();\r\n            currentPeriod.requestSources(this.getSources());\r\n            currentPeriod.thaw();\r\n        }\r\n    };\r\n    // Source Querying\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.getSources = function () {\r\n        return [this.stickySource].concat(this.otherSources);\r\n    };\r\n    // like querySources, but accepts multple match criteria (like multiple IDs)\r\n    EventManager.prototype.multiQuerySources = function (matchInputs) {\r\n        // coerce into an array\r\n        if (!matchInputs) {\r\n            matchInputs = [];\r\n        }\r\n        else if (!$.isArray(matchInputs)) {\r\n            matchInputs = [matchInputs];\r\n        }\r\n        var matchingSources = [];\r\n        var i;\r\n        // resolve raw inputs to real event source objects\r\n        for (i = 0; i < matchInputs.length; i++) {\r\n            matchingSources.push.apply(// append\r\n            matchingSources, this.querySources(matchInputs[i]));\r\n        }\r\n        return matchingSources;\r\n    };\r\n    // matchInput can either by a real event source object, an ID, or the function/URL for the source.\r\n    // returns an array of matching source objects.\r\n    EventManager.prototype.querySources = function (matchInput) {\r\n        var sources = this.otherSources;\r\n        var i;\r\n        var source;\r\n        // given a proper event source object\r\n        for (i = 0; i < sources.length; i++) {\r\n            source = sources[i];\r\n            if (source === matchInput) {\r\n                return [source];\r\n            }\r\n        }\r\n        // an ID match\r\n        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));\r\n        if (source) {\r\n            return [source];\r\n        }\r\n        // parse as an event source\r\n        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);\r\n        if (matchInput) {\r\n            return $.grep(sources, function (source) {\r\n                return isSourcesEquivalent(matchInput, source);\r\n            });\r\n        }\r\n    };\r\n    /*\r\n    ID assumed to already be normalized\r\n    */\r\n    EventManager.prototype.getSourceById = function (id) {\r\n        return $.grep(this.otherSources, function (source) {\r\n            return source.id && source.id === id;\r\n        })[0];\r\n    };\r\n    // Event-Period\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.setPeriod = function (eventPeriod) {\r\n        if (this.currentPeriod) {\r\n            this.unbindPeriod(this.currentPeriod);\r\n            this.currentPeriod = null;\r\n        }\r\n        this.currentPeriod = eventPeriod;\r\n        this.bindPeriod(eventPeriod);\r\n        eventPeriod.requestSources(this.getSources());\r\n    };\r\n    EventManager.prototype.bindPeriod = function (eventPeriod) {\r\n        this.listenTo(eventPeriod, 'release', function (eventsPayload) {\r\n            this.trigger('release', eventsPayload);\r\n        });\r\n    };\r\n    EventManager.prototype.unbindPeriod = function (eventPeriod) {\r\n        this.stopListeningTo(eventPeriod);\r\n    };\r\n    // Event Getting/Adding/Removing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.getEventDefByUid = function (uid) {\r\n        if (this.currentPeriod) {\r\n            return this.currentPeriod.getEventDefByUid(uid);\r\n        }\r\n    };\r\n    EventManager.prototype.addEventDef = function (eventDef, isSticky) {\r\n        if (isSticky) {\r\n            this.stickySource.addEventDef(eventDef);\r\n        }\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.addEventDef(eventDef); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeEventDefsById = function (eventId) {\r\n        this.getSources().forEach(function (eventSource) {\r\n            eventSource.removeEventDefsById(eventId);\r\n        });\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.removeEventDefsById(eventId); // might release\r\n        }\r\n    };\r\n    EventManager.prototype.removeAllEventDefs = function () {\r\n        this.getSources().forEach(function (eventSource) {\r\n            eventSource.removeAllEventDefs();\r\n        });\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.removeAllEventDefs();\r\n        }\r\n    };\r\n    // Event Mutating\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    Returns an undo function.\r\n    */\r\n    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {\r\n        var currentPeriod = this.currentPeriod;\r\n        var eventDefs;\r\n        var undoFuncs = [];\r\n        if (currentPeriod) {\r\n            currentPeriod.freeze();\r\n            eventDefs = currentPeriod.getEventDefsById(eventDefId);\r\n            eventDefs.forEach(function (eventDef) {\r\n                // add/remove esp because id might change\r\n                currentPeriod.removeEventDef(eventDef);\r\n                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));\r\n                currentPeriod.addEventDef(eventDef);\r\n            });\r\n            currentPeriod.thaw();\r\n            return function () {\r\n                currentPeriod.freeze();\r\n                for (var i = 0; i < eventDefs.length; i++) {\r\n                    currentPeriod.removeEventDef(eventDefs[i]);\r\n                    undoFuncs[i]();\r\n                    currentPeriod.addEventDef(eventDefs[i]);\r\n                }\r\n                currentPeriod.thaw();\r\n            };\r\n        }\r\n        return function () { };\r\n    };\r\n    /*\r\n    copies and then mutates\r\n    */\r\n    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {\r\n        var eventDefs = this.getEventDefsById(eventDefId);\r\n        var i;\r\n        var defCopy;\r\n        var allInstances = [];\r\n        for (i = 0; i < eventDefs.length; i++) {\r\n            defCopy = eventDefs[i].clone();\r\n            if (defCopy instanceof SingleEventDef_1.default) {\r\n                eventDefMutation.mutateSingle(defCopy);\r\n                allInstances.push.apply(allInstances, // append\r\n                defCopy.buildInstances());\r\n            }\r\n        }\r\n        return new EventInstanceGroup_1.default(allInstances);\r\n    };\r\n    // Freezing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventManager.prototype.freeze = function () {\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.freeze();\r\n        }\r\n    };\r\n    EventManager.prototype.thaw = function () {\r\n        if (this.currentPeriod) {\r\n            this.currentPeriod.thaw();\r\n        }\r\n    };\r\n    // methods that simply forward to EventPeriod\r\n    EventManager.prototype.getEventDefsById = function (eventDefId) {\r\n        return this.currentPeriod.getEventDefsById(eventDefId);\r\n    };\r\n    EventManager.prototype.getEventInstances = function () {\r\n        return this.currentPeriod.getEventInstances();\r\n    };\r\n    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {\r\n        return this.currentPeriod.getEventInstancesWithId(eventDefId);\r\n    };\r\n    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {\r\n        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);\r\n    };\r\n    return EventManager;\r\n}());\r\nexports.default = EventManager;\r\nEmitterMixin_1.default.mixInto(EventManager);\r\nListenerMixin_1.default.mixInto(EventManager);\r\nfunction isSourcesEquivalent(source0, source1) {\r\n    return source0.getPrimitive() === source1.getPrimitive();\r\n}\r\n\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar Promise_1 = __webpack_require__(20);\r\nvar EmitterMixin_1 = __webpack_require__(11);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar EventInstanceGroup_1 = __webpack_require__(18);\r\nvar EventPeriod = /** @class */ (function () {\r\n    function EventPeriod(start, end, timezone) {\r\n        this.pendingCnt = 0;\r\n        this.freezeDepth = 0;\r\n        this.stuntedReleaseCnt = 0;\r\n        this.releaseCnt = 0;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.timezone = timezone;\r\n        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());\r\n        this.requestsByUid = {};\r\n        this.eventDefsByUid = {};\r\n        this.eventDefsById = {};\r\n        this.eventInstanceGroupsById = {};\r\n    }\r\n    EventPeriod.prototype.isWithinRange = function (start, end) {\r\n        // TODO: use a range util function?\r\n        return !start.isBefore(this.start) && !end.isAfter(this.end);\r\n    };\r\n    // Requesting and Purging\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.requestSources = function (sources) {\r\n        this.freeze();\r\n        for (var i = 0; i < sources.length; i++) {\r\n            this.requestSource(sources[i]);\r\n        }\r\n        this.thaw();\r\n    };\r\n    EventPeriod.prototype.requestSource = function (source) {\r\n        var _this = this;\r\n        var request = { source: source, status: 'pending', eventDefs: null };\r\n        this.requestsByUid[source.uid] = request;\r\n        this.pendingCnt += 1;\r\n        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {\r\n            if (request.status !== 'cancelled') {\r\n                request.status = 'completed';\r\n                request.eventDefs = eventDefs;\r\n                _this.addEventDefs(eventDefs);\r\n                _this.pendingCnt--;\r\n                _this.tryRelease();\r\n            }\r\n        }, function () {\r\n            if (request.status !== 'cancelled') {\r\n                request.status = 'failed';\r\n                _this.pendingCnt--;\r\n                _this.tryRelease();\r\n            }\r\n        });\r\n    };\r\n    EventPeriod.prototype.purgeSource = function (source) {\r\n        var request = this.requestsByUid[source.uid];\r\n        if (request) {\r\n            delete this.requestsByUid[source.uid];\r\n            if (request.status === 'pending') {\r\n                request.status = 'cancelled';\r\n                this.pendingCnt--;\r\n                this.tryRelease();\r\n            }\r\n            else if (request.status === 'completed') {\r\n                request.eventDefs.forEach(this.removeEventDef.bind(this));\r\n            }\r\n        }\r\n    };\r\n    EventPeriod.prototype.purgeAllSources = function () {\r\n        var requestsByUid = this.requestsByUid;\r\n        var uid;\r\n        var request;\r\n        var completedCnt = 0;\r\n        for (uid in requestsByUid) {\r\n            request = requestsByUid[uid];\r\n            if (request.status === 'pending') {\r\n                request.status = 'cancelled';\r\n            }\r\n            else if (request.status === 'completed') {\r\n                completedCnt++;\r\n            }\r\n        }\r\n        this.requestsByUid = {};\r\n        this.pendingCnt = 0;\r\n        if (completedCnt) {\r\n            this.removeAllEventDefs(); // might release\r\n        }\r\n    };\r\n    // Event Definitions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {\r\n        return this.eventDefsByUid[eventDefUid];\r\n    };\r\n    EventPeriod.prototype.getEventDefsById = function (eventDefId) {\r\n        var a = this.eventDefsById[eventDefId];\r\n        if (a) {\r\n            return a.slice(); // clone\r\n        }\r\n        return [];\r\n    };\r\n    EventPeriod.prototype.addEventDefs = function (eventDefs) {\r\n        for (var i = 0; i < eventDefs.length; i++) {\r\n            this.addEventDef(eventDefs[i]);\r\n        }\r\n    };\r\n    EventPeriod.prototype.addEventDef = function (eventDef) {\r\n        var eventDefsById = this.eventDefsById;\r\n        var eventDefId = eventDef.id;\r\n        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);\r\n        var eventInstances = eventDef.buildInstances(this.unzonedRange);\r\n        var i;\r\n        eventDefs.push(eventDef);\r\n        this.eventDefsByUid[eventDef.uid] = eventDef;\r\n        for (i = 0; i < eventInstances.length; i++) {\r\n            this.addEventInstance(eventInstances[i], eventDefId);\r\n        }\r\n    };\r\n    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {\r\n        var _this = this;\r\n        this.getEventDefsById(eventDefId).forEach(function (eventDef) {\r\n            _this.removeEventDef(eventDef);\r\n        });\r\n    };\r\n    EventPeriod.prototype.removeAllEventDefs = function () {\r\n        var isEmpty = $.isEmptyObject(this.eventDefsByUid);\r\n        this.eventDefsByUid = {};\r\n        this.eventDefsById = {};\r\n        this.eventInstanceGroupsById = {};\r\n        if (!isEmpty) {\r\n            this.tryRelease();\r\n        }\r\n    };\r\n    EventPeriod.prototype.removeEventDef = function (eventDef) {\r\n        var eventDefsById = this.eventDefsById;\r\n        var eventDefs = eventDefsById[eventDef.id];\r\n        delete this.eventDefsByUid[eventDef.uid];\r\n        if (eventDefs) {\r\n            util_1.removeExact(eventDefs, eventDef);\r\n            if (!eventDefs.length) {\r\n                delete eventDefsById[eventDef.id];\r\n            }\r\n            this.removeEventInstancesForDef(eventDef);\r\n        }\r\n    };\r\n    // Event Instances\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.getEventInstances = function () {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstances = [];\r\n        var id;\r\n        for (id in eventInstanceGroupsById) {\r\n            eventInstances.push.apply(eventInstances, // append\r\n            eventInstanceGroupsById[id].eventInstances);\r\n        }\r\n        return eventInstances;\r\n    };\r\n    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {\r\n        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];\r\n        if (eventInstanceGroup) {\r\n            return eventInstanceGroup.eventInstances.slice(); // clone\r\n        }\r\n        return [];\r\n    };\r\n    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var matchingInstances = [];\r\n        var id;\r\n        for (id in eventInstanceGroupsById) {\r\n            if (id !== eventDefId) {\r\n                matchingInstances.push.apply(matchingInstances, // append\r\n                eventInstanceGroupsById[id].eventInstances);\r\n            }\r\n        }\r\n        return matchingInstances;\r\n    };\r\n    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||\r\n            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());\r\n        eventInstanceGroup.eventInstances.push(eventInstance);\r\n        this.tryRelease();\r\n    };\r\n    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {\r\n        var eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];\r\n        var removeCnt;\r\n        if (eventInstanceGroup) {\r\n            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {\r\n                return currentEventInstance.def === eventDef;\r\n            });\r\n            if (!eventInstanceGroup.eventInstances.length) {\r\n                delete eventInstanceGroupsById[eventDef.id];\r\n            }\r\n            if (removeCnt) {\r\n                this.tryRelease();\r\n            }\r\n        }\r\n    };\r\n    // Releasing and Freezing\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    EventPeriod.prototype.tryRelease = function () {\r\n        if (!this.pendingCnt) {\r\n            if (!this.freezeDepth) {\r\n                this.release();\r\n            }\r\n            else {\r\n                this.stuntedReleaseCnt++;\r\n            }\r\n        }\r\n    };\r\n    EventPeriod.prototype.release = function () {\r\n        this.releaseCnt++;\r\n        this.trigger('release', this.eventInstanceGroupsById);\r\n    };\r\n    EventPeriod.prototype.whenReleased = function () {\r\n        var _this = this;\r\n        if (this.releaseCnt) {\r\n            return Promise_1.default.resolve(this.eventInstanceGroupsById);\r\n        }\r\n        else {\r\n            return Promise_1.default.construct(function (onResolve) {\r\n                _this.one('release', onResolve);\r\n            });\r\n        }\r\n    };\r\n    EventPeriod.prototype.freeze = function () {\r\n        if (!(this.freezeDepth++)) {\r\n            this.stuntedReleaseCnt = 0;\r\n        }\r\n    };\r\n    EventPeriod.prototype.thaw = function () {\r\n        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {\r\n            this.release();\r\n        }\r\n    };\r\n    return EventPeriod;\r\n}());\r\nexports.default = EventPeriod;\r\nEmitterMixin_1.default.mixInto(EventPeriod);\r\n\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\n/* Creates a clone of an element and lets it track the mouse as it moves\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar MouseFollower = /** @class */ (function () {\r\n    function MouseFollower(sourceEl, options) {\r\n        this.isFollowing = false;\r\n        this.isHidden = false;\r\n        this.isAnimating = false; // doing the revert animation?\r\n        this.options = options = options || {};\r\n        this.sourceEl = sourceEl;\r\n        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\r\n    }\r\n    // Causes the element to start following the mouse\r\n    MouseFollower.prototype.start = function (ev) {\r\n        if (!this.isFollowing) {\r\n            this.isFollowing = true;\r\n            this.y0 = util_1.getEvY(ev);\r\n            this.x0 = util_1.getEvX(ev);\r\n            this.topDelta = 0;\r\n            this.leftDelta = 0;\r\n            if (!this.isHidden) {\r\n                this.updatePosition();\r\n            }\r\n            if (util_1.getEvIsTouch(ev)) {\r\n                this.listenTo($(document), 'touchmove', this.handleMove);\r\n            }\r\n            else {\r\n                this.listenTo($(document), 'mousemove', this.handleMove);\r\n            }\r\n        }\r\n    };\r\n    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\r\n    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\r\n    MouseFollower.prototype.stop = function (shouldRevert, callback) {\r\n        var _this = this;\r\n        var revertDuration = this.options.revertDuration;\r\n        var complete = function () {\r\n            _this.isAnimating = false;\r\n            _this.removeElement();\r\n            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        };\r\n        if (this.isFollowing && !this.isAnimating) {\r\n            this.isFollowing = false;\r\n            this.stopListeningTo($(document));\r\n            if (shouldRevert && revertDuration && !this.isHidden) {\r\n                this.isAnimating = true;\r\n                this.el.animate({\r\n                    top: this.top0,\r\n                    left: this.left0\r\n                }, {\r\n                    duration: revertDuration,\r\n                    complete: complete\r\n                });\r\n            }\r\n            else {\r\n                complete();\r\n            }\r\n        }\r\n    };\r\n    // Gets the tracking element. Create it if necessary\r\n    MouseFollower.prototype.getEl = function () {\r\n        var el = this.el;\r\n        if (!el) {\r\n            el = this.el = this.sourceEl.clone()\r\n                .addClass(this.options.additionalClass || '')\r\n                .css({\r\n                position: 'absolute',\r\n                visibility: '',\r\n                display: this.isHidden ? 'none' : '',\r\n                margin: 0,\r\n                right: 'auto',\r\n                bottom: 'auto',\r\n                width: this.sourceEl.width(),\r\n                height: this.sourceEl.height(),\r\n                opacity: this.options.opacity || '',\r\n                zIndex: this.options.zIndex\r\n            });\r\n            // we don't want long taps or any mouse interaction causing selection/menus.\r\n            // would use preventSelection(), but that prevents selectstart, causing problems.\r\n            el.addClass('fc-unselectable');\r\n            el.appendTo(this.parentEl);\r\n        }\r\n        return el;\r\n    };\r\n    // Removes the tracking element if it has already been created\r\n    MouseFollower.prototype.removeElement = function () {\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n    };\r\n    // Update the CSS position of the tracking element\r\n    MouseFollower.prototype.updatePosition = function () {\r\n        var sourceOffset;\r\n        var origin;\r\n        this.getEl(); // ensure this.el\r\n        // make sure origin info was computed\r\n        if (this.top0 == null) {\r\n            sourceOffset = this.sourceEl.offset();\r\n            origin = this.el.offsetParent().offset();\r\n            this.top0 = sourceOffset.top - origin.top;\r\n            this.left0 = sourceOffset.left - origin.left;\r\n        }\r\n        this.el.css({\r\n            top: this.top0 + this.topDelta,\r\n            left: this.left0 + this.leftDelta\r\n        });\r\n    };\r\n    // Gets called when the user moves the mouse\r\n    MouseFollower.prototype.handleMove = function (ev) {\r\n        this.topDelta = util_1.getEvY(ev) - this.y0;\r\n        this.leftDelta = util_1.getEvX(ev) - this.x0;\r\n        if (!this.isHidden) {\r\n            this.updatePosition();\r\n        }\r\n    };\r\n    // Temporarily makes the tracking element invisible. Can be called before following starts\r\n    MouseFollower.prototype.hide = function () {\r\n        if (!this.isHidden) {\r\n            this.isHidden = true;\r\n            if (this.el) {\r\n                this.el.hide();\r\n            }\r\n        }\r\n    };\r\n    // Show the tracking element after it has been temporarily hidden\r\n    MouseFollower.prototype.show = function () {\r\n        if (this.isHidden) {\r\n            this.isHidden = false;\r\n            this.updatePosition();\r\n            this.getEl().show();\r\n        }\r\n    };\r\n    return MouseFollower;\r\n}());\r\nexports.default = MouseFollower;\r\nListenerMixin_1.default.mixInto(MouseFollower);\r\n\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar HitDragListener_1 = __webpack_require__(23);\r\nvar Interaction_1 = __webpack_require__(15);\r\nvar DateClicking = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DateClicking, _super);\r\n    /*\r\n    component must implement:\r\n      - bindDateHandlerToEl\r\n      - getSafeHitFootprint\r\n      - getHitEl\r\n    */\r\n    function DateClicking(component) {\r\n        var _this = _super.call(this, component) || this;\r\n        _this.dragListener = _this.buildDragListener();\r\n        return _this;\r\n    }\r\n    DateClicking.prototype.end = function () {\r\n        this.dragListener.endInteraction();\r\n    };\r\n    DateClicking.prototype.bindToEl = function (el) {\r\n        var component = this.component;\r\n        var dragListener = this.dragListener;\r\n        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {\r\n            if (!component.shouldIgnoreMouse()) {\r\n                dragListener.startInteraction(ev);\r\n            }\r\n        });\r\n        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {\r\n            if (!component.shouldIgnoreTouch()) {\r\n                dragListener.startInteraction(ev);\r\n            }\r\n        });\r\n    };\r\n    // Creates a listener that tracks the user's drag across day elements, for day clicking.\r\n    DateClicking.prototype.buildDragListener = function () {\r\n        var _this = this;\r\n        var component = this.component;\r\n        var dayClickHit; // null if invalid dayClick\r\n        var dragListener = new HitDragListener_1.default(component, {\r\n            scroll: this.opt('dragScroll'),\r\n            interactionStart: function () {\r\n                dayClickHit = dragListener.origHit;\r\n            },\r\n            hitOver: function (hit, isOrig, origHit) {\r\n                // if user dragged to another cell at any point, it can no longer be a dayClick\r\n                if (!isOrig) {\r\n                    dayClickHit = null;\r\n                }\r\n            },\r\n            hitOut: function () {\r\n                dayClickHit = null;\r\n            },\r\n            interactionEnd: function (ev, isCancelled) {\r\n                var componentFootprint;\r\n                if (!isCancelled && dayClickHit) {\r\n                    componentFootprint = component.getSafeHitFootprint(dayClickHit);\r\n                    if (componentFootprint) {\r\n                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        // because dragListener won't be called with any time delay, \"dragging\" will begin immediately,\r\n        // which will kill any touchmoving/scrolling. Prevent this.\r\n        dragListener.shouldCancelTouchScroll = false;\r\n        dragListener.scrollAlwaysKills = true;\r\n        return dragListener;\r\n    };\r\n    return DateClicking;\r\n}(Interaction_1.default));\r\nexports.default = DateClicking;\r\n\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\n/*\r\nOnly handles foreground segs.\r\nDoes not own rendering. Use for low-level util methods by TimeGrid.\r\n*/\r\nvar TimeGridEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridEventRenderer, _super);\r\n    function TimeGridEventRenderer(timeGrid, fillRenderer) {\r\n        var _this = _super.call(this, timeGrid, fillRenderer) || this;\r\n        _this.timeGrid = timeGrid;\r\n        return _this;\r\n    }\r\n    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);\r\n    };\r\n    // Given an array of foreground segments, render a DOM element for each, computes position,\r\n    // and attaches to the column inner-container elements.\r\n    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {\r\n        var segsByCol;\r\n        var col;\r\n        segsByCol = this.timeGrid.groupSegsByCol(segs);\r\n        for (col = 0; col < this.timeGrid.colCnt; col++) {\r\n            this.updateFgSegCoords(segsByCol[col]);\r\n        }\r\n        this.timeGrid.attachSegsByCol(segsByCol, containerEls);\r\n    };\r\n    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {\r\n        if (this.fgSegs) {\r\n            this.fgSegs.forEach(function (seg) {\r\n                seg.el.remove();\r\n            });\r\n        }\r\n    };\r\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\r\n    };\r\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\r\n    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return true;\r\n    };\r\n    // Renders the HTML for a single event segment's default rendering\r\n    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var componentFootprint = seg.footprint.componentFootprint;\r\n        var isAllDay = componentFootprint.isAllDay;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var isDraggable = view.isEventDefDraggable(eventDef);\r\n        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\r\n        var timeText;\r\n        var fullTimeText; // more verbose time text. for the print stylesheet\r\n        var startTimeText; // just the start time text\r\n        classes.unshift('fc-time-grid-event', 'fc-v-event');\r\n        // if the event appears to span more than one day...\r\n        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n            // Don't display time text on segments that run entirely through a day.\r\n            // That would appear as midnight-midnight and would look dumb.\r\n            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\r\n            if (seg.isStart || seg.isEnd) {\r\n                var zonedStart = calendar.msToMoment(seg.startMs);\r\n                var zonedEnd = calendar.msToMoment(seg.endMs);\r\n                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);\r\n                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');\r\n                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false\r\n            }\r\n        }\r\n        else {\r\n            // Display the normal time text for the *event's* times\r\n            timeText = this.getTimeText(seg.footprint);\r\n            fullTimeText = this.getTimeText(seg.footprint, 'LT');\r\n            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false\r\n        }\r\n        return '<a class=\"' + classes.join(' ') + '\"' +\r\n            (eventDef.url ?\r\n                ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\r\n                '') +\r\n            (skinCss ?\r\n                ' style=\"' + skinCss + '\"' :\r\n                '') +\r\n            '>' +\r\n            '<div class=\"fc-content\">' +\r\n            (timeText ?\r\n                '<div class=\"fc-time\"' +\r\n                    ' data-start=\"' + util_1.htmlEscape(startTimeText) + '\"' +\r\n                    ' data-full=\"' + util_1.htmlEscape(fullTimeText) + '\"' +\r\n                    '>' +\r\n                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +\r\n                    '</div>' :\r\n                '') +\r\n            (eventDef.title ?\r\n                '<div class=\"fc-title\">' +\r\n                    util_1.htmlEscape(eventDef.title) +\r\n                    '</div>' :\r\n                '') +\r\n            '</div>' +\r\n            '<div class=\"fc-bg\"/>' +\r\n            /* TODO: write CSS for this\r\n            (isResizableFromStart ?\r\n              '<div class=\"fc-resizer fc-start-resizer\" />' :\r\n              ''\r\n              ) +\r\n            */\r\n            (isResizableFromEnd ?\r\n                '<div class=\"fc-resizer fc-end-resizer\" />' :\r\n                '') +\r\n            '</a>';\r\n    };\r\n    // Given segments that are assumed to all live in the *same column*,\r\n    // compute their verical/horizontal coordinates and assign to their elements.\r\n    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {\r\n        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this\r\n        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\r\n        this.timeGrid.assignSegVerticals(segs);\r\n        this.assignFgSegHorizontals(segs);\r\n    };\r\n    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\r\n    // NOTE: Also reorders the given array by date!\r\n    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {\r\n        var levels;\r\n        var level0;\r\n        var i;\r\n        this.sortEventSegs(segs); // order by certain criteria\r\n        levels = buildSlotSegLevels(segs);\r\n        computeForwardSlotSegs(levels);\r\n        if ((level0 = levels[0])) {\r\n            for (i = 0; i < level0.length; i++) {\r\n                computeSlotSegPressures(level0[i]);\r\n            }\r\n            for (i = 0; i < level0.length; i++) {\r\n                this.computeFgSegForwardBack(level0[i], 0, 0);\r\n            }\r\n        }\r\n    };\r\n    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\r\n    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\r\n    // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\r\n    //\r\n    // The segment might be part of a \"series\", which means consecutive segments with the same pressure\r\n    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\r\n    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\r\n    // coordinate of the first segment in the series.\r\n    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {\r\n        var forwardSegs = seg.forwardSegs;\r\n        var i;\r\n        if (seg.forwardCoord === undefined) {\r\n            if (!forwardSegs.length) {\r\n                // if there are no forward segments, this segment should butt up against the edge\r\n                seg.forwardCoord = 1;\r\n            }\r\n            else {\r\n                // sort highest pressure first\r\n                this.sortForwardSegs(forwardSegs);\r\n                // this segment's forwardCoord will be calculated from the backwardCoord of the\r\n                // highest-pressure forward segment.\r\n                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\r\n                seg.forwardCoord = forwardSegs[0].backwardCoord;\r\n            }\r\n            // calculate the backwardCoord from the forwardCoord. consider the series\r\n            seg.backwardCoord = seg.forwardCoord -\r\n                (seg.forwardCoord - seriesBackwardCoord) / // available width for series\r\n                    (seriesBackwardPressure + 1); // # of segments in the series\r\n            // use this segment's coordinates to computed the coordinates of the less-pressurized\r\n            // forward segments\r\n            for (i = 0; i < forwardSegs.length; i++) {\r\n                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\r\n            }\r\n        }\r\n    };\r\n    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {\r\n        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));\r\n    };\r\n    // A cmp function for determining which forward segment to rely on more when computing coordinates.\r\n    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {\r\n        // put higher-pressure first\r\n        return seg2.forwardPressure - seg1.forwardPressure ||\r\n            // put segments that are closer to initial edge first (and favor ones with no coords yet)\r\n            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\r\n            // do normal sorting...\r\n            this.compareEventSegs(seg1, seg2);\r\n    };\r\n    // Given foreground event segments that have already had their position coordinates computed,\r\n    // assigns position-related CSS values to their elements.\r\n    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {\r\n        var i;\r\n        var seg;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            seg.el.css(this.generateFgSegHorizontalCss(seg));\r\n            // if the height is short, add a className for alternate styling\r\n            if (seg.bottom - seg.top < 30) {\r\n                seg.el.addClass('fc-short');\r\n            }\r\n        }\r\n    };\r\n    // Generates an object with CSS properties/values that should be applied to an event segment element.\r\n    // Contains important positioning-related properties that should be applied to any event element, customized or not.\r\n    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {\r\n        var shouldOverlap = this.opt('slotEventOverlap');\r\n        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\r\n        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\r\n        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\r\n        var isRTL = this.timeGrid.isRTL;\r\n        var left; // amount of space from left edge, a fraction of the total width\r\n        var right; // amount of space from right edge, a fraction of the total width\r\n        if (shouldOverlap) {\r\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\r\n            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\r\n        }\r\n        if (isRTL) {\r\n            left = 1 - forwardCoord;\r\n            right = backwardCoord;\r\n        }\r\n        else {\r\n            left = backwardCoord;\r\n            right = 1 - forwardCoord;\r\n        }\r\n        props.zIndex = seg.level + 1; // convert from 0-base to 1-based\r\n        props.left = left * 100 + '%';\r\n        props.right = right * 100 + '%';\r\n        if (shouldOverlap && seg.forwardPressure) {\r\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\r\n            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\r\n        }\r\n        return props;\r\n    };\r\n    return TimeGridEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = TimeGridEventRenderer;\r\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\r\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\r\nfunction buildSlotSegLevels(segs) {\r\n    var levels = [];\r\n    var i;\r\n    var seg;\r\n    var j;\r\n    for (i = 0; i < segs.length; i++) {\r\n        seg = segs[i];\r\n        // go through all the levels and stop on the first level where there are no collisions\r\n        for (j = 0; j < levels.length; j++) {\r\n            if (!computeSlotSegCollisions(seg, levels[j]).length) {\r\n                break;\r\n            }\r\n        }\r\n        seg.level = j;\r\n        (levels[j] || (levels[j] = [])).push(seg);\r\n    }\r\n    return levels;\r\n}\r\n// For every segment, figure out the other segments that are in subsequent\r\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\r\nfunction computeForwardSlotSegs(levels) {\r\n    var i;\r\n    var level;\r\n    var j;\r\n    var seg;\r\n    var k;\r\n    for (i = 0; i < levels.length; i++) {\r\n        level = levels[i];\r\n        for (j = 0; j < level.length; j++) {\r\n            seg = level[j];\r\n            seg.forwardSegs = [];\r\n            for (k = i + 1; k < levels.length; k++) {\r\n                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\r\n            }\r\n        }\r\n    }\r\n}\r\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\r\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\r\nfunction computeSlotSegPressures(seg) {\r\n    var forwardSegs = seg.forwardSegs;\r\n    var forwardPressure = 0;\r\n    var i;\r\n    var forwardSeg;\r\n    if (seg.forwardPressure === undefined) {\r\n        for (i = 0; i < forwardSegs.length; i++) {\r\n            forwardSeg = forwardSegs[i];\r\n            // figure out the child's maximum forward path\r\n            computeSlotSegPressures(forwardSeg);\r\n            // either use the existing maximum, or use the child's forward pressure\r\n            // plus one (for the forwardSeg itself)\r\n            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\r\n        }\r\n        seg.forwardPressure = forwardPressure;\r\n    }\r\n}\r\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\r\n// Append into an optionally-supplied `results` array and return.\r\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\r\n    if (results === void 0) { results = []; }\r\n    for (var i = 0; i < otherSegs.length; i++) {\r\n        if (isSlotSegCollision(seg, otherSegs[i])) {\r\n            results.push(otherSegs[i]);\r\n        }\r\n    }\r\n    return results;\r\n}\r\n// Do these segments occupy the same vertical space?\r\nfunction isSlotSegCollision(seg1, seg2) {\r\n    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\r\n}\r\n\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nvar TimeGridHelperRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridHelperRenderer, _super);\r\n    function TimeGridHelperRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        var helperNodes = [];\r\n        var i;\r\n        var seg;\r\n        var sourceEl;\r\n        // TODO: not good to call eventRenderer this way\r\n        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);\r\n        // Try to make the segment that is in the same row as sourceSeg look the same\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            if (sourceSeg && sourceSeg.col === seg.col) {\r\n                sourceEl = sourceSeg.el;\r\n                seg.el.css({\r\n                    left: sourceEl.css('left'),\r\n                    right: sourceEl.css('right'),\r\n                    'margin-left': sourceEl.css('margin-left'),\r\n                    'margin-right': sourceEl.css('margin-right')\r\n                });\r\n            }\r\n            helperNodes.push(seg.el[0]);\r\n        }\r\n        return $(helperNodes); // must return the elements rendered\r\n    };\r\n    return TimeGridHelperRenderer;\r\n}(HelperRenderer_1.default));\r\nexports.default = TimeGridHelperRenderer;\r\n\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nvar TimeGridFillRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TimeGridFillRenderer, _super);\r\n    function TimeGridFillRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        var timeGrid = this.component;\r\n        var containerEls;\r\n        // TODO: more efficient lookup\r\n        if (type === 'bgEvent') {\r\n            containerEls = timeGrid.bgContainerEls;\r\n        }\r\n        else if (type === 'businessHours') {\r\n            containerEls = timeGrid.businessContainerEls;\r\n        }\r\n        else if (type === 'highlight') {\r\n            containerEls = timeGrid.highlightContainerEls;\r\n        }\r\n        timeGrid.updateSegVerticals(segs);\r\n        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\r\n        return segs.map(function (seg) {\r\n            return seg.el[0];\r\n        });\r\n    };\r\n    return TimeGridFillRenderer;\r\n}(FillRenderer_1.default));\r\nexports.default = TimeGridFillRenderer;\r\n\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* A rectangular panel that is absolutely positioned over other content\r\n------------------------------------------------------------------------------------------------------------------------\r\nOptions:\r\n  - className (string)\r\n  - content (HTML string or jQuery element set)\r\n  - parentEl\r\n  - top\r\n  - left\r\n  - right (the x coord of where the right edge should be. not a \"CSS\" right)\r\n  - autoHide (boolean)\r\n  - show (callback)\r\n  - hide (callback)\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar ListenerMixin_1 = __webpack_require__(7);\r\nvar Popover = /** @class */ (function () {\r\n    function Popover(options) {\r\n        this.isHidden = true;\r\n        this.margin = 10; // the space required between the popover and the edges of the scroll container\r\n        this.options = options || {};\r\n    }\r\n    // Shows the popover on the specified position. Renders it if not already\r\n    Popover.prototype.show = function () {\r\n        if (this.isHidden) {\r\n            if (!this.el) {\r\n                this.render();\r\n            }\r\n            this.el.show();\r\n            this.position();\r\n            this.isHidden = false;\r\n            this.trigger('show');\r\n        }\r\n    };\r\n    // Hides the popover, through CSS, but does not remove it from the DOM\r\n    Popover.prototype.hide = function () {\r\n        if (!this.isHidden) {\r\n            this.el.hide();\r\n            this.isHidden = true;\r\n            this.trigger('hide');\r\n        }\r\n    };\r\n    // Creates `this.el` and renders content inside of it\r\n    Popover.prototype.render = function () {\r\n        var _this = this;\r\n        var options = this.options;\r\n        this.el = $('<div class=\"fc-popover\"/>')\r\n            .addClass(options.className || '')\r\n            .css({\r\n            // position initially to the top left to avoid creating scrollbars\r\n            top: 0,\r\n            left: 0\r\n        })\r\n            .append(options.content)\r\n            .appendTo(options.parentEl);\r\n        // when a click happens on anything inside with a 'fc-close' className, hide the popover\r\n        this.el.on('click', '.fc-close', function () {\r\n            _this.hide();\r\n        });\r\n        if (options.autoHide) {\r\n            this.listenTo($(document), 'mousedown', this.documentMousedown);\r\n        }\r\n    };\r\n    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\r\n    Popover.prototype.documentMousedown = function (ev) {\r\n        // only hide the popover if the click happened outside the popover\r\n        if (this.el && !$(ev.target).closest(this.el).length) {\r\n            this.hide();\r\n        }\r\n    };\r\n    // Hides and unregisters any handlers\r\n    Popover.prototype.removeElement = function () {\r\n        this.hide();\r\n        if (this.el) {\r\n            this.el.remove();\r\n            this.el = null;\r\n        }\r\n        this.stopListeningTo($(document), 'mousedown');\r\n    };\r\n    // Positions the popover optimally, using the top/left/right options\r\n    Popover.prototype.position = function () {\r\n        var options = this.options;\r\n        var origin = this.el.offsetParent().offset();\r\n        var width = this.el.outerWidth();\r\n        var height = this.el.outerHeight();\r\n        var windowEl = $(window);\r\n        var viewportEl = util_1.getScrollParent(this.el);\r\n        var viewportTop;\r\n        var viewportLeft;\r\n        var viewportOffset;\r\n        var top; // the \"position\" (not \"offset\") values for the popover\r\n        var left; //\r\n        // compute top and left\r\n        top = options.top || 0;\r\n        if (options.left !== undefined) {\r\n            left = options.left;\r\n        }\r\n        else if (options.right !== undefined) {\r\n            left = options.right - width; // derive the left value from the right value\r\n        }\r\n        else {\r\n            left = 0;\r\n        }\r\n        if (viewportEl.is(window) || viewportEl.is(document)) {\r\n            viewportEl = windowEl;\r\n            viewportTop = 0; // the window is always at the top left\r\n            viewportLeft = 0; // (and .offset() won't work if called here)\r\n        }\r\n        else {\r\n            viewportOffset = viewportEl.offset();\r\n            viewportTop = viewportOffset.top;\r\n            viewportLeft = viewportOffset.left;\r\n        }\r\n        // if the window is scrolled, it causes the visible area to be further down\r\n        viewportTop += windowEl.scrollTop();\r\n        viewportLeft += windowEl.scrollLeft();\r\n        // constrain to the view port. if constrained by two edges, give precedence to top/left\r\n        if (options.viewportConstrain !== false) {\r\n            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\r\n            top = Math.max(top, viewportTop + this.margin);\r\n            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\r\n            left = Math.max(left, viewportLeft + this.margin);\r\n        }\r\n        this.el.css({\r\n            top: top - origin.top,\r\n            left: left - origin.left\r\n        });\r\n    };\r\n    // Triggers a callback. Calls a function in the option hash of the same name.\r\n    // Arguments beyond the first `name` are forwarded on.\r\n    // TODO: better code reuse for this. Repeat code\r\n    Popover.prototype.trigger = function (name) {\r\n        if (this.options[name]) {\r\n            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\r\n        }\r\n    };\r\n    return Popover;\r\n}());\r\nexports.default = Popover;\r\nListenerMixin_1.default.mixInto(Popover);\r\n\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\n/* Event-rendering methods for the DayGrid class\r\n----------------------------------------------------------------------------------------------------------------------*/\r\nvar DayGridEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridEventRenderer, _super);\r\n    function DayGridEventRenderer(dayGrid, fillRenderer) {\r\n        var _this = _super.call(this, dayGrid, fillRenderer) || this;\r\n        _this.dayGrid = dayGrid;\r\n        return _this;\r\n    }\r\n    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {\r\n        // don't render timed background events\r\n        eventRanges = $.grep(eventRanges, function (eventRange) {\r\n            return eventRange.eventDef.isAllDay();\r\n        });\r\n        _super.prototype.renderBgRanges.call(this, eventRanges);\r\n    };\r\n    // Renders the given foreground event segments onto the grid\r\n    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        var rowStructs = this.rowStructs = this.renderSegRows(segs);\r\n        // append to each row's content skeleton\r\n        this.dayGrid.rowEls.each(function (i, rowNode) {\r\n            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);\r\n        });\r\n    };\r\n    // Unrenders all currently rendered foreground event segments\r\n    DayGridEventRenderer.prototype.unrenderFgSegs = function () {\r\n        var rowStructs = this.rowStructs || [];\r\n        var rowStruct;\r\n        while ((rowStruct = rowStructs.pop())) {\r\n            rowStruct.tbodyEl.remove();\r\n        }\r\n        this.rowStructs = null;\r\n    };\r\n    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\r\n    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\r\n    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\r\n    DayGridEventRenderer.prototype.renderSegRows = function (segs) {\r\n        var rowStructs = [];\r\n        var segRows;\r\n        var row;\r\n        segRows = this.groupSegRows(segs); // group into nested arrays\r\n        // iterate each row of segment groupings\r\n        for (row = 0; row < segRows.length; row++) {\r\n            rowStructs.push(this.renderSegRow(row, segRows[row]));\r\n        }\r\n        return rowStructs;\r\n    };\r\n    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\r\n    // the segments. Returns object with a bunch of internal data about how the render was calculated.\r\n    // NOTE: modifies rowSegs\r\n    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\r\n        var colCnt = this.dayGrid.colCnt;\r\n        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\r\n        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\r\n        var tbody = $('<tbody/>');\r\n        var segMatrix = []; // lookup for which segments are rendered into which level+col cells\r\n        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\r\n        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\r\n        var i;\r\n        var levelSegs;\r\n        var col;\r\n        var tr;\r\n        var j;\r\n        var seg;\r\n        var td;\r\n        // populates empty cells from the current column (`col`) to `endCol`\r\n        function emptyCellsUntil(endCol) {\r\n            while (col < endCol) {\r\n                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\r\n                td = (loneCellMatrix[i - 1] || [])[col];\r\n                if (td) {\r\n                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);\r\n                }\r\n                else {\r\n                    td = $('<td/>');\r\n                    tr.append(td);\r\n                }\r\n                cellMatrix[i][col] = td;\r\n                loneCellMatrix[i][col] = td;\r\n                col++;\r\n            }\r\n        }\r\n        for (i = 0; i < levelCnt; i++) {\r\n            levelSegs = segLevels[i];\r\n            col = 0;\r\n            tr = $('<tr/>');\r\n            segMatrix.push([]);\r\n            cellMatrix.push([]);\r\n            loneCellMatrix.push([]);\r\n            // levelCnt might be 1 even though there are no actual levels. protect against this.\r\n            // this single empty row is useful for styling.\r\n            if (levelSegs) {\r\n                for (j = 0; j < levelSegs.length; j++) {\r\n                    seg = levelSegs[j];\r\n                    emptyCellsUntil(seg.leftCol);\r\n                    // create a container that occupies or more columns. append the event element.\r\n                    td = $('<td class=\"fc-event-container\"/>').append(seg.el);\r\n                    if (seg.leftCol !== seg.rightCol) {\r\n                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);\r\n                    }\r\n                    else {\r\n                        loneCellMatrix[i][col] = td;\r\n                    }\r\n                    while (col <= seg.rightCol) {\r\n                        cellMatrix[i][col] = td;\r\n                        segMatrix[i][col] = seg;\r\n                        col++;\r\n                    }\r\n                    tr.append(td);\r\n                }\r\n            }\r\n            emptyCellsUntil(colCnt); // finish off the row\r\n            this.dayGrid.bookendCells(tr);\r\n            tbody.append(tr);\r\n        }\r\n        return {\r\n            row: row,\r\n            tbodyEl: tbody,\r\n            cellMatrix: cellMatrix,\r\n            segMatrix: segMatrix,\r\n            segLevels: segLevels,\r\n            segs: rowSegs\r\n        };\r\n    };\r\n    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\r\n    // NOTE: modifies segs\r\n    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\r\n        var levels = [];\r\n        var i;\r\n        var seg;\r\n        var j;\r\n        // Give preference to elements with certain criteria, so they have\r\n        // a chance to be closer to the top.\r\n        this.sortEventSegs(segs);\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\r\n            for (j = 0; j < levels.length; j++) {\r\n                if (!isDaySegCollision(seg, levels[j])) {\r\n                    break;\r\n                }\r\n            }\r\n            // `j` now holds the desired subrow index\r\n            seg.level = j;\r\n            // create new level array if needed and append segment\r\n            (levels[j] || (levels[j] = [])).push(seg);\r\n        }\r\n        // order segments left-to-right. very important if calendar is RTL\r\n        for (j = 0; j < levels.length; j++) {\r\n            levels[j].sort(compareDaySegCols);\r\n        }\r\n        return levels;\r\n    };\r\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\r\n    DayGridEventRenderer.prototype.groupSegRows = function (segs) {\r\n        var segRows = [];\r\n        var i;\r\n        for (i = 0; i < this.dayGrid.rowCnt; i++) {\r\n            segRows.push([]);\r\n        }\r\n        for (i = 0; i < segs.length; i++) {\r\n            segRows[segs[i].row].push(segs[i]);\r\n        }\r\n        return segRows;\r\n    };\r\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\r\n    };\r\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\r\n    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\r\n        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\r\n    };\r\n    // Builds the HTML to be used for the default element for an individual segment\r\n    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {\r\n        var view = this.view;\r\n        var eventDef = seg.footprint.eventDef;\r\n        var isAllDay = seg.footprint.componentFootprint.isAllDay;\r\n        var isDraggable = view.isEventDefDraggable(eventDef);\r\n        var isResizableFromStart = !disableResizing && isAllDay &&\r\n            seg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n        var isResizableFromEnd = !disableResizing && isAllDay &&\r\n            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));\r\n        var timeHtml = '';\r\n        var timeText;\r\n        var titleHtml;\r\n        classes.unshift('fc-day-grid-event', 'fc-h-event');\r\n        // Only display a timed events time if it is the starting segment\r\n        if (seg.isStart) {\r\n            timeText = this.getTimeText(seg.footprint);\r\n            if (timeText) {\r\n                timeHtml = '<span class=\"fc-time\">' + util_1.htmlEscape(timeText) + '</span>';\r\n            }\r\n        }\r\n        titleHtml =\r\n            '<span class=\"fc-title\">' +\r\n                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\r\n                '</span>';\r\n        return '<a class=\"' + classes.join(' ') + '\"' +\r\n            (eventDef.url ?\r\n                ' href=\"' + util_1.htmlEscape(eventDef.url) + '\"' :\r\n                '') +\r\n            (skinCss ?\r\n                ' style=\"' + skinCss + '\"' :\r\n                '') +\r\n            '>' +\r\n            '<div class=\"fc-content\">' +\r\n            (this.dayGrid.isRTL ?\r\n                titleHtml + ' ' + timeHtml : // put a natural space in between\r\n                timeHtml + ' ' + titleHtml //\r\n            ) +\r\n            '</div>' +\r\n            (isResizableFromStart ?\r\n                '<div class=\"fc-resizer fc-start-resizer\" />' :\r\n                '') +\r\n            (isResizableFromEnd ?\r\n                '<div class=\"fc-resizer fc-end-resizer\" />' :\r\n                '') +\r\n            '</a>';\r\n    };\r\n    return DayGridEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = DayGridEventRenderer;\r\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\r\nfunction isDaySegCollision(seg, otherSegs) {\r\n    var i;\r\n    var otherSeg;\r\n    for (i = 0; i < otherSegs.length; i++) {\r\n        otherSeg = otherSegs[i];\r\n        if (otherSeg.leftCol <= seg.rightCol &&\r\n            otherSeg.rightCol >= seg.leftCol) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// A cmp function for determining the leftmost event\r\nfunction compareDaySegCols(a, b) {\r\n    return a.leftCol - b.leftCol;\r\n}\r\n\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar HelperRenderer_1 = __webpack_require__(58);\r\nvar DayGridHelperRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridHelperRenderer, _super);\r\n    function DayGridHelperRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\r\n    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {\r\n        var helperNodes = [];\r\n        var rowStructs;\r\n        // TODO: not good to call eventRenderer this way\r\n        rowStructs = this.eventRenderer.renderSegRows(segs);\r\n        // inject each new event skeleton into each associated row\r\n        this.component.rowEls.each(function (row, rowNode) {\r\n            var rowEl = $(rowNode); // the .fc-row\r\n            var skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\r\n            var skeletonTopEl;\r\n            var skeletonTop;\r\n            // If there is an original segment, match the top position. Otherwise, put it at the row's top level\r\n            if (sourceSeg && sourceSeg.row === row) {\r\n                skeletonTop = sourceSeg.el.position().top;\r\n            }\r\n            else {\r\n                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');\r\n                if (!skeletonTopEl.length) {\r\n                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');\r\n                }\r\n                skeletonTop = skeletonTopEl.position().top;\r\n            }\r\n            skeletonEl.css('top', skeletonTop)\r\n                .find('table')\r\n                .append(rowStructs[row].tbodyEl);\r\n            rowEl.append(skeletonEl);\r\n            helperNodes.push(skeletonEl[0]);\r\n        });\r\n        return $(helperNodes); // must return the elements rendered\r\n    };\r\n    return DayGridHelperRenderer;\r\n}(HelperRenderer_1.default));\r\nexports.default = DayGridHelperRenderer;\r\n\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar FillRenderer_1 = __webpack_require__(57);\r\nvar DayGridFillRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DayGridFillRenderer, _super);\r\n    function DayGridFillRenderer() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.fillSegTag = 'td'; // override the default tag name\r\n        return _this;\r\n    }\r\n    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {\r\n        var nodes = [];\r\n        var i;\r\n        var seg;\r\n        var skeletonEl;\r\n        for (i = 0; i < segs.length; i++) {\r\n            seg = segs[i];\r\n            skeletonEl = this.renderFillRow(type, seg);\r\n            this.component.rowEls.eq(seg.row).append(skeletonEl);\r\n            nodes.push(skeletonEl[0]);\r\n        }\r\n        return nodes;\r\n    };\r\n    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\r\n    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\r\n        var colCnt = this.component.colCnt;\r\n        var startCol = seg.leftCol;\r\n        var endCol = seg.rightCol + 1;\r\n        var className;\r\n        var skeletonEl;\r\n        var trEl;\r\n        if (type === 'businessHours') {\r\n            className = 'bgevent';\r\n        }\r\n        else {\r\n            className = type.toLowerCase();\r\n        }\r\n        skeletonEl = $('<div class=\"fc-' + className + '-skeleton\">' +\r\n            '<table><tr/></table>' +\r\n            '</div>');\r\n        trEl = skeletonEl.find('tr');\r\n        if (startCol > 0) {\r\n            trEl.append('<td colspan=\"' + startCol + '\"/>');\r\n        }\r\n        trEl.append(seg.el.attr('colspan', endCol - startCol));\r\n        if (endCol < colCnt) {\r\n            trEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\r\n        }\r\n        this.component.bookendCells(trEl);\r\n        return skeletonEl;\r\n    };\r\n    return DayGridFillRenderer;\r\n}(FillRenderer_1.default));\r\nexports.default = DayGridFillRenderer;\r\n\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar BasicViewDateProfileGenerator_1 = __webpack_require__(228);\r\nvar UnzonedRange_1 = __webpack_require__(5);\r\nvar MonthViewDateProfileGenerator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MonthViewDateProfileGenerator, _super);\r\n    function MonthViewDateProfileGenerator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Computes the date range that will be rendered.\r\n    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);\r\n        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n        var rowCnt;\r\n        // ensure 6 weeks\r\n        if (this.opt('fixedWeekCount')) {\r\n            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\r\n            end.diff(start, 'weeks', true) // dontRound=true\r\n            );\r\n            end.add(6 - rowCnt, 'weeks');\r\n        }\r\n        return new UnzonedRange_1.default(start, end);\r\n    };\r\n    return MonthViewDateProfileGenerator;\r\n}(BasicViewDateProfileGenerator_1.default));\r\nexports.default = MonthViewDateProfileGenerator;\r\n\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar util_1 = __webpack_require__(4);\r\nvar EventRenderer_1 = __webpack_require__(42);\r\nvar ListEventRenderer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListEventRenderer, _super);\r\n    function ListEventRenderer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ListEventRenderer.prototype.renderFgSegs = function (segs) {\r\n        if (!segs.length) {\r\n            this.component.renderEmptyMessage();\r\n        }\r\n        else {\r\n            this.component.renderSegList(segs);\r\n        }\r\n    };\r\n    // generates the HTML for a single event row\r\n    ListEventRenderer.prototype.fgSegHtml = function (seg) {\r\n        var view = this.view;\r\n        var calendar = view.calendar;\r\n        var theme = calendar.theme;\r\n        var eventFootprint = seg.footprint;\r\n        var eventDef = eventFootprint.eventDef;\r\n        var componentFootprint = eventFootprint.componentFootprint;\r\n        var url = eventDef.url;\r\n        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));\r\n        var bgColor = this.getBgColor(eventDef);\r\n        var timeHtml;\r\n        if (componentFootprint.isAllDay) {\r\n            timeHtml = view.getAllDayHtml();\r\n        }\r\n        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n            if (seg.isStart || seg.isEnd) {\r\n                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));\r\n            }\r\n            else {\r\n                timeHtml = view.getAllDayHtml();\r\n            }\r\n        }\r\n        else {\r\n            // Display the normal time text for the *event's* times\r\n            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));\r\n        }\r\n        if (url) {\r\n            classes.push('fc-has-url');\r\n        }\r\n        return '<tr class=\"' + classes.join(' ') + '\">' +\r\n            (this.displayEventTime ?\r\n                '<td class=\"fc-list-item-time ' + theme.getClass('widgetContent') + '\">' +\r\n                    (timeHtml || '') +\r\n                    '</td>' :\r\n                '') +\r\n            '<td class=\"fc-list-item-marker ' + theme.getClass('widgetContent') + '\">' +\r\n            '<span class=\"fc-event-dot\"' +\r\n            (bgColor ?\r\n                ' style=\"background-color:' + bgColor + '\"' :\r\n                '') +\r\n            '></span>' +\r\n            '</td>' +\r\n            '<td class=\"fc-list-item-title ' + theme.getClass('widgetContent') + '\">' +\r\n            '<a' + (url ? ' href=\"' + util_1.htmlEscape(url) + '\"' : '') + '>' +\r\n            util_1.htmlEscape(eventDef.title || '') +\r\n            '</a>' +\r\n            '</td>' +\r\n            '</tr>';\r\n    };\r\n    // like \"4:00am\"\r\n    ListEventRenderer.prototype.computeEventTimeFormat = function () {\r\n        return this.opt('mediumTimeFormat');\r\n    };\r\n    return ListEventRenderer;\r\n}(EventRenderer_1.default));\r\nexports.default = ListEventRenderer;\r\n\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar $ = __webpack_require__(3);\r\nvar EventPointing_1 = __webpack_require__(59);\r\nvar ListEventPointing = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ListEventPointing, _super);\r\n    function ListEventPointing() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // for events with a url, the whole <tr> should be clickable,\r\n    // but it's impossible to wrap with an <a> tag. simulate this.\r\n    ListEventPointing.prototype.handleClick = function (seg, ev) {\r\n        var url;\r\n        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action\r\n        // not clicking on or within an <a> with an href\r\n        if (!$(ev.target).closest('a[href]').length) {\r\n            url = seg.footprint.eventDef.url;\r\n            if (url && !ev.isDefaultPrevented()) {\r\n                window.location.href = url; // simulate link click\r\n            }\r\n        }\r\n    };\r\n    return ListEventPointing;\r\n}(EventPointing_1.default));\r\nexports.default = ListEventPointing;\r\n\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EventSourceParser_1 = __webpack_require__(38);\r\nvar ArrayEventSource_1 = __webpack_require__(52);\r\nvar FuncEventSource_1 = __webpack_require__(215);\r\nvar JsonFeedEventSource_1 = __webpack_require__(216);\r\nEventSourceParser_1.default.registerClass(ArrayEventSource_1.default);\r\nEventSourceParser_1.default.registerClass(FuncEventSource_1.default);\r\nEventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);\r\n\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ThemeRegistry_1 = __webpack_require__(51);\r\nvar StandardTheme_1 = __webpack_require__(213);\r\nvar JqueryUiTheme_1 = __webpack_require__(214);\r\nvar Bootstrap3Theme_1 = __webpack_require__(258);\r\nvar Bootstrap4Theme_1 = __webpack_require__(259);\r\nThemeRegistry_1.defineThemeSystem('standard', StandardTheme_1.default);\r\nThemeRegistry_1.defineThemeSystem('jquery-ui', JqueryUiTheme_1.default);\r\nThemeRegistry_1.defineThemeSystem('bootstrap3', Bootstrap3Theme_1.default);\r\nThemeRegistry_1.defineThemeSystem('bootstrap4', Bootstrap4Theme_1.default);\r\n\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar Bootstrap3Theme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Bootstrap3Theme, _super);\r\n    function Bootstrap3Theme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Bootstrap3Theme;\r\n}(Theme_1.default));\r\nexports.default = Bootstrap3Theme;\r\nBootstrap3Theme.prototype.classes = {\r\n    widget: 'fc-bootstrap3',\r\n    tableGrid: 'table-bordered',\r\n    tableList: 'table',\r\n    tableListHeading: 'active',\r\n    buttonGroup: 'btn-group',\r\n    button: 'btn btn-default',\r\n    stateActive: 'active',\r\n    stateDisabled: 'disabled',\r\n    today: 'alert alert-info',\r\n    popover: 'panel panel-default',\r\n    popoverHeader: 'panel-heading',\r\n    popoverContent: 'panel-body',\r\n    // day grid\r\n    // for left/right border color when border is inset from edges (all-day in agenda view)\r\n    // avoid `panel` class b/c don't want margins/radius. only border color.\r\n    headerRow: 'panel-default',\r\n    dayRow: 'panel-default',\r\n    // list view\r\n    listView: 'panel panel-default'\r\n};\r\nBootstrap3Theme.prototype.baseIconClass = 'glyphicon';\r\nBootstrap3Theme.prototype.iconClasses = {\r\n    close: 'glyphicon-remove',\r\n    prev: 'glyphicon-chevron-left',\r\n    next: 'glyphicon-chevron-right',\r\n    prevYear: 'glyphicon-backward',\r\n    nextYear: 'glyphicon-forward'\r\n};\r\nBootstrap3Theme.prototype.iconOverrideOption = 'bootstrapGlyphicons';\r\nBootstrap3Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';\r\nBootstrap3Theme.prototype.iconOverridePrefix = 'glyphicon-';\r\n\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(2);\r\nvar Theme_1 = __webpack_require__(19);\r\nvar Bootstrap4Theme = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Bootstrap4Theme, _super);\r\n    function Bootstrap4Theme() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Bootstrap4Theme;\r\n}(Theme_1.default));\r\nexports.default = Bootstrap4Theme;\r\nBootstrap4Theme.prototype.classes = {\r\n    widget: 'fc-bootstrap4',\r\n    tableGrid: 'table-bordered',\r\n    tableList: 'table',\r\n    tableListHeading: 'table-active',\r\n    buttonGroup: 'btn-group',\r\n    button: 'btn btn-primary',\r\n    stateActive: 'active',\r\n    stateDisabled: 'disabled',\r\n    today: 'alert alert-info',\r\n    popover: 'card card-primary',\r\n    popoverHeader: 'card-header',\r\n    popoverContent: 'card-body',\r\n    // day grid\r\n    // for left/right border color when border is inset from edges (all-day in agenda view)\r\n    // avoid `table` class b/c don't want margins/padding/structure. only border color.\r\n    headerRow: 'table-bordered',\r\n    dayRow: 'table-bordered',\r\n    // list view\r\n    listView: 'card card-primary'\r\n};\r\nBootstrap4Theme.prototype.baseIconClass = 'fa';\r\nBootstrap4Theme.prototype.iconClasses = {\r\n    close: 'fa-times',\r\n    prev: 'fa-chevron-left',\r\n    next: 'fa-chevron-right',\r\n    prevYear: 'fa-angle-double-left',\r\n    nextYear: 'fa-angle-double-right'\r\n};\r\nBootstrap4Theme.prototype.iconOverrideOption = 'bootstrapFontAwesome';\r\nBootstrap4Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';\r\nBootstrap4Theme.prototype.iconOverridePrefix = 'fa-';\r\n\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar BasicView_1 = __webpack_require__(62);\r\nvar MonthView_1 = __webpack_require__(229);\r\nViewRegistry_1.defineView('basic', {\r\n    'class': BasicView_1.default\r\n});\r\nViewRegistry_1.defineView('basicDay', {\r\n    type: 'basic',\r\n    duration: { days: 1 }\r\n});\r\nViewRegistry_1.defineView('basicWeek', {\r\n    type: 'basic',\r\n    duration: { weeks: 1 }\r\n});\r\nViewRegistry_1.defineView('month', {\r\n    'class': MonthView_1.default,\r\n    duration: { months: 1 },\r\n    defaults: {\r\n        fixedWeekCount: true\r\n    }\r\n});\r\n\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar AgendaView_1 = __webpack_require__(226);\r\nViewRegistry_1.defineView('agenda', {\r\n    'class': AgendaView_1.default,\r\n    defaults: {\r\n        allDaySlot: true,\r\n        slotDuration: '00:30:00',\r\n        slotEventOverlap: true // a bad name. confused with overlap/constraint system\r\n    }\r\n});\r\nViewRegistry_1.defineView('agendaDay', {\r\n    type: 'agenda',\r\n    duration: { days: 1 }\r\n});\r\nViewRegistry_1.defineView('agendaWeek', {\r\n    type: 'agenda',\r\n    duration: { weeks: 1 }\r\n});\r\n\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ViewRegistry_1 = __webpack_require__(22);\r\nvar ListView_1 = __webpack_require__(230);\r\nViewRegistry_1.defineView('list', {\r\n    'class': ListView_1.default,\r\n    buttonTextKey: 'list',\r\n    defaults: {\r\n        buttonText: 'list',\r\n        listDayFormat: 'LL',\r\n        noEventsMessage: 'No events to display'\r\n    }\r\n});\r\nViewRegistry_1.defineView('listDay', {\r\n    type: 'list',\r\n    duration: { days: 1 },\r\n    defaults: {\r\n        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\r\n    }\r\n});\r\nViewRegistry_1.defineView('listWeek', {\r\n    type: 'list',\r\n    duration: { weeks: 1 },\r\n    defaults: {\r\n        listDayFormat: 'dddd',\r\n        listDayAltFormat: 'LL'\r\n    }\r\n});\r\nViewRegistry_1.defineView('listMonth', {\r\n    type: 'list',\r\n    duration: { month: 1 },\r\n    defaults: {\r\n        listDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n    }\r\n});\r\nViewRegistry_1.defineView('listYear', {\r\n    type: 'list',\r\n    duration: { year: 1 },\r\n    defaults: {\r\n        listDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n    }\r\n});\r\n\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qcz9hMjVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRnVsbENhbGVuZGFyIHYzLjkuMFxuICogRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuICogKGMpIDIwMTggQWRhbSBTaGF3XG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIm1vbWVudFwiKSwgcmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJtb21lbnRcIiwgXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRnVsbENhbGVuZGFyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibW9tZW50XCIpLCByZXF1aXJlKFwianF1ZXJ5XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJGdWxsQ2FsZW5kYXJcIl0gPSBmYWN0b3J5KHJvb3RbXCJtb21lbnRcIl0sIHJvb3RbXCJqUXVlcnlcIl0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMzYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXHJcbmRlcml2ZWQgZnJvbTpcclxuaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC90c2xpYi9ibG9iL3YxLjYuMC90c2xpYi5qc1xyXG5cbm9ubHkgaW5jbHVkZSB0aGUgaGVscGVycyB3ZSBuZWVkLCB0byBrZWVwIGRvd24gZmlsZXNpemVcclxuKi9cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYilcclxuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSlcclxuICAgICAgICAgICAgZFtwXSA9IGJbcF07IH07XHJcbmV4cG9ydHMuX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gR2l2ZW4gdGhlIHNjcm9sbGJhciB3aWR0aHMgb2Ygc29tZSBvdGhlciBjb250YWluZXIsIGNyZWF0ZSBib3JkZXJzL21hcmdpbnMgb24gcm93RWxzIGluIG9yZGVyIHRvIG1hdGNoIHRoZSBsZWZ0XHJcbi8vIGFuZCByaWdodCBzcGFjZSB0aGF0IHdhcyBvZmZzZXQgYnkgdGhlIHNjcm9sbGJhcnMuIEEgMS1waXhlbCBib3JkZXIgZmlyc3QsIHRoZW4gbWFyZ2luIGJleW9uZCB0aGF0LlxyXG5mdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKSB7XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcclxuICAgICAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAgICAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ21hcmdpbi1sZWZ0Jzogc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0Jzogc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29tcGVuc2F0ZVNjcm9sbCA9IGNvbXBlbnNhdGVTY3JvbGw7XHJcbi8vIFVuZG9lcyBjb21wZW5zYXRlU2Nyb2xsIGFuZCByZXN0b3JlcyBhbGwgYm9yZGVycy9tYXJnaW5zXHJcbmZ1bmN0aW9uIHVuY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMpIHtcclxuICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICdtYXJnaW4tbGVmdCc6ICcnLFxyXG4gICAgICAgICdtYXJnaW4tcmlnaHQnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogJydcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5jb21wZW5zYXRlU2Nyb2xsID0gdW5jb21wZW5zYXRlU2Nyb2xsO1xyXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcclxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcclxuICAgICQoJ2JvZHknKS5hZGRDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcclxufVxyXG5leHBvcnRzLmRpc2FibGVDdXJzb3IgPSBkaXNhYmxlQ3Vyc29yO1xyXG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcclxuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlQ3Vyc29yID0gZW5hYmxlQ3Vyc29yO1xyXG4vLyBHaXZlbiBhIHRvdGFsIGF2YWlsYWJsZSBoZWlnaHQgdG8gZmlsbCwgaGF2ZSBgZWxzYCAoZXNzZW50aWFsbHkgY2hpbGQgcm93cykgZXhwYW5kIHRvIGFjY29tb2RhdGUuXHJcbi8vIEJ5IGRlZmF1bHQsIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gdGhlIHJlY29tbWVuZGVkIGhlaWdodCBhcmUgZXhwYW5kZWQgdW5pZm9ybWx5LCBub3QgY29uc2lkZXJpbmdcclxuLy8gYW55IG90aGVyIGVscyB0aGF0IGFyZSBhbHJlYWR5IHRvbyB0YWxsLiBpZiBgc2hvdWxkUmVkaXN0cmlidXRlYCBpcyBvbiwgaXQgY29uc2lkZXJzIHRoZXNlIHRhbGwgcm93cyBhbmRcclxuLy8gcmVkdWNlcyB0aGUgYXZhaWxhYmxlIGhlaWdodC5cclxuZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAvLyAqRkxPT1JJTkcgTk9URSo6IHdlIGZsb29yIGluIGNlcnRhaW4gcGxhY2VzIGJlY2F1c2Ugem9vbSBjYW4gZ2l2ZSBpbmFjY3VyYXRlIGZsb2F0aW5nLXBvaW50IGRpbWVuc2lvbnMsXHJcbiAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXHJcbiAgICB2YXIgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZWxzLmxlbmd0aCk7IC8vIGZvciBub24tbGFzdCBlbGVtZW50XHJcbiAgICB2YXIgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChlbHMubGVuZ3RoIC0gMSkpOyAvLyBmb3IgbGFzdCBlbGVtZW50ICpGTE9PUklORyBOT1RFKlxyXG4gICAgdmFyIGZsZXhFbHMgPSBbXTsgLy8gZWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBleHBhbmQuIGFycmF5IG9mIERPTSBub2Rlc1xyXG4gICAgdmFyIGZsZXhPZmZzZXRzID0gW107IC8vIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBpdCB0YWtlcyB1cFxyXG4gICAgdmFyIGZsZXhIZWlnaHRzID0gW107IC8vIGFjdHVhbCBjc3MgaGVpZ2h0XHJcbiAgICB2YXIgdXNlZEhlaWdodCA9IDA7XHJcbiAgICB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuICAgIC8vIGZpbmQgZWxlbWVudHMgdGhhdCBhcmUgYmVsb3cgdGhlIHJlY29tbWVuZGVkIGhlaWdodCAoZXhwYW5kYWJsZSkuXHJcbiAgICAvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cclxuICAgIGVscy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgIHZhciBtaW5PZmZzZXQgPSBpID09PSBlbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSk7XHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgZmxleEVscy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgZmxleE9mZnNldHMucHVzaChuYXR1cmFsT2Zmc2V0KTtcclxuICAgICAgICAgICAgZmxleEhlaWdodHMucHVzaCgkKGVsKS5oZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgc3RyZXRjaGVzIHBhc3QgcmVjb21tZW5kZWQgaGVpZ2h0IChub24tZXhwYW5kYWJsZSkuIG1hcmsgdGhlIHNwYWNlIGFzIG9jY3VwaWVkLlxyXG4gICAgICAgICAgICB1c2VkSGVpZ2h0ICs9IG5hdHVyYWxPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyByZWFkanVzdCB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IHRvIG9ubHkgY29uc2lkZXIgdGhlIGhlaWdodCBhdmFpbGFibGUgdG8gbm9uLW1heGVkLW91dCByb3dzLlxyXG4gICAgaWYgKHNob3VsZFJlZGlzdHJpYnV0ZSkge1xyXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSB1c2VkSGVpZ2h0O1xyXG4gICAgICAgIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGZsZXhFbHMubGVuZ3RoKTtcclxuICAgICAgICBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGZsZXhFbHMubGVuZ3RoIC0gMSkpOyAvLyAqRkxPT1JJTkcgTk9URSpcclxuICAgIH1cclxuICAgIC8vIGFzc2lnbiBoZWlnaHRzIHRvIGFsbCBleHBhbmRhYmxlIGVsZW1lbnRzXHJcbiAgICAkKGZsZXhFbHMpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGZsZXhFbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gZmxleE9mZnNldHNbaV07XHJcbiAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSBmbGV4SGVpZ2h0c1tpXTtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gbWluT2Zmc2V0IC0gKG5hdHVyYWxPZmZzZXQgLSBuYXR1cmFsSGVpZ2h0KTsgLy8gc3VidHJhY3QgdGhlIG1hcmdpbi9wYWRkaW5nXHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgJChlbCkuaGVpZ2h0KG5ld0hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaXN0cmlidXRlSGVpZ2h0ID0gZGlzdHJpYnV0ZUhlaWdodDtcclxuLy8gVW5kb2VzIGRpc3RydWJ1dGVIZWlnaHQsIHJlc3RvcmluZyBhbGwgZWxzIHRvIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XHJcbmZ1bmN0aW9uIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpIHtcclxuICAgIGVscy5oZWlnaHQoJycpO1xyXG59XHJcbmV4cG9ydHMudW5kaXN0cmlidXRlSGVpZ2h0ID0gdW5kaXN0cmlidXRlSGVpZ2h0O1xyXG4vLyBHaXZlbiBgZWxzYCwgYSBqUXVlcnkgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXHJcbi8vIGNlbGxzIHRvIGJlIHRoYXQgd2lkdGguXHJcbi8vIFBSRVJFUVVJU0lURTogaWYgeW91IHdhbnQgYSBjZWxsIHRvIHRha2UgdXAgd2lkdGgsIGl0IG5lZWRzIHRvIGhhdmUgYSBzaW5nbGUgaW5uZXIgZWxlbWVudCB3LyBkaXNwbGF5OmlubGluZVxyXG5mdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XHJcbiAgICB2YXIgbWF4SW5uZXJXaWR0aCA9IDA7XHJcbiAgICBlbHMuZmluZCgnPiAqJykuZWFjaChmdW5jdGlvbiAoaSwgaW5uZXJFbCkge1xyXG4gICAgICAgIHZhciBpbm5lcldpZHRoID0gJChpbm5lckVsKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgaWYgKGlubmVyV2lkdGggPiBtYXhJbm5lcldpZHRoKSB7XHJcbiAgICAgICAgICAgIG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbWF4SW5uZXJXaWR0aCsrOyAvLyBzb21ldGltZXMgbm90IGFjY3VyYXRlIG9mIHdpZHRoIHRoZSB0ZXh0IG5lZWRzIHRvIHN0YXkgb24gb25lIGxpbmUuIGluc3VyYW5jZVxyXG4gICAgZWxzLndpZHRoKG1heElubmVyV2lkdGgpO1xyXG4gICAgcmV0dXJuIG1heElubmVyV2lkdGg7XHJcbn1cclxuZXhwb3J0cy5tYXRjaENlbGxXaWR0aHMgPSBtYXRjaENlbGxXaWR0aHM7XHJcbi8vIEdpdmVuIG9uZSBlbGVtZW50IHRoYXQgcmVzaWRlcyBpbnNpZGUgYW5vdGhlcixcclxuLy8gU3VidHJhY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGVsZW1lbnQgZnJvbSB0aGUgb3V0ZXIgZWxlbWVudC5cclxuZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcclxuICAgIHZhciBib3RoID0gb3V0ZXJFbC5hZGQoaW5uZXJFbCk7XHJcbiAgICB2YXIgZGlmZjtcclxuICAgIC8vIGVmZmluJyBJRTgvOS8xMC8xMSBzb21ldGltZXMgcmV0dXJucyAwIGZvciBkaW1lbnNpb25zLiB0aGlzIHdlaXJkIGhhY2sgd2FzIHRoZSBvbmx5IHRoaW5nIHRoYXQgd29ya2VkXHJcbiAgICBib3RoLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgbGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxyXG4gICAgfSk7XHJcbiAgICBkaWZmID0gb3V0ZXJFbC5vdXRlckhlaWdodCgpIC0gaW5uZXJFbC5vdXRlckhlaWdodCgpOyAvLyBncmFiIHRoZSBkaW1lbnNpb25zXHJcbiAgICBib3RoLmNzcyh7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfSk7IC8vIHVuZG8gaGFja1xyXG4gICAgcmV0dXJuIGRpZmY7XHJcbn1cclxuZXhwb3J0cy5zdWJ0cmFjdElubmVyRWxIZWlnaHQgPSBzdWJ0cmFjdElubmVyRWxIZWlnaHQ7XHJcbi8qIEVsZW1lbnQgR2VvbSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi8xLjExLjAvdWkvY29yZS5qcyNMNTFcclxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBlbC5jc3MoJ3Bvc2l0aW9uJyk7XHJcbiAgICB2YXIgc2Nyb2xsUGFyZW50ID0gZWwucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9ICQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QocGFyZW50LmNzcygnb3ZlcmZsb3cnKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXknKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXgnKSk7XHJcbiAgICB9KS5lcSgwKTtcclxuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZWxbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XHJcbn1cclxuZXhwb3J0cy5nZXRTY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQ7XHJcbi8vIFF1ZXJpZXMgdGhlIG91dGVyIGJvdW5kaW5nIGFyZWEgb2YgYSBqUXVlcnkgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0T3V0ZXJSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcclxuICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsLm91dGVyV2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLm91dGVySGVpZ2h0KClcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRPdXRlclJlY3QgPSBnZXRPdXRlclJlY3Q7XHJcbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3Njcm9sbGJhcnMgb2YgYSBqUXVlcnkgZWxlbWVudC4gRG9lcyBub3QgZ28gd2l0aGluIHRoZSBwYWRkaW5nLlxyXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cclxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxyXG4vLyBXQVJOSU5HOiBnaXZlbiBlbGVtZW50IGNhbid0IGhhdmUgYm9yZGVyc1xyXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXHJcbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xyXG4gICAgdmFyIHNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocyhlbCk7XHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgZWxbMF0uY2xpZW50SGVpZ2h0IC8vIGNsaWVudEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0O1xyXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9wYWRkaW5nIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIEFzc3VtZWQgbm90IHRvIGhhdmUgc2Nyb2xsYmFycy5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpOyAvLyBqdXN0IG91dHNpZGUgb2YgYm9yZGVyLCBtYXJnaW4gbm90IGluY2x1ZGVkXHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLWxlZnQnKSAtXHJcbiAgICAgICAgKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLXRvcCcpIC1cclxuICAgICAgICAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgZWwud2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLmhlaWdodCgpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSBnZXRDb250ZW50UmVjdDtcclxuLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgbGVmdC9yaWdodC90b3AvYm90dG9tIHNjcm9sbGJhciB3aWR0aHMgZm9yIHRoZSBnaXZlbiBqUXVlcnkgZWxlbWVudC5cclxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnMgKHdoaWNoIHdpbGwgY2F1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHRvIGJlIGxhcmdlcikuXHJcbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cclxuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKSB7XHJcbiAgICB2YXIgbGVmdFJpZ2h0V2lkdGggPSBlbFswXS5vZmZzZXRXaWR0aCAtIGVsWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIGJvdHRvbVdpZHRoID0gZWxbMF0ub2Zmc2V0SGVpZ2h0IC0gZWxbMF0uY2xpZW50SGVpZ2h0O1xyXG4gICAgdmFyIHdpZHRocztcclxuICAgIGxlZnRSaWdodFdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChsZWZ0UmlnaHRXaWR0aCk7XHJcbiAgICBib3R0b21XaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgoYm90dG9tV2lkdGgpO1xyXG4gICAgd2lkdGhzID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IGJvdHRvbVdpZHRoIH07XHJcbiAgICBpZiAoZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpICYmIGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSB7XHJcbiAgICAgICAgd2lkdGhzLmxlZnQgPSBsZWZ0UmlnaHRXaWR0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRocztcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcclxuLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gZ2V0U2Nyb2xsYmFyV2lkdGhzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cclxuLy8gcmV0aW5hIGRpc3BsYXlzLCByb3VuZGluZywgYW5kIElFMTEuIE1hc3NhZ2UgdGhlbSBpbnRvIGEgdXNhYmxlIHZhbHVlLlxyXG5mdW5jdGlvbiBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKHdpZHRoKSB7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXHJcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59XHJcbi8vIExvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiwgd2hlbiB0aGUgZWxlbWVudCBpcyByaWdodC10by1sZWZ0LCB0aGUgc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgc2lkZVxyXG52YXIgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgaWYgKF9pc0xlZnRSdGxTY3JvbGxiYXJzID09PSBudWxsKSB7XHJcbiAgICAgICAgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc0xlZnRSdGxTY3JvbGxiYXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgdmFyIGVsID0gJCgnPGRpdj48ZGl2Lz48L2Rpdj4nKVxyXG4gICAgICAgIC5jc3Moe1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogLTEwMDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXHJcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xyXG4gICAgfSlcclxuICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKTtcclxuICAgIHZhciBpbm5lckVsID0gZWwuY2hpbGRyZW4oKTtcclxuICAgIHZhciByZXMgPSBpbm5lckVsLm9mZnNldCgpLmxlZnQgPiBlbC5vZmZzZXQoKS5sZWZ0OyAvLyBpcyB0aGUgaW5uZXIgZGl2IHNoaWZ0ZWQgdG8gYWNjb21tb2RhdGUgYSBsZWZ0IHNjcm9sbGJhcj9cclxuICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vLyBSZXRyaWV2ZXMgYSBqUXVlcnkgZWxlbWVudCdzIGNvbXB1dGVkIENTUyB2YWx1ZSBhcyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cclxuLy8gSWYgdGhlIHF1ZXJpZWQgdmFsdWUgaXMgbm9uLW51bWVyaWMgKGV4OiBJRSBjYW4gcmV0dXJuIFwibWVkaXVtXCIgZm9yIGJvcmRlciB3aWR0aCksIHdpbGwganVzdCByZXR1cm4gemVyby5cclxuZnVuY3Rpb24gZ2V0Q3NzRmxvYXQoZWwsIHByb3ApIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KGVsLmNzcyhwcm9wKSkgfHwgMDtcclxufVxyXG4vKiBNb3VzZSAvIFRvdWNoIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXHJcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XHJcbiAgICByZXR1cm4gZXYud2hpY2ggPT09IDEgJiYgIWV2LmN0cmxLZXk7XHJcbn1cclxuZXhwb3J0cy5pc1ByaW1hcnlNb3VzZUJ1dHRvbiA9IGlzUHJpbWFyeU1vdXNlQnV0dG9uO1xyXG5mdW5jdGlvbiBnZXRFdlgoZXYpIHtcclxuICAgIHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xyXG4gICAgLy8gb24gbW9iaWxlIEZGLCBwYWdlWCBmb3IgdG91Y2ggZXZlbnRzIGlzIHByZXNlbnQsIGJ1dCBpbmNvcnJlY3QsXHJcbiAgICAvLyBzbywgbG9vayBhdCB0b3VjaCBjb29yZGluYXRlcyBmaXJzdC5cclxuICAgIGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXYucGFnZVg7XHJcbn1cclxuZXhwb3J0cy5nZXRFdlggPSBnZXRFdlg7XHJcbmZ1bmN0aW9uIGdldEV2WShldikge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcbiAgICAvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcclxuICAgIC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hlc1swXS5wYWdlWTtcclxuICAgIH1cclxuICAgIHJldHVybiBldi5wYWdlWTtcclxufVxyXG5leHBvcnRzLmdldEV2WSA9IGdldEV2WTtcclxuZnVuY3Rpb24gZ2V0RXZJc1RvdWNoKGV2KSB7XHJcbiAgICByZXR1cm4gL150b3VjaC8udGVzdChldi50eXBlKTtcclxufVxyXG5leHBvcnRzLmdldEV2SXNUb3VjaCA9IGdldEV2SXNUb3VjaDtcclxuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xyXG4gICAgZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXHJcbiAgICAgICAgLm9uKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5leHBvcnRzLnByZXZlbnRTZWxlY3Rpb24gPSBwcmV2ZW50U2VsZWN0aW9uO1xyXG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xyXG4gICAgZWwucmVtb3ZlQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXHJcbiAgICAgICAgLm9mZignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IGFsbG93U2VsZWN0aW9uO1xyXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cclxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbn1cclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xyXG4vKiBHZW5lcmFsIEdlb21ldHJ5IFV0aWxzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxyXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcclxuICAgIHZhciByZXMgPSB7XHJcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXHJcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXHJcbiAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXHJcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSlcclxuICAgIH07XHJcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcclxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG5mdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludCwgcmVjdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSlcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jb25zdHJhaW5Qb2ludCA9IGNvbnN0cmFpblBvaW50O1xyXG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcclxuZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXHJcbiAgICAgICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0UmVjdENlbnRlciA9IGdldFJlY3RDZW50ZXI7XHJcbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxyXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXHJcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRpZmZQb2ludHMgPSBkaWZmUG9pbnRzO1xyXG4vKiBPYmplY3QgT3JkZXJpbmcgYnkgRmllbGRcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xyXG4gICAgdmFyIHNwZWNzID0gW107XHJcbiAgICB2YXIgdG9rZW5zID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cclxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzcGVjcztcclxufVxyXG5leHBvcnRzLnBhcnNlRmllbGRTcGVjcyA9IHBhcnNlRmllbGRTcGVjcztcclxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjaykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY21wO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjc1tpXSwgb2JqMWZhbGxiYWNrLCBvYmoyZmFsbGJhY2spO1xyXG4gICAgICAgIGlmIChjbXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjaykge1xyXG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajEsIG9iajIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZhbDEgPSBvYmoxW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB2YXIgdmFsMiA9IG9iajJbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIGlmICh2YWwxID09IG51bGwgJiYgb2JqMWZhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFsMSA9IG9iajFmYWxsYmFja1tmaWVsZFNwZWMuZmllbGRdO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbDIgPT0gbnVsbCAmJiBvYmoyZmFsbGJhY2spIHtcclxuICAgICAgICB2YWwyID0gb2JqMmZhbGxiYWNrW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKHZhbDEsIHZhbDIpICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IGNvbXBhcmVCeUZpZWxkU3BlYztcclxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcclxuICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmICgkLnR5cGUoYSkgPT09ICdzdHJpbmcnIHx8ICQudHlwZShiKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IGZsZXhpYmxlQ29tcGFyZTtcclxuLyogRGF0ZSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydHMuZGF5SURzID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcclxuZXhwb3J0cy51bml0c0Rlc2MgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107IC8vIGRlc2NlbmRpbmdcclxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIGludG8gYSBEdXJhdGlvbiB3aGVyZSBmdWxsLWRheXMgYXJlIHJlY29yZGVkIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgdGltZS5cclxuLy8gTW9tZW50cyB3aWxsIGhhdmUgdGhlaXIgdGltZXpvbmVzIG5vcm1hbGl6ZWQuXHJcbmZ1bmN0aW9uIGRpZmZEYXlUaW1lKGEsIGIpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgIGRheXM6IGEuY2xvbmUoKS5zdHJpcFRpbWUoKS5kaWZmKGIuY2xvbmUoKS5zdHJpcFRpbWUoKSwgJ2RheXMnKSxcclxuICAgICAgICBtczogYS50aW1lKCkgLSBiLnRpbWUoKSAvLyB0aW1lLW9mLWRheSBmcm9tIGRheSBzdGFydC4gZGlzcmVnYXJkcyB0aW1lem9uZVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaWZmRGF5VGltZSA9IGRpZmZEYXlUaW1lO1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgdmlhIHRoZWlyIHN0YXJ0LW9mLWRheSAocmVnYXJkbGVzcyBvZiB0aW1lem9uZSkuIFByb2R1Y2VzIHdob2xlLWRheSBkdXJhdGlvbnMuXHJcbmZ1bmN0aW9uIGRpZmZEYXkoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXkgPSBkaWZmRGF5O1xyXG4vLyBEaWZmcyB0d28gbW9tZW50cywgcHJvZHVjaW5nIGEgZHVyYXRpb24sIG1hZGUgb2YgYSB3aG9sZS11bml0LWluY3JlbWVudCBvZiB0aGUgZ2l2ZW4gdW5pdC4gVXNlcyByb3VuZGluZy5cclxuZnVuY3Rpb24gZGlmZkJ5VW5pdChhLCBiLCB1bml0KSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKE1hdGgucm91bmQoYS5kaWZmKGIsIHVuaXQsIHRydWUpKSwgLy8gcmV0dXJuRmxvYXQ9dHJ1ZVxyXG4gICAgdW5pdCk7XHJcbn1cclxuZXhwb3J0cy5kaWZmQnlVbml0ID0gZGlmZkJ5VW5pdDtcclxuLy8gQ29tcHV0ZXMgdGhlIHVuaXQgbmFtZSBvZiB0aGUgbGFyZ2VzdCB3aG9sZS11bml0IHBlcmlvZCBvZiB0aW1lLlxyXG4vLyBGb3IgZXhhbXBsZSwgNDggaG91cnMgd2lsbCBiZSBcImRheXNcIiB3aGVyZWFzIDQ5IGhvdXJzIHdpbGwgYmUgXCJob3Vyc1wiLlxyXG4vLyBBY2NlcHRzIHN0YXJ0L2VuZCwgYSByYW5nZSBvYmplY3QsIG9yIGFuIG9yaWdpbmFsIGR1cmF0aW9uIG9iamVjdC5cclxuZnVuY3Rpb24gY29tcHV0ZUdyZWF0ZXN0VW5pdChzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB1bml0O1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLnVuaXRzRGVzYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHVuaXQgPSBleHBvcnRzLnVuaXRzRGVzY1tpXTtcclxuICAgICAgICB2YWwgPSBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAodmFsID49IDEgJiYgaXNJbnQodmFsKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdDsgLy8gd2lsbCBiZSBcIm1pbGxpc2Vjb25kc1wiIGlmIG5vdGhpbmcgZWxzZSBtYXRjaGVzXHJcbn1cclxuZXhwb3J0cy5jb21wdXRlR3JlYXRlc3RVbml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdDtcclxuLy8gbGlrZSBjb21wdXRlR3JlYXRlc3RVbml0LCBidXQgaGFzIHNwZWNpYWwgYWJpbGl0aWVzIHRvIGludGVycHJldCB0aGUgc291cmNlIGlucHV0IGZvciBjbHVlc1xyXG5mdW5jdGlvbiBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpIHtcclxuICAgIHZhciB1bml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdChkdXJhdGlvbik7XHJcbiAgICAvLyBwcmV2ZW50IGRheXM6NyBmcm9tIGJlaW5nIGludGVycHJldGVkIGFzIGEgd2Vla1xyXG4gICAgaWYgKHVuaXQgPT09ICd3ZWVrJyAmJiB0eXBlb2YgZHVyYXRpb25JbnB1dCA9PT0gJ29iamVjdCcgJiYgZHVyYXRpb25JbnB1dC5kYXlzKSB7XHJcbiAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXQ7XHJcbn1cclxuZXhwb3J0cy5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQgPSBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQ7XHJcbi8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgdW5pdHMgKGxpa2UgXCJob3Vyc1wiKSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXHJcbi8vIFJhbmdlIGNhbiBiZSBhIHtzdGFydCxlbmR9IG9iamVjdCwgc2VwYXJhdGUgc3RhcnQvZW5kIGFyZ3MsIG9yIGEgRHVyYXRpb24uXHJcbi8vIFJlc3VsdHMgYXJlIGJhc2VkIG9uIE1vbWVudCdzIC5hcygpIGFuZCAuZGlmZigpIG1ldGhvZHMsIHNvIHJlc3VsdHMgY2FuIGRlcGVuZCBvbiBpbnRlcm5hbCBoYW5kbGluZ1xyXG4vLyBvZiBtb250aC1kaWZmaW5nIGxvZ2ljICh3aGljaCB0ZW5kcyB0byB2YXJ5IGZyb20gdmVyc2lvbiB0byB2ZXJzaW9uKS5cclxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKGVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHN0YXJ0KSkge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5hcyh1bml0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5lbmQuZGlmZihzdGFydC5zdGFydCwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIGEgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHN0YXJ0L2VuZCBwYXJhbXMpIGJ5IGEgZHVyYXRpb25cclxuZnVuY3Rpb24gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uKHN0YXJ0LCBlbmQsIGR1cikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyO1xyXG4gICAgfVxyXG4gICAgbW9udGhzID0gZHVyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcclxuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdtb250aHMnLCB0cnVlKSAvIG1vbnRocztcclxuICAgIH1cclxuICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgJ2RheXMnLCB0cnVlKSAvIGR1ci5hc0RheXMoKTtcclxufVxyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IGRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIG9uZSBkdXJhdGlvbiBieSBhbm90aGVyXHJcbmZ1bmN0aW9uIGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihkdXIxLCBkdXIyKSB7XHJcbiAgICB2YXIgbW9udGhzMTtcclxuICAgIHZhciBtb250aHMyO1xyXG4gICAgaWYgKGR1cmF0aW9uSGFzVGltZShkdXIxKSB8fCBkdXJhdGlvbkhhc1RpbWUoZHVyMikpIHtcclxuICAgICAgICByZXR1cm4gZHVyMSAvIGR1cjI7XHJcbiAgICB9XHJcbiAgICBtb250aHMxID0gZHVyMS5hc01vbnRocygpO1xyXG4gICAgbW9udGhzMiA9IGR1cjIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMxKSA+PSAxICYmIGlzSW50KG1vbnRoczEpICYmXHJcbiAgICAgICAgTWF0aC5hYnMobW9udGhzMikgPj0gMSAmJiBpc0ludChtb250aHMyKSkge1xyXG4gICAgICAgIHJldHVybiBtb250aHMxIC8gbW9udGhzMjtcclxuICAgIH1cclxuICAgIHJldHVybiBkdXIxLmFzRGF5cygpIC8gZHVyMi5hc0RheXMoKTtcclxufVxyXG5leHBvcnRzLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbiA9IGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuLy8gSW50ZWxsaWdlbnRseSBtdWx0aXBsaWVzIGEgZHVyYXRpb24gYnkgYSBudW1iZXJcclxuZnVuY3Rpb24gbXVsdGlwbHlEdXJhdGlvbihkdXIsIG4pIHtcclxuICAgIHZhciBtb250aHM7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGR1ciAqIG4pO1xyXG4gICAgfVxyXG4gICAgbW9udGhzID0gZHVyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgbW9udGhzOiBtb250aHMgKiBuIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IGR1ci5hc0RheXMoKSAqIG4gfSk7XHJcbn1cclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gbXVsdGlwbHlEdXJhdGlvbjtcclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgZ2l2ZW4gZHVyYXRpb24gaGFzIGFueSB0aW1lIHBhcnRzIChob3Vycy9taW51dGVzL3NlY29uZHMvbXMpXHJcbmZ1bmN0aW9uIGR1cmF0aW9uSGFzVGltZShkdXIpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGR1ci5ob3VycygpIHx8IGR1ci5taW51dGVzKCkgfHwgZHVyLnNlY29uZHMoKSB8fCBkdXIubWlsbGlzZWNvbmRzKCkpO1xyXG59XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gZHVyYXRpb25IYXNUaW1lO1xyXG5mdW5jdGlvbiBpc05hdGl2ZURhdGUoaW5wdXQpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHwgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xyXG59XHJcbmV4cG9ydHMuaXNOYXRpdmVEYXRlID0gaXNOYXRpdmVEYXRlO1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBpcyBhIHRpbWUgc3RyaW5nLCBsaWtlIFwiMDY6NDA6MDBcIiBvciBcIjA2OjAwXCJcclxuZnVuY3Rpb24gaXNUaW1lU3RyaW5nKHN0cikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgL15cXGQrXFw6XFxkKyg/OlxcOlxcZCtcXC4/KD86XFxkezN9KT8pPyQvLnRlc3Qoc3RyKTtcclxufVxyXG5leHBvcnRzLmlzVGltZVN0cmluZyA9IGlzVGltZVN0cmluZztcclxuLyogTG9nZ2luZyBhbmQgRGVidWdcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmZ1bmN0aW9uIGxvZygpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmxvZyA9IGxvZztcclxuZnVuY3Rpb24gd2FybigpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxvZy5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLndhcm4gPSB3YXJuO1xyXG4vKiBHZW5lcmFsIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIGhhc093blByb3BNZXRob2QgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcclxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXHJcbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHMpIHtcclxuICAgIHZhciBkZXN0ID0ge307XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBuYW1lO1xyXG4gICAgdmFyIGNvbXBsZXhPYmpzO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgdmFsO1xyXG4gICAgdmFyIHByb3BzO1xyXG4gICAgaWYgKGNvbXBsZXhQcm9wcykge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmFtZSA9IGNvbXBsZXhQcm9wc1tpXTtcclxuICAgICAgICAgICAgY29tcGxleE9ianMgPSBbXTtcclxuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxyXG4gICAgICAgICAgICBmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcHJvcE9ianNbal1bbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxyXG4gICAgZm9yIChpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBwcm9wcyA9IHByb3BPYmpzW2ldO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufVxyXG5leHBvcnRzLm1lcmdlUHJvcHMgPSBtZXJnZVByb3BzO1xyXG5mdW5jdGlvbiBjb3B5T3duUHJvcHMoc3JjLCBkZXN0KSB7XHJcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gc3JjKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3Aoc3JjLCBuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgIGRlc3RbbmFtZV8xXSA9IHNyY1tuYW1lXzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvcHlPd25Qcm9wcyA9IGNvcHlPd25Qcm9wcztcclxuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIG5hbWUpIHtcclxuICAgIHJldHVybiBoYXNPd25Qcm9wTWV0aG9kLmNhbGwob2JqLCBuYW1lKTtcclxufVxyXG5leHBvcnRzLmhhc093blByb3AgPSBoYXNPd25Qcm9wO1xyXG5mdW5jdGlvbiBhcHBseUFsbChmdW5jdGlvbnMsIHRoaXNPYmosIGFyZ3MpIHtcclxuICAgIGlmICgkLmlzRnVuY3Rpb24oZnVuY3Rpb25zKSkge1xyXG4gICAgICAgIGZ1bmN0aW9ucyA9IFtmdW5jdGlvbnNdO1xyXG4gICAgfVxyXG4gICAgaWYgKGZ1bmN0aW9ucykge1xyXG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xyXG4gICAgICAgIHZhciByZXQgPSB2b2lkIDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXQgPSBmdW5jdGlvbnNbaV0uYXBwbHkodGhpc09iaiwgYXJncykgfHwgcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSBhcHBseUFsbDtcclxuZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmcoYXJyYXksIHRlc3RGdW5jKSB7XHJcbiAgICB2YXIgcmVtb3ZlQ250ID0gMDtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRlc3RGdW5jKGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUNudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdmVDbnQ7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVNYXRjaGluZyA9IHJlbW92ZU1hdGNoaW5nO1xyXG5mdW5jdGlvbiByZW1vdmVFeGFjdChhcnJheSwgZXhhY3RWYWwpIHtcclxuICAgIHZhciByZW1vdmVDbnQgPSAwO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZUNudDtcclxufVxyXG5leHBvcnRzLnJlbW92ZUV4YWN0ID0gcmVtb3ZlRXhhY3Q7XHJcbmZ1bmN0aW9uIGlzQXJyYXlzRXF1YWwoYTAsIGExKSB7XHJcbiAgICB2YXIgbGVuID0gYTAubGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuICE9PSBhMS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYTBbaV0gIT09IGExW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xyXG5mdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmdzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZpcnN0RGVmaW5lZCA9IGZpcnN0RGVmaW5lZDtcclxuZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XHJcbiAgICByZXR1cm4gKHMgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcclxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xyXG59XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IGh0bWxFc2NhcGU7XHJcbmZ1bmN0aW9uIHN0cmlwSHRtbEVudGl0aWVzKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyYuKj87L2csICcnKTtcclxufVxyXG5leHBvcnRzLnN0cmlwSHRtbEVudGl0aWVzID0gc3RyaXBIdG1sRW50aXRpZXM7XHJcbi8vIEdpdmVuIGEgaGFzaCBvZiBDU1MgcHJvcGVydGllcywgcmV0dXJucyBhIHN0cmluZyBvZiBDU1MuXHJcbi8vIFVzZXMgcHJvcGVydHkgbmFtZXMgYXMtaXMgKG5vIGNhbWVsLWNhc2UgY29udmVyc2lvbikuIFdpbGwgbm90IG1ha2Ugc3RhdGVtZW50cyBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxyXG5mdW5jdGlvbiBjc3NUb1N0cihjc3NQcm9wcykge1xyXG4gICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcclxuICAgICQuZWFjaChjc3NQcm9wcywgZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmFtZSArICc6JyArIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGVtZW50cy5qb2luKCc7Jyk7XHJcbn1cclxuZXhwb3J0cy5jc3NUb1N0ciA9IGNzc1RvU3RyO1xyXG4vLyBHaXZlbiBhbiBvYmplY3QgaGFzaCBvZiBIVE1MIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMsXHJcbi8vIGdlbmVyYXRlcyBhIHN0cmluZyB0aGF0IGNhbiBiZSBpbmplY3RlZCBiZXR3ZWVuIDwgPiBpbiBIVE1MXHJcbmZ1bmN0aW9uIGF0dHJzVG9TdHIoYXR0cnMpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgJC5lYWNoKGF0dHJzLCBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobmFtZSArICc9XCInICsgaHRtbEVzY2FwZSh2YWwpICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcGFydHMuam9pbignICcpO1xyXG59XHJcbmV4cG9ydHMuYXR0cnNUb1N0ciA9IGF0dHJzVG9TdHI7XHJcbmZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn1cclxuZXhwb3J0cy5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIgPSBjYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVOdW1iZXJzID0gY29tcGFyZU51bWJlcnM7XHJcbmZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgIHJldHVybiBuICUgMSA9PT0gMDtcclxufVxyXG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XHJcbi8vIFJldHVybnMgYSBtZXRob2QgYm91bmQgdG8gdGhlIGdpdmVuIG9iamVjdCBjb250ZXh0LlxyXG4vLyBKdXN0IGxpa2Ugb25lIG9mIHRoZSBqUXVlcnkucHJveHkgc2lnbmF0dXJlcywgYnV0IHdpdGhvdXQgdGhlIHVuZGVzaXJlZCBiZWhhdmlvciBvZiB0cmVhdGluZyB0aGUgc2FtZSBtZXRob2Qgd2l0aFxyXG4vLyBkaWZmZXJlbnQgY29udGV4dHMgYXMgaWRlbnRpY2FsIHdoZW4gYmluZGluZy91bmJpbmRpbmcgZXZlbnRzLlxyXG5mdW5jdGlvbiBwcm94eShvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnByb3h5ID0gcHJveHk7XHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcclxuLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxyXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcclxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvMS42LjAvdW5kZXJzY29yZS5qcyNMNzE0XHJcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xyXG4gICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgdGltZW91dDtcclxuICAgIHZhciBhcmdzO1xyXG4gICAgdmFyIGNvbnRleHQ7XHJcbiAgICB2YXIgdGltZXN0YW1wO1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xyXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICB0aW1lc3RhbXAgPSArbmV3IERhdGUoKTtcclxuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcclxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBVbnpvbmVkUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVbnpvbmVkUmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoZXNlIGludG8gZm9vdHByaW50LlxyXG4gICAgICAgIC8vIEVzcGVjaWFsbHksIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgbnVsbCBzdGFydE1zL2VuZE1zLlxyXG4gICAgICAgIHRoaXMuaXNTdGFydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChzdGFydElucHV0KSkge1xyXG4gICAgICAgICAgICBzdGFydElucHV0ID0gc3RhcnRJbnB1dC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGVuZElucHV0KSkge1xyXG4gICAgICAgICAgICBlbmRJbnB1dCA9IGVuZElucHV0LmNsb25lKCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRNcyA9IHN0YXJ0SW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kSW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRNcyA9IGVuZElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgU0lERUVGRkVDVDogd2lsbCBtdXRhdGUgZXZlbnRSYW5nZXMuXHJcbiAgICBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgVW56b25lZFJhbmdlLmludmVydFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gY29uc3RyYWludFJhbmdlLnN0YXJ0TXM7IC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkYXRlUmFuZ2U7XHJcbiAgICAgICAgLy8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxyXG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVVbnpvbmVkUmFuZ2VzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0TXMgPiBzdGFydE1zKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgZGF0ZVJhbmdlLnN0YXJ0TXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZE1zID4gc3RhcnRNcykge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IGRhdGVSYW5nZS5lbmRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgIGlmIChzdGFydE1zIDwgY29uc3RyYWludFJhbmdlLmVuZE1zKSB7XHJcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBjb25zdHJhaW50UmFuZ2UuZW5kTXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnRNcztcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmVuZE1zO1xyXG4gICAgICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBvdGhlclJhbmdlLnN0YXJ0TXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gTWF0aC5tYXgoc3RhcnRNcywgb3RoZXJSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmRNcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IG90aGVyUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IE1hdGgubWluKGVuZE1zLCBvdGhlclJhbmdlLmVuZE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRNcyA9PSBudWxsIHx8IGVuZE1zID09IG51bGwgfHwgc3RhcnRNcyA8IGVuZE1zKSB7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlID0gbmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBlbmRNcyk7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlLmlzU3RhcnQgPSB0aGlzLmlzU3RhcnQgJiYgc3RhcnRNcyA9PT0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgICAgICBuZXdSYW5nZS5pc0VuZCA9IHRoaXMuaXNFbmQgJiYgZW5kTXMgPT09IHRoaXMuZW5kTXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHNXaXRoID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBvdGhlclJhbmdlLnN0YXJ0TXMgPT0gbnVsbCB8fCB0aGlzLmVuZE1zID4gb3RoZXJSYW5nZS5zdGFydE1zKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGFydE1zID09IG51bGwgfHwgb3RoZXJSYW5nZS5lbmRNcyA9PSBudWxsIHx8IHRoaXMuc3RhcnRNcyA8IG90aGVyUmFuZ2UuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uIChpbm5lclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydE1zICE9IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydE1zID49IHRoaXMuc3RhcnRNcykpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmVuZE1zID09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kTXMgIT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZE1zIDw9IHRoaXMuZW5kTXMpKTtcclxuICAgIH07XHJcbiAgICAvLyBgZGF0ZWAgY2FuIGJlIGEgbW9tZW50LCBhIERhdGUsIG9yIGEgbWlsbGlzZWNvbmQgdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgbXMgPSBkYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IG1zID49IHRoaXMuc3RhcnRNcykgJiZcclxuICAgICAgICAgICAgKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBtcyA8IHRoaXMuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cclxuICAgIC8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxyXG4gICAgLy8gYGRhdGVgIGNhbiBiZSBhIG1vbWVudCwgYSBEYXRlLCBvciBhIG1pbGxpc2Vjb25kIHRpbWUuXHJcbiAgICAvLyBSZXR1cm5zIGEgTVMtdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29uc3RyYWluRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIG1zID0gZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRNcyAhPSBudWxsICYmIG1zIDwgdGhpcy5zdGFydE1zKSB7XHJcbiAgICAgICAgICAgIG1zID0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsICYmIG1zID49IHRoaXMuZW5kTXMpIHtcclxuICAgICAgICAgICAgbXMgPSB0aGlzLmVuZE1zIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1zO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE1zID09PSBvdGhlclJhbmdlLnN0YXJ0TXMgJiYgdGhpcy5lbmRNcyA9PT0gb3RoZXJSYW5nZS5lbmRNcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2UodGhpcy5zdGFydE1zLCB0aGlzLmVuZE1zKTtcclxuICAgICAgICByYW5nZS5pc1N0YXJ0ID0gdGhpcy5pc1N0YXJ0O1xyXG4gICAgICAgIHJhbmdlLmlzRW5kID0gdGhpcy5pc0VuZDtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhbiBhbWJpZy16b25lZCBtb21lbnQgZnJvbSBzdGFydE1zLlxyXG4gICAgLy8gQkVXQVJFOiByZXR1cm5lZCBtb21lbnQgaXMgbm90IGxvY2FsaXplZC5cclxuICAgIC8vIEZvcm1hdHRpbmcgYW5kIHN0YXJ0LW9mLXdlZWsgd2lsbCBiZSBkZWZhdWx0LlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5nZXRTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyh0aGlzLnN0YXJ0TXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGFuIGFtYmlnLXpvbmVkIG1vbWVudCBmcm9tIHN0YXJ0TXMuXHJcbiAgICAvLyBCRVdBUkU6IHJldHVybmVkIG1vbWVudCBpcyBub3QgbG9jYWxpemVkLlxyXG4gICAgLy8gRm9ybWF0dGluZyBhbmQgc3RhcnQtb2Ytd2VlayB3aWxsIGJlIGRlZmF1bHQuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGModGhpcy5lbmRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuYXMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQudXRjKHRoaXMuZW5kTXMpLmRpZmYobW9tZW50LnV0Yyh0aGlzLnN0YXJ0TXMpLCB1bml0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW56b25lZFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVbnpvbmVkUmFuZ2U7XHJcbi8qXHJcbk9ubHkgd29ya3MgZm9yIG5vbi1vcGVuLWVuZGVkIHJhbmdlcy5cclxuKi9cclxuZnVuY3Rpb24gY29tcGFyZVVuem9uZWRSYW5nZXMocmFuZ2UxLCByYW5nZTIpIHtcclxuICAgIHJldHVybiByYW5nZTEuc3RhcnRNcyAtIHJhbmdlMi5zdGFydE1zOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDgpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG52YXIgRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIC8vIGNhbiB3ZSBkbyBhd2F5IHdpdGggY2FsZW5kYXI/IGF0IGxlYXN0IGZvciB0aGUgYWJzdHJhY3Q/XHJcbiAgICAvLyB1c2VmdWwgZm9yIGJ1aWxkRXZlbnREZWZcclxuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhFdmVudFNvdXJjZS51dWlkKyspO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICByYXdJbnB1dCBjYW4gYmUgYW55IGRhdGEgdHlwZSFcclxuICAgICovXHJcbiAgICBFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gbmV3IHRoaXMoY2FsZW5kYXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3SW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuYXBwbHlQcm9wcyhyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLm5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50LiBtdXN0IHJldHVybiBhIHByb21pc2UuXHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEZvciBjb21wYWlyaW5nL21hdGNoaW5nXHJcbiAgICAqL1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChvdGhlclNvdXJjZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucGFyc2VFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmID0gdGhpcy5wYXJzZUV2ZW50RGVmKHJhd0V2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudERlZnM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnBhcnNlRXZlbnREZWYgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXJUcmFuc2Zvcm0gPSB0aGlzLmNhbGVuZGFyLm9wdCgnZXZlbnREYXRhVHJhbnNmb3JtJyk7XHJcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybSA9IHRoaXMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmIChjYWxlbmRhclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IGNhbGVuZGFyVHJhbnNmb3JtKHJhd0lucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IHNvdXJjZVRyYW5zZm9ybShyYXdJbnB1dCwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3SW5wdXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAocmF3UHJvcHMuaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQocmF3UHJvcHMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50RGVmXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS51dWlkID0gMDtcclxuICAgIEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudFNvdXJjZS5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgcmV0dXJuIEV2ZW50U291cmNlO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFNvdXJjZTtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50U291cmNlKTtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBtYW51YWxseSBwcm9jZXNzLi4uXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSB0cmFuc2Zlci4uLlxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBvdmVybGFwOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIGFsbERheURlZmF1bHQ6IHRydWUsXHJcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IHRydWVcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcclxuVXRpbGl0eSBtZXRob2RzIGZvciBlYXNpbHkgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiBhbm90aGVyIG9iamVjdCxcclxuYW5kIG1vcmUgaW1wb3J0YW50bHksIGVhc2lseSB1bmxpc3RlbmluZyBmcm9tIHRoZW0uXHJcblxuVVNBR0U6XHJcbiAgaW1wb3J0IHsgZGVmYXVsdCBhcyBMaXN0ZW5lck1peGluLCBMaXN0ZW5lckludGVyZmFjZSB9IGZyb20gJy4vTGlzdGVuZXJNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgbGlzdGVuVG86IExpc3RlbmVySW50ZXJmYWNlWydsaXN0ZW5UbyddXHJcbiAgc3RvcExpc3RlbmluZ1RvOiBMaXN0ZW5lckludGVyZmFjZVsnc3RvcExpc3RlbmluZ1RvJ11cclxuYWZ0ZXIgY2xhc3M6XHJcbiAgTGlzdGVuZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgZ3VpZCA9IDA7XHJcbnZhciBMaXN0ZW5lck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdGVuZXJNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RlbmVyTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEdpdmVuIGFuIGBvdGhlcmAgb2JqZWN0IHRoYXQgaGFzIG9uL29mZiBtZXRob2RzLCBiaW5kIHRoZSBnaXZlbiBgY2FsbGJhY2tgIHRvIGFuIGV2ZW50IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgVGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXHJcbiAgICBDYW4gYmUgY2FsbGVkOlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIGV2ZW50TmFtZSwgY2FsbGJhY2spXHJcbiAgICBPUlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIHtcclxuICAgICAgICBldmVudE5hbWUxOiBjYWxsYmFjazEsXHJcbiAgICAgICAgZXZlbnROYW1lMjogY2FsbGJhY2syXHJcbiAgICAgIH0pXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUubGlzdGVuVG8gPSBmdW5jdGlvbiAob3RoZXIsIGFyZywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBhcmdbZXZlbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb3RoZXIub24oYXJnICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpLCAvLyB1c2UgZXZlbnQgbmFtZXNwYWNpbmcgdG8gaWRlbnRpZnkgdGhpcyBvYmplY3RcclxuICAgICAgICAgICAgJC5wcm94eShjYWxsYmFjaywgdGhpcykgLy8gYWx3YXlzIHVzZSBgdGhpc2AgY29udGV4dFxyXG4gICAgICAgICAgICAvLyB0aGUgdXN1YWxseS11bmRlc2lyZWQgalF1ZXJ5IGd1aWQgYmVoYXZpb3IgZG9lc24ndCBtYXR0ZXIsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYWx3YXlzIHVuYmluZCB2aWEgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDYXVzZXMgdGhlIGN1cnJlbnQgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiB0aGUgYG90aGVyYCBvYmplY3QuXHJcbiAgICBgZXZlbnROYW1lYCBpcyBvcHRpb25hbC4gSWYgb21pdHRlZCwgd2lsbCBzdG9wIGxpc3RlbmluZyB0byBBTEwgZXZlbnRzIG9uIGBvdGhlcmAuXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuc3RvcExpc3RlbmluZ1RvID0gZnVuY3Rpb24gKG90aGVyLCBldmVudE5hbWUpIHtcclxuICAgICAgICBvdGhlci5vZmYoKGV2ZW50TmFtZSB8fCAnJykgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGEgc3RyaW5nLCB1bmlxdWUgdG8gdGhpcyBvYmplY3QsIHRvIGJlIHVzZWQgZm9yIGV2ZW50IG5hbWVzcGFjaW5nXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuZ2V0TGlzdGVuZXJOYW1lc3BhY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJJZCA9IGd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdfbGlzdGVuZXInICsgdGhpcy5saXN0ZW5lcklkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0ZW5lck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0ZW5lck1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA4ICovLFxuLyogOSAqLyxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBhbWJpZ0RhdGVPZk1vbnRoUmVnZXggPSAvXlxccypcXGR7NH0tXFxkXFxkJC87XHJcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9IC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XHJcbnZhciBuZXdNb21lbnRQcm90byA9IG1vbWVudC5mbjsgLy8gd2hlcmUgd2Ugd2lsbCBhdHRhY2ggb3VyIG5ldyBtZXRob2RzXHJcbmV4cG9ydHMubmV3TW9tZW50UHJvdG8gPSBuZXdNb21lbnRQcm90bztcclxudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xyXG5leHBvcnRzLm9sZE1vbWVudFByb3RvID0gb2xkTW9tZW50UHJvdG87XHJcbi8vIHRlbGwgbW9tZW50anMgdG8gdHJhbnNmZXIgdGhlc2UgcHJvcGVydGllcyB1cG9uIGNsb25lXHJcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50Lm1vbWVudFByb3BlcnRpZXM7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2Z1bGxDYWxlbmRhcicpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1RpbWUnKTtcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdab25lJyk7XHJcbi8qXHJcbkNhbGwgdGhpcyBpZiB5b3Ugd2FudCBNb21lbnQncyBvcmlnaW5hbCBmb3JtYXQgbWV0aG9kIHRvIGJlIHVzZWRcclxuKi9cclxuZnVuY3Rpb24gb2xkTW9tZW50Rm9ybWF0KG1vbSwgZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmNhbGwobW9tLCBmb3JtYXRTdHIpOyAvLyBvbGRNb21lbnRQcm90byBkZWZpbmVkIGluIG1vbWVudC1leHQuanNcclxufVxyXG5leHBvcnRzLm9sZE1vbWVudEZvcm1hdCA9IG9sZE1vbWVudEZvcm1hdDtcclxuLy8gQ3JlYXRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcclxuLy8gZXh0cmEgZmVhdHVyZXMgKGFtYmlndW91cyB0aW1lLCBlbmhhbmNlZCBmb3JtYXR0aW5nKS4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsXHJcbi8vIGl0IHdpbGwgZnVuY3Rpb24gYXMgYSBjbG9uZSAoYW5kIHJldGFpbiB0aGUgem9uZSBvZiB0aGUgbW9tZW50KS4gQW55dGhpbmcgZWxzZSB3aWxsXHJcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cclxudmFyIG1vbWVudEV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1vbWVudEV4dDtcclxuLy8gU2FtZXMgYXMgbW9tZW50RXh0LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXHJcbm1vbWVudEV4dC51dGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbW9tID0gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUpO1xyXG4gICAgLy8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XHJcbiAgICAvLyAoaWYgZ2l2ZW4gYSBwcmUtZXhpc3RpbmcgbW9tZW50IGZvciBleGFtcGxlKVxyXG4gICAgaWYgKG1vbS5oYXNUaW1lKCkpIHtcclxuICAgICAgICBtb20udXRjKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tO1xyXG59O1xyXG4vLyBTYW1lIGFzIG1vbWVudEV4dCwgYnV0IHdoZW4gZ2l2ZW4gYW4gSVNPODYwMSBzdHJpbmcsIHRoZSB0aW1lem9uZSBvZmZzZXQgaXMgcHJlc2VydmVkLlxyXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXHJcbm1vbWVudEV4dC5wYXJzZVpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUsIHRydWUpO1xyXG59O1xyXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXHJcbi8vIG5hdGl2ZSBEYXRlLCBvciBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgKHRoZSBjdXJyZW50IHRpbWUpLCB0aGUgcmVzdWx0aW5nIG1vbWVudCB3aWxsIGJlIGxvY2FsLlxyXG4vLyBBbnl0aGluZyBlbHNlIG5lZWRzIHRvIGJlIFwicGFyc2VkXCIgKGEgc3RyaW5nIG9yIGFuIGFycmF5KSwgYW5kIHdpbGwgYmUgYWZmZWN0ZWQgYnk6XHJcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cclxuLy8gICAgcGFyc2Vab25lIC0gaWYgdGhlcmUgaXMgem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIGZvcmNlIHRoZSB6b25lIG9mIHRoZSBtb21lbnQ/XHJcbmZ1bmN0aW9uIG1ha2VNb21lbnQoYXJncywgcGFyc2VBc1VUQywgcGFyc2Vab25lKSB7XHJcbiAgICBpZiAocGFyc2VBc1VUQyA9PT0gdm9pZCAwKSB7IHBhcnNlQXNVVEMgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhcnNlWm9uZSA9PT0gdm9pZCAwKSB7IHBhcnNlWm9uZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgaW5wdXQgPSBhcmdzWzBdO1xyXG4gICAgdmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcclxuICAgIHZhciBpc0FtYmlnVGltZTtcclxuICAgIHZhciBpc0FtYmlnWm9uZTtcclxuICAgIHZhciBhbWJpZ01hdGNoO1xyXG4gICAgdmFyIG1vbTtcclxuICAgIGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpIHx8IHV0aWxfMS5pc05hdGl2ZURhdGUoaW5wdXQpIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgICAgIGlzQW1iaWdab25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChhbWJpZ0RhdGVPZk1vbnRoUmVnZXgudGVzdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdCBzdHJpbmdzIGxpa2UgJzIwMTQtMDUnLCBidXQgY29udmVydCB0byB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoXHJcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnLTAxJztcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbaW5wdXRdOyAvLyBmb3Igd2hlbiB3ZSBwYXNzIGl0IG9uIHRvIG1vbWVudCdzIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKGFtYmlnTWF0Y2ggPSBhbWJpZ1RpbWVPclpvbmVSZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdUaW1lID0gIWFtYmlnTWF0Y2hbNV07IC8vIG5vIHRpbWUgcGFydD9cclxuICAgICAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIC8vIGFycmF5cyBoYXZlIG5vIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBhc3N1bWUgYW1iaWd1b3VzIHpvbmVcclxuICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UsIHByb2JhYmx5IGEgc3RyaW5nIHdpdGggYSBmb3JtYXRcclxuICAgICAgICBpZiAocGFyc2VBc1VUQyB8fCBpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQudXRjLmFwcGx5KG1vbWVudCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20uX2FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTsgLy8gYW1iaWd1b3VzIHRpbWUgYWx3YXlzIG1lYW5zIGFtYmlndW91cyB6b25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnNlWm9uZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBbWJpZ1pvbmUpIHtcclxuICAgICAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NpbmdsZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgbW9tLnV0Y09mZnNldChpbnB1dCk7IC8vIGlmIG5vdCBhIHZhbGlkIHpvbmUsIHdpbGwgYXNzaWduIFVUQ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbW9tLl9mdWxsQ2FsZW5kYXIgPSB0cnVlOyAvLyBmbGFnIGZvciBleHRlbmRlZCBmdW5jdGlvbmFsaXR5XHJcbiAgICByZXR1cm4gbW9tO1xyXG59XHJcbi8vIFdlZWsgTnVtYmVyXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmV0dXJucyB0aGUgd2VlayBudW1iZXIsIGNvbnNpZGVyaW5nIHRoZSBsb2NhbGUncyBjdXN0b20gd2VlayBudW1iZXIgY2FsY3VhdGlvblxyXG4vLyBgd2Vla3NgIGlzIGFuIGFsaWFzIGZvciBgd2Vla2BcclxubmV3TW9tZW50UHJvdG8ud2VlayA9IG5ld01vbWVudFByb3RvLndlZWtzID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICB2YXIgd2Vla0NhbGMgPSB0aGlzLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYztcclxuICAgIGlmIChpbnB1dCA9PSBudWxsICYmIHR5cGVvZiB3ZWVrQ2FsYyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiB3ZWVrQ2FsYyh0aGlzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdlZWtDYWxjID09PSAnSVNPJykge1xyXG4gICAgICAgIHJldHVybiBvbGRNb21lbnRQcm90by5pc29XZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIElTTyBnZXR0ZXIvc2V0dGVyXHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8ud2Vlay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBsb2NhbCBnZXR0ZXIvc2V0dGVyXHJcbn07XHJcbi8vIFRpbWUtb2YtZGF5XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gR0VUVEVSXHJcbi8vIFJldHVybnMgYSBEdXJhdGlvbiB3aXRoIHRoZSBob3Vycy9taW51dGVzL3NlY29uZHMvbXMgdmFsdWVzIG9mIHRoZSBtb21lbnQuXHJcbi8vIElmIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBhIGR1cmF0aW9uIG9mIDAwOjAwIHdpbGwgYmUgcmV0dXJuZWQuXHJcbi8vXHJcbi8vIFNFVFRFUlxyXG4vLyBZb3UgY2FuIHN1cHBseSBhIER1cmF0aW9uLCBhIE1vbWVudCwgb3IgYSBEdXJhdGlvbi1saWtlIGFyZ3VtZW50LlxyXG4vLyBXaGVuIHNldHRpbmcgdGhlIHRpbWUsIGFuZCB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgaXQgdGhlbiBiZWNvbWVzIHVuYW1iaWd1b3VzLlxyXG5uZXdNb21lbnRQcm90by50aW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGlmIHRoZXJlIGlzIG9uZSkgaWYgdGhpcyBtb21lbnQgd2Fzbid0IGNyZWF0ZWQgdmlhIEZ1bGxDYWxlbmRhci5cclxuICAgIC8vIGB0aW1lYCBpcyBhIGdlbmVyaWMgZW5vdWdoIG1ldGhvZCBuYW1lIHdoZXJlIHRoaXMgcHJlY2F1dGlvbiBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgY29sbGlzaW9ucyB3LyBvdGhlciBwbHVnaW5zLlxyXG4gICAgaWYgKCF0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8udGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgICAgICBob3VyczogdGhpcy5ob3VycygpLFxyXG4gICAgICAgICAgICBtaW51dGVzOiB0aGlzLm1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgc2Vjb25kczogdGhpcy5zZWNvbmRzKCksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogdGhpcy5taWxsaXNlY29uZHMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7IC8vIG1hcmsgdGhhdCB0aGUgbW9tZW50IG5vdyBoYXMgYSB0aW1lXHJcbiAgICAgICAgaWYgKCFtb21lbnQuaXNEdXJhdGlvbih0aW1lKSAmJiAhbW9tZW50LmlzTW9tZW50KHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRpbWUgPSBtb21lbnQuZHVyYXRpb24odGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBkYXkgdmFsdWUgc2hvdWxkIGNhdXNlIG92ZXJmbG93IChzbyAyNCBob3VycyBiZWNvbWVzIDAwOjAwOjAwIG9mIG5leHQgZGF5KS5cclxuICAgICAgICAvLyBPbmx5IGZvciBEdXJhdGlvbiB0aW1lcywgbm90IE1vbWVudCB0aW1lcy5cclxuICAgICAgICB2YXIgZGF5SG91cnMgPSAwO1xyXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbih0aW1lKSkge1xyXG4gICAgICAgICAgICBkYXlIb3VycyA9IE1hdGguZmxvb3IodGltZS5hc0RheXMoKSkgKiAyNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhlIGluZGl2aWR1YWwgZmllbGRzLlxyXG4gICAgICAgIC8vIENhbid0IHVzZSBzdGFydE9mKCdkYXknKSB0aGVuIGFkZCBkdXJhdGlvbi4gSW4gY2FzZSBvZiBEU1QgYXQgc3RhcnQgb2YgZGF5LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKGRheUhvdXJzICsgdGltZS5ob3VycygpKVxyXG4gICAgICAgICAgICAubWludXRlcyh0aW1lLm1pbnV0ZXMoKSlcclxuICAgICAgICAgICAgLnNlY29uZHModGltZS5zZWNvbmRzKCkpXHJcbiAgICAgICAgICAgIC5taWxsaXNlY29uZHModGltZS5taWxsaXNlY29uZHMoKSk7XHJcbiAgICB9XHJcbn07XHJcbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lLW9mLWRheSBhbmQgdGltZXpvbmUgb2Zmc2V0LFxyXG4vLyBidXQgcHJlc2VydmluZyBpdHMgWU1ELiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZSB3aWxsIGRpc3BsYXkgbm8gdGltZVxyXG4vLyBub3IgdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cclxubmV3TW9tZW50UHJvdG8uc3RyaXBUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICB0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyAqZGF0ZSogdmFsdWUpXHJcbiAgICAgICAgLy8gc2V0IHRpbWUgdG8gemVyb1xyXG4gICAgICAgIHRoaXMuc2V0KHtcclxuICAgICAgICAgICAgaG91cnM6IDAsXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IDAsXHJcbiAgICAgICAgICAgIHNlY29uZHM6IDAsXHJcbiAgICAgICAgICAgIG1zOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgdGltZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXHJcbiAgICAgICAgLy8gd2hpY2ggY2xlYXJzIGFsbCBhbWJpZyBmbGFncy5cclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7IC8vIGlmIGFtYmlndW91cyB0aW1lLCBhbHNvIGFtYmlndW91cyB0aW1lem9uZSBvZmZzZXRcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gUmV0dXJucyBpZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZSAoYm9vbGVhbilcclxubmV3TW9tZW50UHJvdG8uaGFzVGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5fYW1iaWdUaW1lO1xyXG59O1xyXG4vLyBUaW1lem9uZVxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lem9uZSBvZmZzZXQsIGJ1dCBwcmVzZXJ2aW5nIGl0c1xyXG4vLyBZTUQgYW5kIHRpbWUtb2YtZGF5LiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZXpvbmUgb2Zmc2V0IHdpbGwgZGlzcGxheSBub1xyXG4vLyB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxyXG5uZXdNb21lbnRQcm90by5zdHJpcFpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2FzQW1iaWdUaW1lO1xyXG4gICAgaWYgKCF0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICB3YXNBbWJpZ1RpbWUgPSB0aGlzLl9hbWJpZ1RpbWU7XHJcbiAgICAgICAgdGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgZGF0ZSBhbmQgdGltZSB2YWx1ZXMpXHJcbiAgICAgICAgLy8gdGhlIGFib3ZlIGNhbGwgdG8gLnV0YygpLy51dGNPZmZzZXQoKSB1bmZvcnR1bmF0ZWx5IG1pZ2h0IGNsZWFyIHRoZSBhbWJpZyBmbGFncywgc28gcmVzdG9yZVxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IHdhc0FtYmlnVGltZSB8fCBmYWxzZTtcclxuICAgICAgICAvLyBNYXJrIHRoZSB6b25lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcclxuICAgICAgICAvLyB3aGljaCBjbGVhcnMgdGhlIGFtYmlnIGZsYWdzLlxyXG4gICAgICAgIHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIFJldHVybnMgb2YgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldCAoYm9vbGVhbilcclxubmV3TW9tZW50UHJvdG8uaGFzWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5fYW1iaWdab25lO1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxyXG5uZXdNb21lbnRQcm90by5sb2NhbCA9IGZ1bmN0aW9uIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICAvLyBmb3Igd2hlbiBjb252ZXJ0aW5nIGZyb20gYW1iaWd1b3VzbHktem9uZWQgdG8gbG9jYWwsXHJcbiAgICAvLyBrZWVwIHRoZSB0aW1lIHZhbHVlcyB3aGVuIGNvbnZlcnRpbmcgZnJvbSBVVEMgLT4gbG9jYWxcclxuICAgIG9sZE1vbWVudFByb3RvLmxvY2FsLmNhbGwodGhpcywgdGhpcy5fYW1iaWdab25lIHx8IGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgLy8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcclxuICAgIC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgbG9jYWwoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXHJcbiAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxyXG5uZXdNb21lbnRQcm90by51dGMgPSBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgb2xkTW9tZW50UHJvdG8udXRjLmNhbGwodGhpcywga2VlcExvY2FsVGltZSk7XHJcbiAgICAvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xyXG4gICAgLy8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSB1dGMoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXHJcbiAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lICh3aWxsIHByb2JhYmx5IGdldCBjYWxsZWQgdXBvbiAudXRjKCkgYW5kIC5sb2NhbCgpKVxyXG5uZXdNb21lbnRQcm90by51dGNPZmZzZXQgPSBmdW5jdGlvbiAodHpvKSB7XHJcbiAgICBpZiAodHpvICE9IG51bGwpIHtcclxuICAgICAgICAvLyB0aGVzZSBhc3NpZ25tZW50cyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBvcmlnaW5hbCB6b25lIG1ldGhvZCBpcyBjYWxsZWQuXHJcbiAgICAgICAgLy8gSSBmb3JnZXQgd2h5LCBzb21ldGhpbmcgdG8gZG8gd2l0aCBhIGJyb3dzZXIgY3Jhc2guXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8udXRjT2Zmc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgRW1pdHRlck1peGluLCBFbWl0dGVySW50ZXJmYWNlIH0gZnJvbSAnLi9FbWl0dGVyTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIG9uOiBFbWl0dGVySW50ZXJmYWNlWydvbiddXHJcbiAgb25lOiBFbWl0dGVySW50ZXJmYWNlWydvbmUnXVxyXG4gIG9mZjogRW1pdHRlckludGVyZmFjZVsnb2ZmJ11cclxuICB0cmlnZ2VyOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyJ11cclxuICB0cmlnZ2VyV2l0aDogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlcldpdGgnXVxyXG4gIGhhc0hhbmRsZXJzOiBFbWl0dGVySW50ZXJmYWNlWydoYXNIYW5kbGVycyddXHJcbmFmdGVyIGNsYXNzOlxyXG4gIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgRW1pdHRlck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRW1pdHRlck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW1pdHRlck1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxyXG4gICAgLy8gdGhlIHNhbWUgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIChpbmNsdWRpbmcgbmFtZXNwYWNlcykuXHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbih0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbmUodHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLl9wcmVwYXJlSW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXHJcbiAgICAgICAgLy8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgICAgIC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXHJcbiAgICAgICAgdmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uIChldiwgZXh0cmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuYXBwbHkoZXh0cmEuY29udGV4dCB8fCB0aGlzLCBleHRyYS5hcmdzIHx8IFtdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxyXG4gICAgICAgIC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcclxuICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cclxuICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XHJcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlcywgaGFuZGxlcikge1xyXG4gICAgICAgICQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUudHJpZ2dlcldpdGggPSBmdW5jdGlvbiAodHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXHJcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgaGFzaCA9ICQuX2RhdGEodGhpcywgJ2V2ZW50cycpOyAvLyBodHRwOi8vYmxvZy5qcXVlcnkuY29tLzIwMTIvMDgvMDkvanF1ZXJ5LTEtOC1yZWxlYXNlZC9cclxuICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoW3R5cGVdICYmIGhhc2hbdHlwZV0ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1pdHRlck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypcclxuTWVhbnQgdG8gYmUgaW1tdXRhYmxlXHJcbiovXHJcbnZhciBDb21wb25lbnRGb290cHJpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnRGb290cHJpbnQodW56b25lZFJhbmdlLCBpc0FsbERheSkge1xyXG4gICAgICAgIHRoaXMuaXNBbGxEYXkgPSBmYWxzZTsgLy8gY29tcG9uZW50IGNhbiBjaG9vc2UgdG8gaWdub3JlIHRoaXNcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IHVuem9uZWRSYW5nZTtcclxuICAgICAgICB0aGlzLmlzQWxsRGF5ID0gaXNBbGxEYXk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4gICAgKi9cclxuICAgIENvbXBvbmVudEZvb3RwcmludC5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogY2FsZW5kYXIubXNUb01vbWVudCh0aGlzLnVuem9uZWRSYW5nZS5zdGFydE1zLCB0aGlzLmlzQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiBjYWxlbmRhci5tc1RvTW9tZW50KHRoaXMudW56b25lZFJhbmdlLmVuZE1zLCB0aGlzLmlzQWxsRGF5KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudEZvb3RwcmludDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50Rm9vdHByaW50O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEV2ZW50SW5zdGFuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5KTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgU2luZ2xlRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTaW5nbGVFdmVudERlZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbmdsZUV2ZW50RGVmKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBXaWxsIHJlY2VpdmUgc3RhcnQvZW5kIHBhcmFtcywgYnV0IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICovXHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmJ1aWxkSW5zdGFuY2UoKV07XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmJ1aWxkSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEluc3RhbmNlXzEuZGVmYXVsdCh0aGlzLCAvLyBkZWZpbml0aW9uXHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVQcm9maWxlLmlzQWxsRGF5KCk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWYgPSBfc3VwZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgZGVmLmRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5yZXpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5zdGFydCksIGRhdGVQcm9maWxlLmVuZCA/IGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5lbmQpIDogbnVsbCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiAgICAqL1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdC5wYXJzZShyYXdQcm9wcywgdGhpcy5zb3VyY2UpOyAvLyByZXR1cm5zIG51bGwgb24gZmFpbHVyZVxyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBgZGF0ZWAgc2hvd3MgdXAgaW4gdGhlIGxlZ2FjeSBldmVudCBvYmplY3RzIGFzLWlzXHJcbiAgICAgICAgICAgIGlmIChyYXdQcm9wcy5kYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlzY1Byb3BzLmRhdGUgPSByYXdQcm9wcy5kYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTaW5nbGVFdmVudERlZjtcclxufShFdmVudERlZl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2luZ2xlRXZlbnREZWY7XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblNpbmdsZUV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgc3RhcnQ6IGZhbHNlLFxyXG4gICAgZGF0ZTogZmFsc2UsXHJcbiAgICBlbmQ6IGZhbHNlLFxyXG4gICAgYWxsRGF5OiBmYWxzZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNaXhpbigpIHtcclxuICAgIH1cclxuICAgIE1peGluLm1peEludG8gPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBfdGhpcy5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgd2lsbCBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzXHJcbiAgICBUT0RPOiByZW1vdmUhIG5vdCB1c2VkIGFueW1vcmVcclxuICAgICovXHJcbiAgICBNaXhpbi5taXhPdmVyID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IF90aGlzLnByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWl4aW47XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNvbXBvbmVudC5fZ2V0VmlldygpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJhY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aW9uO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMudmVyc2lvbiA9ICczLjkuMCc7XHJcbi8vIFdoZW4gaW50cm9kdWNpbmcgaW50ZXJuYWwgQVBJIGluY29tcGF0aWJpbGl0aWVzICh3aGVyZSBmdWxsY2FsZW5kYXIgcGx1Z2lucyB3b3VsZCBicmVhayksXHJcbi8vIHRoZSBtaW5vciB2ZXJzaW9uIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgdXBwZWQgKGV4OiAyLjcuMiAtPiAyLjguMClcclxuLy8gYW5kIHRoZSBiZWxvdyBpbnRlZ2VyIHNob3VsZCBiZSBpbmNyZW1lbnRlZC5cclxuZXhwb3J0cy5pbnRlcm5hbEFwaVZlcnNpb24gPSAxMjtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSB1dGlsXzEuYXBwbHlBbGw7XHJcbmV4cG9ydHMuZGVib3VuY2UgPSB1dGlsXzEuZGVib3VuY2U7XHJcbmV4cG9ydHMuaXNJbnQgPSB1dGlsXzEuaXNJbnQ7XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IHV0aWxfMS5odG1sRXNjYXBlO1xyXG5leHBvcnRzLmNzc1RvU3RyID0gdXRpbF8xLmNzc1RvU3RyO1xyXG5leHBvcnRzLnByb3h5ID0gdXRpbF8xLnByb3h5O1xyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gdXRpbF8xLmdldE91dGVyUmVjdDtcclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gdXRpbF8xLmdldENsaWVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSB1dGlsXzEuZ2V0Q29udGVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocztcclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHV0aWxfMS5wcmV2ZW50RGVmYXVsdDtcclxuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSB1dGlsXzEucGFyc2VGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcztcclxuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWMgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IHV0aWxfMS5mbGV4aWJsZUNvbXBhcmU7XHJcbmV4cG9ydHMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0O1xyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IHV0aWxfMS5kaXZpZGVSYW5nZUJ5RHVyYXRpb247XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gdXRpbF8xLm11bHRpcGx5RHVyYXRpb247XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gdXRpbF8xLmR1cmF0aW9uSGFzVGltZTtcclxuZXhwb3J0cy5sb2cgPSB1dGlsXzEubG9nO1xyXG5leHBvcnRzLndhcm4gPSB1dGlsXzEud2FybjtcclxuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHV0aWxfMS5yZW1vdmVFeGFjdDtcclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IHV0aWxfMS5pbnRlcnNlY3RSZWN0cztcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdERhdGU7XHJcbmV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBkYXRlX2Zvcm1hdHRpbmdfMS5mb3JtYXRSYW5nZTtcclxuZXhwb3J0cy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBkYXRlX2Zvcm1hdHRpbmdfMS5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBsb2NhbGVfMS5kYXRlcGlja2VyTG9jYWxlO1xyXG5leHBvcnRzLmxvY2FsZSA9IGxvY2FsZV8xLmxvY2FsZTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5leHBvcnRzLm1vbWVudCA9IG1vbWVudF9leHRfMS5kZWZhdWx0O1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuZXhwb3J0cy5FbWl0dGVyTWl4aW4gPSBFbWl0dGVyTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuZXhwb3J0cy5MaXN0ZW5lck1peGluID0gTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbF8xLmRlZmF1bHQ7XHJcbnZhciBDb25zdHJhaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDcpO1xyXG5leHBvcnRzLkNvbnN0cmFpbnRzID0gQ29uc3RyYWludHNfMS5kZWZhdWx0O1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5leHBvcnRzLlVuem9uZWRSYW5nZSA9IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQ7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5leHBvcnRzLkNvbXBvbmVudEZvb3RwcmludCA9IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQ7XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcclxuZXhwb3J0cy5CdXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5leHBvcnRzLkV2ZW50RGVmID0gRXZlbnREZWZfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbmV4cG9ydHMuRXZlbnREZWZNdXRhdGlvbiA9IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5leHBvcnRzLkV2ZW50U291cmNlUGFyc2VyID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbmV4cG9ydHMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxuZXhwb3J0cy5kZWZpbmVUaGVtZVN5c3RlbSA9IFRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbmV4cG9ydHMuRXZlbnRJbnN0YW5jZUdyb3VwID0gRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdDtcclxudmFyIEFycmF5RXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5leHBvcnRzLkFycmF5RXZlbnRTb3VyY2UgPSBBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTUpO1xyXG5leHBvcnRzLkZ1bmNFdmVudFNvdXJjZSA9IEZ1bmNFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNik7XHJcbmV4cG9ydHMuSnNvbkZlZWRFdmVudFNvdXJjZSA9IEpzb25GZWVkRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5leHBvcnRzLkV2ZW50Rm9vdHByaW50ID0gRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG5leHBvcnRzLkNsYXNzID0gQ2xhc3NfMS5kZWZhdWx0O1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5leHBvcnRzLk1peGluID0gTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbmV4cG9ydHMuQ29vcmRDYWNoZSA9IENvb3JkQ2FjaGVfMS5kZWZhdWx0O1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxuZXhwb3J0cy5EcmFnTGlzdGVuZXIgPSBEcmFnTGlzdGVuZXJfMS5kZWZhdWx0O1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2VfMS5kZWZhdWx0O1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNyk7XHJcbmV4cG9ydHMuVGFza1F1ZXVlID0gVGFza1F1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbmV4cG9ydHMuUmVuZGVyUXVldWUgPSBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQ7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbmV4cG9ydHMuU2Nyb2xsZXIgPSBTY3JvbGxlcl8xLmRlZmF1bHQ7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbmV4cG9ydHMuVGhlbWUgPSBUaGVtZV8xLmRlZmF1bHQ7XHJcbnZhciBEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOSk7XHJcbmV4cG9ydHMuRGF0ZUNvbXBvbmVudCA9IERhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxuZXhwb3J0cy5JbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2FsZW5kYXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIwKTtcclxuZXhwb3J0cy5DYWxlbmRhciA9IENhbGVuZGFyXzEuZGVmYXVsdDtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG5leHBvcnRzLlZpZXcgPSBWaWV3XzEuZGVmYXVsdDtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbmV4cG9ydHMuZGVmaW5lVmlldyA9IFZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXc7XHJcbmV4cG9ydHMuZ2V0Vmlld0NvbmZpZyA9IFZpZXdSZWdpc3RyeV8xLmdldFZpZXdDb25maWc7XHJcbnZhciBEYXlUYWJsZU1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcclxuZXhwb3J0cy5EYXlUYWJsZU1peGluID0gRGF5VGFibGVNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbmV4cG9ydHMuQnVzaW5lc3NIb3VyUmVuZGVyZXIgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuZXhwb3J0cy5FdmVudFJlbmRlcmVyID0gRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG5leHBvcnRzLkZpbGxSZW5kZXJlciA9IEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbmV4cG9ydHMuSGVscGVyUmVuZGVyZXIgPSBIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMik7XHJcbmV4cG9ydHMuRXh0ZXJuYWxEcm9wcGluZyA9IEV4dGVybmFsRHJvcHBpbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSZXNpemluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjMpO1xyXG5leHBvcnRzLkV2ZW50UmVzaXppbmcgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xyXG5leHBvcnRzLkV2ZW50UG9pbnRpbmcgPSBFdmVudFBvaW50aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI0KTtcclxuZXhwb3J0cy5FdmVudERyYWdnaW5nID0gRXZlbnREcmFnZ2luZ18xLmRlZmF1bHQ7XHJcbnZhciBEYXRlU2VsZWN0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XHJcbmV4cG9ydHMuRGF0ZVNlbGVjdGluZyA9IERhdGVTZWxlY3RpbmdfMS5kZWZhdWx0O1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XHJcbmV4cG9ydHMuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiA9IFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjYpO1xyXG5leHBvcnRzLkFnZW5kYVZpZXcgPSBBZ2VuZGFWaWV3XzEuZGVmYXVsdDtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XHJcbmV4cG9ydHMuVGltZUdyaWQgPSBUaW1lR3JpZF8xLmRlZmF1bHQ7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuZXhwb3J0cy5EYXlHcmlkID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbnZhciBCYXNpY1ZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG5leHBvcnRzLkJhc2ljVmlldyA9IEJhc2ljVmlld18xLmRlZmF1bHQ7XHJcbnZhciBNb250aFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI5KTtcclxuZXhwb3J0cy5Nb250aFZpZXcgPSBNb250aFZpZXdfMS5kZWZhdWx0O1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwKTtcclxuZXhwb3J0cy5MaXN0VmlldyA9IExpc3RWaWV3XzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIEV2ZW50RGF0ZVByb2ZpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERhdGVQcm9maWxlKHN0YXJ0LCBlbmQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkVW56b25lZFJhbmdlKGNhbGVuZGFyKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBOZWVkcyBhbiBFdmVudFNvdXJjZSBvYmplY3RcclxuICAgICovXHJcbiAgICBFdmVudERhdGVQcm9maWxlLnBhcnNlID0gZnVuY3Rpb24gKHJhd1Byb3BzLCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgc3RhcnRJbnB1dCA9IHJhd1Byb3BzLnN0YXJ0IHx8IHJhd1Byb3BzLmRhdGU7XHJcbiAgICAgICAgdmFyIGVuZElucHV0ID0gcmF3UHJvcHMuZW5kO1xyXG4gICAgICAgIGlmICghc3RhcnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgc3RhcnQgPSBjYWxlbmRhci5tb21lbnQoc3RhcnRJbnB1dCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGVuZElucHV0ID8gY2FsZW5kYXIubW9tZW50KGVuZElucHV0KSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGZvcmNlZEFsbERheSA9IHJhd1Byb3BzLmFsbERheTtcclxuICAgICAgICB2YXIgZm9yY2VFdmVudER1cmF0aW9uID0gY2FsZW5kYXIub3B0KCdmb3JjZUV2ZW50RHVyYXRpb24nKTtcclxuICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgJiYgKCFlbmQuaXNWYWxpZCgpIHx8ICFlbmQuaXNBZnRlcihzdGFydCkpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JjZWRBbGxEYXkgPSBzb3VyY2UuYWxsRGF5RGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZWRBbGxEYXkgPSBjYWxlbmRhci5vcHQoJ2FsbERheURlZmF1bHQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm9yY2VkQWxsRGF5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmICFlbmQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVuZCAmJiBmb3JjZUV2ZW50RHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKCFzdGFydC5oYXNUaW1lKCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlKHN0YXJ0LCBlbmQsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICBFdmVudERhdGVQcm9maWxlLmlzU3RhbmRhcmRQcm9wID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BOYW1lID09PSAnc3RhcnQnIHx8IHByb3BOYW1lID09PSAnZGF0ZScgfHwgcHJvcE5hbWUgPT09ICdlbmQnIHx8IHByb3BOYW1lID09PSAnYWxsRGF5JztcclxuICAgIH07XHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5pc0FsbERheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISh0aGlzLnN0YXJ0Lmhhc1RpbWUoKSB8fCAodGhpcy5lbmQgJiYgdGhpcy5lbmQuaGFzVGltZSgpKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuYnVpbGRVbnpvbmVkUmFuZ2UgPSBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgdmFyIGVuZE1zID0gdGhpcy5nZXRFbmQoY2FsZW5kYXIpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnRNcywgZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOZWVkcyBhIENhbGVuZGFyIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCA/XHJcbiAgICAgICAgICAgIHRoaXMuZW5kLmNsb25lKCkgOlxyXG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGVuZCBmcm9tIHRoZSBzdGFydCBhbmQgYWxsRGF5LiBjb21wdXRlIGFsbERheSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKHRoaXMuaXNBbGxEYXkoKSwgdGhpcy5zdGFydCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGF0ZVByb2ZpbGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGF0ZVByb2ZpbGU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTEpO1xyXG4vKlxyXG5JdCdzIGV4cGVjdGVkIHRoYXQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgRXZlbnRJbnN0YW5jZSxcclxuT1IgdGhhdCBhbiBleHBsaWNpdEV2ZW50RGVmIGlzIGFzc2lnbmVkLlxyXG4qL1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlcyA9IGV2ZW50SW5zdGFuY2VzIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5nZXRBbGxFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBpZiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW52ZXJzZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBzbGljZWRSYW5nZTtcclxuICAgICAgICB2YXIgc2xpY2VkRXZlbnRSYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICBzbGljZWRSYW5nZSA9IGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlLmludGVyc2VjdChjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNsaWNlZEV2ZW50UmFuZ2VzLnB1c2gobmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHNsaWNlZFJhbmdlLCBldmVudEluc3RhbmNlLmRlZiwgZXZlbnRJbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzbGljZWRFdmVudFJhbmdlcztcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlcyA9IHRoaXMuZXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBvd25lckRlZiA9IHRoaXMuZ2V0RXZlbnREZWYoKTtcclxuICAgICAgICB1bnpvbmVkUmFuZ2VzID0gVW56b25lZFJhbmdlXzEuZGVmYXVsdC5pbnZlcnRSYW5nZXModW56b25lZFJhbmdlcywgY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICByZXR1cm4gdW56b25lZFJhbmdlcy5tYXAoZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHVuem9uZWRSYW5nZSwgb3duZXJEZWYpOyAvLyBkb24ndCBnaXZlIGFuIEV2ZW50SW5zdGFuY2VcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmlzSW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudERlZigpLmhhc0ludmVyc2VSZW5kZXJpbmcoKTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmdldEV2ZW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RXZlbnREZWYgfHwgdGhpcy5ldmVudEluc3RhbmNlc1swXS5kZWY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50SW5zdGFuY2VHcm91cDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGhlbWUob3B0aW9uc01hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gb3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzSWNvbk92ZXJyaWRlKCk7XHJcbiAgICB9XHJcbiAgICBUaGVtZS5wcm90b3R5cGUucHJvY2Vzc0ljb25PdmVycmlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUodGhpcy5vcHRpb25zTWFuYWdlci5nZXQodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XHJcbiAgICAgICAgdmFyIGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB2YXIgYnV0dG9uTmFtZTtcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGljb25PdmVycmlkZUhhc2gpKSB7XHJcbiAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9ICQuZXh0ZW5kKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcclxuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xyXG4gICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcclxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzID0gZnVuY3Rpb24gKGN1c3RvbUJ1dHRvblByb3BzKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGhlbWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRoZW1lO1xyXG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcclxuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcclxuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VTdHViID0ge1xyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlc29sdmUodmFsKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZWplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQcm9taXNlU3R1YjtcclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZXNvbHZpbmdUaGVuKHByb21pc2UsIHZhbCkge1xyXG4gICAgcHJvbWlzZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlU3R1Yi5yZXNvbHZlKG9uUmVzb2x2ZSh2YWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5leHBvcnRIb29rcy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcclxudmFyIGdsb2JhbEVtaXR0ZXIgPSBudWxsO1xyXG52YXIgbmVlZGVkQ291bnQgPSAwO1xyXG4vKlxyXG5MaXN0ZW5zIHRvIGRvY3VtZW50IGFuZCB3aW5kb3ctbGV2ZWwgdXNlci1pbnRlcmFjdGlvbiBldmVudHMsIGxpa2UgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMsXHJcbmFuZCBmaXJlcyB0aGVzZSBldmVudHMgYXMtaXMgdG8gd2hvZXZlciBpcyBvYnNlcnZpbmcgYSBHbG9iYWxFbWl0dGVyLlxyXG5CZXN0IHdoZW4gdXNlZCBhcyBhIHNpbmdsZXRvbiB2aWEgR2xvYmFsRW1pdHRlci5nZXQoKVxyXG5cbk5vcm1hbGl6ZXMgbW91c2UvdG91Y2ggZXZlbnRzLiBGb3IgZXhhbXBsZXM6XHJcbi0gaWdub3JlcyB0aGUgdGhlIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgdGhhdCBoYXBwZW4gYWZ0ZXIgYSBxdWljayB0YXA6IG1vdXNlbW92ZSttb3VzZWRvd24rbW91c2V1cCtjbGlja1xyXG4tIGNvbXBlbnNhdGVzIGZvciB2YXJpb3VzIGJ1Z2d5IHNjZW5hcmlvcyB3aGVyZSBhIHRvdWNoZW5kIGRvZXMgbm90IGZpcmVcclxuKi9cclxudmFyIEdsb2JhbEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHbG9iYWxFbWl0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2VJZ25vcmVEZXB0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBnZXRzIHRoZSBzaW5nbGV0b25cclxuICAgIEdsb2JhbEVtaXR0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghZ2xvYmFsRW1pdHRlcikge1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyID0gbmV3IEdsb2JhbEVtaXR0ZXIoKTtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnbG9iYWxFbWl0dGVyO1xyXG4gICAgfTtcclxuICAgIC8vIGNhbGxlZCB3aGVuIGFuIG9iamVjdCBrbm93cyBpdCB3aWxsIG5lZWQgYSBHbG9iYWxFbWl0dGVyIGluIHRoZSBuZWFyIGZ1dHVyZS5cclxuICAgIEdsb2JhbEVtaXR0ZXIubmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXIuZ2V0KCk7IC8vIGVuc3VyZXMgZ2xvYmFsRW1pdHRlclxyXG4gICAgICAgIG5lZWRlZENvdW50Kys7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FsbGVkIHdoZW4gdGhlIG9iamVjdCB0aGF0IG9yaWdpbmFsbHkgY2FsbGVkIG5lZWRlZCgpIGRvZXNuJ3QgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgYW55bW9yZS5cclxuICAgIEdsb2JhbEVtaXR0ZXIudW5uZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbmVlZGVkQ291bnQtLTtcclxuICAgICAgICBpZiAoIW5lZWRlZENvdW50KSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgIHRvdWNoY2FuY2VsOiB0aGlzLmhhbmRsZVRvdWNoQ2FuY2VsLFxyXG4gICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcclxuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcclxuICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgbW91c2V1cDogdGhpcy5oYW5kbGVNb3VzZVVwLFxyXG4gICAgICAgICAgICBjbGljazogdGhpcy5oYW5kbGVDbGljayxcclxuICAgICAgICAgICAgc2VsZWN0c3RhcnQ6IHRoaXMuaGFuZGxlU2VsZWN0U3RhcnQsXHJcbiAgICAgICAgICAgIGNvbnRleHRtZW51OiB0aGlzLmhhbmRsZUNvbnRleHRNZW51XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcHJldmVudERlZmF1bHRcclxuICAgICAgICAvLyBiZWNhdXNlIGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZXMvNTA5MzU2NjAwNzIxNDA4MFxyXG4gICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhpcyBpcyBhIGdsb2JhbCBoYW5kbGVyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlVG91Y2hNb3ZlKCQuRXZlbnQoZXYpKTtcclxuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0gLy8gYWxsb3dzIHByZXZlbnREZWZhdWx0KClcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZ2V0IGNhbGxlZCB3aGVuIEFOWSBzY3JvbGwgYWN0aW9uIGhhcHBlbnMgb24gdGhlIHBhZ2UuXHJcbiAgICAgICAgLy8gdGhpcyB3YXMgaW1wb3NzaWJsZSB0byBkbyB3aXRoIG5vcm1hbCBvbi9vZmYgYmVjYXVzZSAnc2Nyb2xsJyBkb2Vzbid0IGJ1YmJsZS5cclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjk1NDU2NS85NjM0MlxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbFByb3h5ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbCgkLkV2ZW50KGV2KSk7XHJcbiAgICAgICAgfSwgdHJ1ZSAvLyB1c2VDYXB0dXJlXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZVByb3h5KTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGxQcm94eSwgdHJ1ZSAvLyB1c2VDYXB0dXJlXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICAvLyBUb3VjaCBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBpZiBhIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uIG5ldmVyIGVuZGVkIHdpdGggYSB0b3VjaGVuZCwgdGhlbiBpbXBsaWNpdGx5IGVuZCBpdCxcclxuICAgICAgICAvLyBidXQgc2luY2UgYSBuZXcgdG91Y2ggaW50ZXJhY3Rpb24gaXMgYWJvdXQgdG8gYmVnaW4sIGRvbid0IHN0YXJ0IHRoZSBtb3VzZSBpZ25vcmUgcGVyaW9kLlxyXG4gICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2LCB0cnVlKTsgLy8gc2tpcE1vdXNlSWdub3JlPXRydWVcclxuICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2hzdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2htb3ZlJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaENhbmNlbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaGNhbmNlbCcsIGV2KTtcclxuICAgICAgICAgICAgLy8gSGF2ZSB0b3VjaGNhbmNlbCBmaXJlIGFuIGFydGlmaWNpYWwgdG91Y2hlbmQuIFRoYXQgd2F5LCBoYW5kbGVycyB3b24ndCBuZWVkIHRvIGxpc3RlbiB0byBib3RoLlxyXG4gICAgICAgICAgICAvLyBJZiB0b3VjaGVuZCBmaXJlcyBsYXRlciwgaXQgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IGIvYyBpc1RvdWNoaW5nIHdpbGwgYmUgZmFsc2UuXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnN0b3BUb3VjaChldik7XHJcbiAgICB9O1xyXG4gICAgLy8gTW91c2UgSGFuZGxlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlZG93bicsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNldXAnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTWlzYyBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3RzdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0TWVudSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignY29udGV4dG1lbnUnLCBldik7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzY3JvbGwnLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5zdG9wVG91Y2ggPSBmdW5jdGlvbiAoZXYsIHNraXBNb3VzZUlnbm9yZSkge1xyXG4gICAgICAgIGlmIChza2lwTW91c2VJZ25vcmUgPT09IHZvaWQgMCkgeyBza2lwTW91c2VJZ25vcmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2hlbmQnLCBldik7XHJcbiAgICAgICAgICAgIGlmICghc2tpcE1vdXNlSWdub3JlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VG91Y2hNb3VzZUlnbm9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnN0YXJ0VG91Y2hNb3VzZUlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3YWl0ID0gZXhwb3J0SG9va3MudG91Y2hNb3VzZUlnbm9yZVdhaXQ7XHJcbiAgICAgICAgaWYgKHdhaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoKys7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW91c2VJZ25vcmVEZXB0aC0tO1xyXG4gICAgICAgICAgICB9LCB3YWl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUb3VjaGluZyB8fCBCb29sZWFuKHRoaXMubW91c2VJZ25vcmVEZXB0aCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdsb2JhbEVtaXR0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdsb2JhbEVtaXR0ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oR2xvYmFsRW1pdHRlcik7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhHbG9iYWxFbWl0dGVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuZXhwb3J0cy52aWV3SGFzaCA9IHt9O1xyXG5leHBvcnRIb29rcy52aWV3cyA9IGV4cG9ydHMudmlld0hhc2g7XHJcbmZ1bmN0aW9uIGRlZmluZVZpZXcodmlld05hbWUsIHZpZXdDb25maWcpIHtcclxuICAgIGV4cG9ydHMudmlld0hhc2hbdmlld05hbWVdID0gdmlld0NvbmZpZztcclxufVxyXG5leHBvcnRzLmRlZmluZVZpZXcgPSBkZWZpbmVWaWV3O1xyXG5mdW5jdGlvbiBnZXRWaWV3Q29uZmlnKHZpZXdOYW1lKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy52aWV3SGFzaFt2aWV3TmFtZV07XHJcbn1cclxuZXhwb3J0cy5nZXRWaWV3Q29uZmlnID0gZ2V0Vmlld0NvbmZpZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxuLyogVHJhY2tzIG1vdXNlIG1vdmVtZW50cyBvdmVyIGEgY29tcG9uZW50IGFuZCByYWlzZXMgZXZlbnRzIGFib3V0IHdoaWNoIGhpdCB0aGUgbW91c2UgaXMgb3Zlci5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm9wdGlvbnM6XHJcbi0gc3ViamVjdEVsXHJcbi0gc3ViamVjdENlbnRlclxyXG4qL1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGl0RHJhZ0xpc3RlbmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGl0RHJhZ0xpc3RlbmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxyXG4gICAgLy8gZXYgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGRyYWdnaW5nIHdhcyBzdGFydGVkIG1hbnVhbGx5LlxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVjdDtcclxuICAgICAgICB2YXIgb3JpZ1BvaW50O1xyXG4gICAgICAgIHZhciBwb2ludDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIGZvciBhdXRvc2Nyb2xsXHJcbiAgICAgICAgaWYgKGV2KSB7XHJcbiAgICAgICAgICAgIG9yaWdQb2ludCA9IHsgbGVmdDogdXRpbF8xLmdldEV2WChldiksIHRvcDogdXRpbF8xLmdldEV2WShldikgfTtcclxuICAgICAgICAgICAgcG9pbnQgPSBvcmlnUG9pbnQ7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdFJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHN1YmplY3RFbCk7IC8vIHVzZWQgZm9yIGNlbnRlcmluZyBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHV0aWxfMS5jb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ0hpdCA9IHRoaXMucXVlcnlIaXQocG9pbnQubGVmdCwgcG9pbnQudG9wKTtcclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGNlbnRlciBvZiB0aGUgc3ViamVjdCBhcyB0aGUgY29sbGlzaW9uIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmIHRoaXMub3B0aW9ucy5zdWJqZWN0Q2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2tpcCB0aGlzIGlmIGhpdCBkaWRuJ3Qgc3VwcGx5IGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gdXRpbF8xLmludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0OyAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB1dGlsXzEuZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHV0aWxfMS5kaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZC4gZG8gaXQgYWZ0ZXIgb3JpZ0hpdCBoYXMgYmVlbiBjb21wdXRlZFxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYWN0dWFsIGRyYWcgaGFzIHN0YXJ0ZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAvLyBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGlzLm9yaWdIaXQgaWYgdGhlIG1pbi1kaXN0YW5jZSBpcyBsYXJnZVxyXG4gICAgICAgIGhpdCA9IHRoaXMucXVlcnlIaXQodXRpbF8xLmdldEV2WChldiksIHV0aWxfMS5nZXRFdlkoZXYpKTtcclxuICAgICAgICAvLyByZXBvcnQgdGhlIGluaXRpYWwgaGl0IHRoZSBtb3VzZSBpcyBvdmVyXHJcbiAgICAgICAgLy8gZXNwZWNpYWxseSBpbXBvcnRhbnQgaWYgbm8gbWluLWRpc3RhbmNlIGFuZCBkcmFnIHN0YXJ0cyBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnIG1vdmVzXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnLmNhbGwodGhpcywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgaGl0ID0gdGhpcy5xdWVyeUhpdCh1dGlsXzEuZ2V0RXZYKGV2KSwgdXRpbF8xLmdldEV2WShldikpO1xyXG4gICAgICAgIGlmICghaXNIaXRzRXF1YWwoaGl0LCB0aGlzLmhpdCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUhpdE91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3ZlcihoaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWdnaW5nIGhhcyBiZWVuIHN0b3BwZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdmVyIGEgbmV3IGhpdFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXRPdmVyID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBoaXQ7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdmVyJywgdGhpcy5oaXQsIGlzT3JpZywgdGhpcy5vcmlnSGl0KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdE91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdXQnLCB0aGlzLmhpdCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3BcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0RG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXREb25lJywgdGhpcy5oaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgaW50ZXJhY3Rpb24gZW5kcywgd2hldGhlciB0aGVyZSB3YXMgYSByZWFsIGRyYWcgb3Igbm90XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uRW5kID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQuY2FsbCh0aGlzLCBldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgIHRoaXMub3JpZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmhpdHNOb3ROZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIC8vIGhpdHMnIGFic29sdXRlIHBvc2l0aW9ucyB3aWxsIGJlIGluIG5ldyBwbGFjZXMgYWZ0ZXIgYSB1c2VyJ3Mgc2Nyb2xsLlxyXG4gICAgICAgIC8vIEhBQ0sgZm9yIHJlY29tcHV0aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGl0IHVuZGVybmVhdGggdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgZ2l2ZW4gbW91c2UgZXZlbnRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdCwgdG9wKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29vcmRBZGp1c3QpIHtcclxuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmNvb3JkQWRqdXN0LmxlZnQ7XHJcbiAgICAgICAgICAgIHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhpdERyYWdMaXN0ZW5lcjtcclxufShEcmFnTGlzdGVuZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEhpdERyYWdMaXN0ZW5lcjtcclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhpdHMgYXJlIGlkZW50aWNhbGx5IGVxdWFsLiBgZmFsc2VgIG90aGVyd2lzZS4gTXVzdCBiZSBmcm9tIHRoZSBzYW1lIGNvbXBvbmVudC5cclxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxyXG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XHJcbiAgICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChoaXQwICYmIGhpdDEpIHtcclxuICAgICAgICByZXR1cm4gaGl0MC5jb21wb25lbnQgPT09IGhpdDEuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgIGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcclxuICAgICAgICAgICAgaXNIaXRQcm9wc1dpdGhpbihoaXQxLCBoaXQwKTsgLy8gZW5zdXJlcyBhbGwgcHJvcHMgYXJlIGlkZW50aWNhbFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBhbGwgb2Ygc3ViSGl0J3Mgbm9uLXN0YW5kYXJkIHByb3BlcnRpZXMgYXJlIHdpdGhpbiBzdXBlckhpdFxyXG5mdW5jdGlvbiBpc0hpdFByb3BzV2l0aGluKHN1YkhpdCwgc3VwZXJIaXQpIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHN1YkhpdCkge1xyXG4gICAgICAgIGlmICghL14oY29tcG9uZW50fGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkkLy50ZXN0KHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViSGl0W3Byb3BOYW1lXSAhPT0gc3VwZXJIaXRbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyNCAqLyxcbi8qIDI1ICovLFxuLyogMjYgKi8sXG4vKiAyNyAqLyxcbi8qIDI4ICovLFxuLyogMjkgKi8sXG4vKiAzMCAqLyxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIGV4cG9ydEhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaCA9IHt9O1xyXG5leHBvcnRIb29rcy5sb2NhbGVzID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoO1xyXG4vLyBOT1RFOiBjYW4ndCBndWFyYW50ZWUgYW55IG9mIHRoZXNlIGNvbXB1dGF0aW9ucyB3aWxsIHJ1biBiZWNhdXNlIG5vdCBldmVyeSBsb2NhbGUgaGFzIGRhdGVwaWNrZXJcclxuLy8gY29uZmlncywgc28gbWFrZSBzdXJlIHRoZXJlIGFyZSBFbmdsaXNoIGZhbGxiYWNrcyBmb3IgdGhlc2UgaW4gdGhlIGRlZmF1bHRzIGZpbGUuXHJcbnZhciBkcENvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgYnV0dG9uVGV4dDogZnVuY3Rpb24gKGRwT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2xhdGlvbnMgc29tZXRpbWVzIHdyb25nbHkgY29udGFpbiBIVE1MIGVudGl0aWVzXHJcbiAgICAgICAgICAgIHByZXY6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMucHJldlRleHQpLFxyXG4gICAgICAgICAgICBuZXh0OiB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLm5leHRUZXh0KSxcclxuICAgICAgICAgICAgdG9kYXk6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMuY3VycmVudFRleHQpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiTU1NTSBZWVlZXCIgLT4gXCJTZXB0ZW1iZXIgMjAxNFwiXHJcbiAgICBtb250aFllYXJGb3JtYXQ6IGZ1bmN0aW9uIChkcE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZHBPcHRpb25zLnNob3dNb250aEFmdGVyWWVhciA/XHJcbiAgICAgICAgICAgICdZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddIE1NTU0nIDpcclxuICAgICAgICAgICAgJ01NTU0gWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSc7XHJcbiAgICB9XHJcbn07XHJcbnZhciBtb21Db21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJkZGQgTS9EXCIgLT4gXCJGcmkgOS8xNVwiXHJcbiAgICBkYXlPZk1vbnRoRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucywgZmNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ2wnKTsgLy8gZm9yIHRoZSBmb3JtYXQgbGlrZSBcIk0vRC9ZWVlZXCJcclxuICAgICAgICAvLyBzdHJpcCB0aGUgeWVhciBvZmYgdGhlIGVkZ2UsIGFzIHdlbGwgYXMgb3RoZXIgbWlzYyBub24td2hpdGVzcGFjZSBjaGFyc1xyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9eWStbXlxcd1xcc10qfFteXFx3XFxzXSpZKyQvZywgJycpO1xyXG4gICAgICAgIGlmIChmY09wdGlvbnMuaXNSVEwpIHtcclxuICAgICAgICAgICAgZm9ybWF0ICs9ICcgZGRkJzsgLy8gZm9yIFJUTCwgYWRkIGRheS1vZi13ZWVrIHRvIGVuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gJ2RkZCAnICsgZm9ybWF0OyAvLyBmb3IgTFRSLCBhZGQgZGF5LW9mLXdlZWsgdG8gYmVnaW5uaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1hXCIgLT4gXCI2OjAwcG1cIlxyXG4gICAgbWVkaXVtVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKWFcIiAtPiBcIjZwbVwiIC8gXCI2OjMwcG1cIlxyXG4gICAgc21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pdFwiIC0+IFwiNnBcIiAvIFwiNjozMHBcIlxyXG4gICAgZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcoOm1tKScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAndCcpOyAvLyBjb252ZXJ0IHRvIEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZSBvbmUtbGV0dGVyLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImhhXCIgLyBcIkhcIiAtPiBcIjZwbVwiIC8gXCIxOFwiXHJcbiAgICBob3VyRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJycpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbVwiIC0+IFwiNjozMFwiICh3aXRoIG5vIEFNL1BNKVxyXG4gICAgbm9NZXJpZGllbVRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBBTS9QTVxyXG4gICAgfVxyXG59O1xyXG4vLyBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIGNvbXB1dGVkIG9mZiBsaXZlIGNhbGVuZGFyIG9wdGlvbnMgKGNvbnNpZGVycyBvdmVycmlkZSBvcHRpb25zKVxyXG4vLyBUT0RPOiBiZXN0IHBsYWNlIGZvciB0aGlzPyByZWxhdGVkIHRvIGxvY2FsZT9cclxuLy8gVE9ETzogZmxpcHBpbmcgdGV4dCBiYXNlZCBvbiBpc1JUTCBpcyBhIGJhZCBpZGVhIGJlY2F1c2UgdGhlIENTUyBgZGlyZWN0aW9uYCBtaWdodCB3YW50IHRvIGhhbmRsZSBpdFxyXG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJNbyAxNlwiXHJcbiAgICBzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnRCBkZCcgOlxyXG4gICAgICAgICAgICAnZGQgRCc7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrIDVcIlxyXG4gICAgd2Vla0Zvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxyXG4gICAgICAgICAgICAnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICcgXXcnO1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXazVcIlxyXG4gICAgc21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcclxuICAgICAgICAgICAgJ1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXXcnO1xyXG4gICAgfVxyXG59O1xyXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGNvbXB1dGFibGUgcHJvcGVydGllcyBpbiBvcHRpb25zTWFuYWdlclxyXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgJC5lYWNoKGluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZnVuYyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucztcclxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXHJcbi8vIFdpbGwgc2V0IHRoaXMgYXMgdGhlIGRlZmF1bHQgbG9jYWxlcyBmb3IgZGF0ZXBpY2tlci5cclxuZnVuY3Rpb24gZGF0ZXBpY2tlckxvY2FsZShsb2NhbGVDb2RlLCBkcExvY2FsZUNvZGUsIGRwT3B0aW9ucykge1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICB2YXIgZmNPcHRpb25zID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XHJcbiAgICAvLyB0cmFuc2ZlciBzb21lIHNpbXBsZSBvcHRpb25zIGZyb20gZGF0ZXBpY2tlciB0byBmY1xyXG4gICAgZmNPcHRpb25zLmlzUlRMID0gZHBPcHRpb25zLmlzUlRMO1xyXG4gICAgZmNPcHRpb25zLndlZWtOdW1iZXJUaXRsZSA9IGRwT3B0aW9ucy53ZWVrSGVhZGVyO1xyXG4gICAgLy8gY29tcHV0ZSBzb21lIG1vcmUgY29tcGxleCBvcHRpb25zIGZyb20gZGF0ZXBpY2tlclxyXG4gICAgJC5lYWNoKGRwQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgZmNPcHRpb25zW25hbWVdID0gZnVuYyhkcE9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIganFEYXRlUGlja2VyID0gJC5kYXRlcGlja2VyO1xyXG4gICAgLy8gaXMgalF1ZXJ5IFVJIERhdGVwaWNrZXIgaXMgb24gdGhlIHBhZ2U/XHJcbiAgICBpZiAoanFEYXRlUGlja2VyKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGxvY2FsZSBkYXRhLlxyXG4gICAgICAgIC8vIEZ1bGxDYWxlbmRhciBhbmQgTW9tZW50SlMgdXNlIGxvY2FsZSBjb2RlcyBsaWtlIFwicHQtYnJcIiBidXQgRGF0ZXBpY2tlclxyXG4gICAgICAgIC8vIGRvZXMgaXQgbGlrZSBcInB0LUJSXCIgb3IgaWYgaXQgZG9lc24ndCBoYXZlIHRoZSBsb2NhbGUsIG1heWJlIGp1c3QgXCJwdFwiLlxyXG4gICAgICAgIC8vIE1ha2UgYW4gYWxpYXMgc28gdGhlIGxvY2FsZSBjYW4gYmUgcmVmZXJlbmNlZCBlaXRoZXIgd2F5LlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5yZWdpb25hbFtkcExvY2FsZUNvZGVdID1cclxuICAgICAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsW2xvY2FsZUNvZGVdID0gLy8gYWxpYXNcclxuICAgICAgICAgICAgICAgIGRwT3B0aW9ucztcclxuICAgICAgICAvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxvY2FsZSBkYXRhLiBEbyB0aGlzIGV2ZXJ5IHRpbWUuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsLmVuID0ganFEYXRlUGlja2VyLnJlZ2lvbmFsWycnXTtcclxuICAgICAgICAvLyBTZXQgYXMgRGF0ZXBpY2tlcidzIGdsb2JhbCBkZWZhdWx0cy5cclxuICAgICAgICBqcURhdGVQaWNrZXIuc2V0RGVmYXVsdHMoZHBPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBkYXRlcGlja2VyTG9jYWxlO1xyXG4vLyBTZXRzIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyB0cmFuc2xhdGlvbnMuIFdpbGwgc2V0IHRoZSBsb2NhbGVzIGFzIHRoZSBnbG9iYWwgZGVmYXVsdC5cclxuZnVuY3Rpb24gbG9jYWxlKGxvY2FsZUNvZGUsIG5ld0ZjT3B0aW9ucykge1xyXG4gICAgdmFyIGZjT3B0aW9ucztcclxuICAgIHZhciBtb21PcHRpb25zO1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cclxuICAgIGlmIChuZXdGY09wdGlvbnMpIHtcclxuICAgICAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtmY09wdGlvbnMsIG5ld0ZjT3B0aW9uc10pO1xyXG4gICAgfVxyXG4gICAgLy8gY29tcHV0ZSBsb2NhbGUgb3B0aW9ucyB0aGF0IHdlcmVuJ3QgZGVmaW5lZC5cclxuICAgIC8vIGFsd2F5cyBkbyB0aGlzLiBuZXdGY09wdGlvbnMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGluaXRpYWxpemluZyBmcm9tIGkxOG4gZmlsZSxcclxuICAgIC8vIHNvIG5vIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gb3IgYSBkZWZhdWx0LXNldHRpbmcuXHJcbiAgICBtb21PcHRpb25zID0gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKTsgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICQuZWFjaChtb21Db21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBpZiAoZmNPcHRpb25zW25hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgZmNPcHRpb25zW25hbWVdID0gKGZ1bmMpKG1vbU9wdGlvbnMsIGZjT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzZXQgaXQgYXMgdGhlIGRlZmF1bHQgbG9jYWxlIGZvciBGdWxsQ2FsZW5kYXJcclxuICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGUgPSBsb2NhbGVDb2RlO1xyXG59XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlO1xyXG4vLyBSZXR1cm5zIG1vbWVudCdzIGludGVybmFsIGxvY2FsZSBkYXRhLiBJZiBkb2Vzbid0IGV4aXN0LCByZXR1cm5zIEVuZ2xpc2guXHJcbmZ1bmN0aW9uIGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSkge1xyXG4gICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHx8IG1vbWVudC5sb2NhbGVEYXRhKCdlbicpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TW9tZW50TG9jYWxlRGF0YSA9IGdldE1vbWVudExvY2FsZURhdGE7XHJcbi8vIEluaXRpYWxpemUgRW5nbGlzaCBieSBmb3JjaW5nIGNvbXB1dGF0aW9uIG9mIG1vbWVudC1kZXJpdmVkIG9wdGlvbnMuXHJcbi8vIEFsc28sIHNldHMgaXQgYXMgdGhlIGRlZmF1bHQuXHJcbmxvY2FsZSgnZW4nLCBvcHRpb25zXzEuZW5nbGlzaERlZmF1bHRzKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZXhwb3J0cy5nbG9iYWxEZWZhdWx0cyA9IHtcclxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxyXG4gICAgbW9udGhZZWFyRm9ybWF0OiAnTU1NTSBZWVlZJyxcclxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMjowMDowMCcsXHJcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxyXG4gICAgbmV4dERheVRocmVzaG9sZDogJzA5OjAwOjAwJyxcclxuICAgIC8vIGRpc3BsYXlcclxuICAgIGNvbHVtbkhlYWRlcjogdHJ1ZSxcclxuICAgIGRlZmF1bHRWaWV3OiAnbW9udGgnLFxyXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAndGl0bGUnLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXHJcbiAgICB9LFxyXG4gICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXHJcbiAgICB3ZWVrTnVtYmVyVGl0bGU6ICdXJyxcclxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgIC8vIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgIC8vIG5vd0luZGljYXRvcjogZmFsc2UsXHJcbiAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgbWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgIG1heFRpbWU6ICcyNDowMDowMCcsXHJcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgLy8gZXZlbnQgYWpheFxyXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcclxuICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgIHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXHJcbiAgICB0aW1lem9uZTogZmFsc2UsXHJcbiAgICAvLyBhbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXHJcbiAgICAvLyBsb2NhbGVcclxuICAgIGxvY2FsZTogbnVsbCxcclxuICAgIGlzUlRMOiBmYWxzZSxcclxuICAgIGJ1dHRvblRleHQ6IHtcclxuICAgICAgICBwcmV2OiAncHJldicsXHJcbiAgICAgICAgbmV4dDogJ25leHQnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcclxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXHJcbiAgICAgICAgeWVhcjogJ3llYXInLFxyXG4gICAgICAgIHRvZGF5OiAndG9kYXknLFxyXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxyXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcclxuICAgICAgICBkYXk6ICdkYXknXHJcbiAgICB9LFxyXG4gICAgLy8gYnV0dG9uSWNvbnM6IG51bGwsXHJcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXHJcbiAgICAvLyBhbGxvd3Mgc2V0dGluZyBhIG1pbi1oZWlnaHQgdG8gdGhlIGV2ZW50IHNlZ21lbnQgdG8gcHJldmVudCBzaG9ydCBldmVudHMgb3ZlcmxhcHBpbmcgZWFjaCBvdGhlclxyXG4gICAgYWdlbmRhRXZlbnRNaW5IZWlnaHQ6IDAsXHJcbiAgICAvLyBqcXVlcnktdWkgdGhlbWluZ1xyXG4gICAgdGhlbWU6IGZhbHNlLFxyXG4gICAgLy8gdGhlbWVCdXR0b25JY29uczogbnVsbCxcclxuICAgIC8vIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcclxuICAgIGRyYWdPcGFjaXR5OiAuNzUsXHJcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcclxuICAgIGRyYWdTY3JvbGw6IHRydWUsXHJcbiAgICAvLyBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcclxuICAgIC8vIHNlbGVjdE1pbkRpc3RhbmNlOiAwLFxyXG4gICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgZXZlbnRPcmRlcjogJ3RpdGxlJyxcclxuICAgIC8vIGV2ZW50UmVuZGVyV2FpdDogbnVsbCxcclxuICAgIGV2ZW50TGltaXQ6IGZhbHNlLFxyXG4gICAgZXZlbnRMaW1pdFRleHQ6ICdtb3JlJyxcclxuICAgIGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxyXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogJ0xMJyxcclxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcclxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXHJcbiAgICBsb25nUHJlc3NEZWxheTogMTAwMFxyXG59O1xyXG5leHBvcnRzLmVuZ2xpc2hEZWZhdWx0cyA9IHtcclxuICAgIGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXHJcbn07XHJcbmV4cG9ydHMucnRsRGVmYXVsdHMgPSB7XHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAnbmV4dCxwcmV2IHRvZGF5JyxcclxuICAgICAgICBjZW50ZXI6ICcnLFxyXG4gICAgICAgIHJpZ2h0OiAndGl0bGUnXHJcbiAgICB9LFxyXG4gICAgYnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93JyxcclxuICAgICAgICBuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xyXG4gICAgfSxcclxuICAgIHRoZW1lQnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAnY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgICAgIG5leHQ6ICdjaXJjbGUtdHJpYW5nbGUtdycsXHJcbiAgICAgICAgbmV4dFllYXI6ICdzZWVrLXByZXYnLFxyXG4gICAgICAgIHByZXZZZWFyOiAnc2Vlay1uZXh0J1xyXG4gICAgfVxyXG59O1xyXG52YXIgY29tcGxleE9wdGlvbnMgPSBbXHJcbiAgICAnaGVhZGVyJyxcclxuICAgICdmb290ZXInLFxyXG4gICAgJ2J1dHRvblRleHQnLFxyXG4gICAgJ2J1dHRvbkljb25zJyxcclxuICAgICd0aGVtZUJ1dHRvbkljb25zJ1xyXG5dO1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcclxuICAgIHJldHVybiB1dGlsXzEubWVyZ2VQcm9wcyhvcHRpb25PYmpzLCBjb21wbGV4T3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSBtZXJnZU9wdGlvbnM7XHJcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLy8gQ2xhc3MgdGhhdCBhbGwgb3RoZXIgY2xhc3NlcyB3aWxsIGluaGVyaXQgZnJvbVxyXG52YXIgQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDbGFzcygpIHtcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCBvbiBhIGNsYXNzIHRvIGNyZWF0ZSBhIHN1YmNsYXNzLlxyXG4gICAgLy8gTElNSVRBVElPTjogY2Fubm90IHByb3ZpZGUgYSBjb25zdHJ1Y3RvciFcclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdmFyIFN1YkNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN1YkNsYXNzO1xyXG4gICAgICAgIH0odGhpcykpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMobWVtYmVycywgU3ViQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cclxuICAgIC8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXHJcbiAgICBDbGFzcy5taXhpbiA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCB0aGlzLnByb3RvdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENsYXNzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDbGFzcztcclxuXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA4KTtcclxudmFyIEV2ZW50RGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREZWYoc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBbXTtcclxuICAgICAgICB0aGlzLm1pc2NQcm9wcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgRXZlbnREZWYucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBkZWYgPSBuZXcgdGhpcyhzb3VyY2UpO1xyXG4gICAgICAgIGlmIChkZWYuYXBwbHlQcm9wcyhyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLm5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ19mYycgKyAoRXZlbnREZWYudXVpZCsrKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgY29weS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgY29weS5yYXdJZCA9IHRoaXMucmF3SWQ7XHJcbiAgICAgICAgY29weS51aWQgPSB0aGlzLnVpZDsgLy8gbm90IHJlYWxseSB1bmlxdWUgYW55bW9yZSA6KFxyXG4gICAgICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHModGhpcywgY29weSk7XHJcbiAgICAgICAgY29weS5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5zbGljZSgpOyAvLyBjb3B5XHJcbiAgICAgICAgY29weS5taXNjUHJvcHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNJbnZlcnNlUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmluZygpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaGFzQmdSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmluZyA9IHRoaXMuZ2V0UmVuZGVyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldFJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZW5kZXJpbmc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50Q29uc3RyYWludCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zb3VyY2Uub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2FsZW5kYXIub3B0KCdldmVudE92ZXJsYXAnKTsgLy8gd2hhdCBhYm91dCBWaWV3IG9wdGlvbj9cclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN0YXJ0RWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5kdXJhdGlvbkVkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc0V4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLnRvTGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvYmogPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIG9iai5faWQgPSB0aGlzLnVpZDtcclxuICAgICAgICBvYmouc291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgb2JqLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBvYmouYWxsRGF5ID0gdGhpcy5pc0FsbERheSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJhd0lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgb2JqLmlkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBvYmopO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIGlmIChyYXdQcm9wcy5pZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5ub3JtYWxpemVJZCgodGhpcy5yYXdJZCA9IHJhd1Byb3BzLmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMuX2lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBTdHJpbmcocmF3UHJvcHMuX2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudWlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50U291cmNlXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgJC5leHRlbmQodGhpcy5taXNjUHJvcHMsIHJhd1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi51dWlkID0gMDtcclxuICAgIEV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZjtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50RGVmKTtcclxuRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBub3QgYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYGZhbHNlYClcclxuICAgIF9pZDogZmFsc2UsXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgc291cmNlOiBmYWxzZSxcclxuICAgIC8vIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgKGB0cnVlYClcclxuICAgIHRpdGxlOiB0cnVlLFxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgcmVuZGVyaW5nOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIG92ZXJsYXA6IHRydWUsXHJcbiAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXHJcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTEpO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuZnVuY3Rpb24gZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcyhldmVudERlZnMsIHVuem9uZWRSYW5nZSkge1xyXG4gICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBldmVudEluc3RhbmNlcy5wdXNoLmFwcGx5KGV2ZW50SW5zdGFuY2VzLCAvLyBhcHBlbmRcclxuICAgICAgICBldmVudERlZnNbaV0uYnVpbGRJbnN0YW5jZXModW56b25lZFJhbmdlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbn1cclxuZXhwb3J0cy5ldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzID0gZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcztcclxuZnVuY3Rpb24gZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZShldmVudEluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlLCBldmVudEluc3RhbmNlLmRlZiwgZXZlbnRJbnN0YW5jZSk7XHJcbn1cclxuZXhwb3J0cy5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlID0gZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZTtcclxuZnVuY3Rpb24gZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQoZXZlbnRSYW5nZS51bnpvbmVkUmFuZ2UsIGV2ZW50UmFuZ2UuZXZlbnREZWYuaXNBbGxEYXkoKSksIGV2ZW50UmFuZ2UuZXZlbnREZWYsIGV2ZW50UmFuZ2UuZXZlbnRJbnN0YW5jZSAvLyBtaWdodCBub3QgZXhpc3RcclxuICAgICk7XHJcbn1cclxuZXhwb3J0cy5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludCA9IGV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50O1xyXG5mdW5jdGlvbiBldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlID0gZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlO1xyXG5mdW5jdGlvbiBldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50KGV2ZW50Rm9vdHByaW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50O1xyXG59XHJcbmV4cG9ydHMuZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50Rm9vdHByaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Rm9vdHByaW50ID0gY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEV2ZW50Rm9vdHByaW50LnByb3RvdHlwZS5nZXRFdmVudExlZ2FjeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRJbnN0YW5jZSB8fCB0aGlzLmV2ZW50RGVmKS50b0xlZ2FjeSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEZvb3RwcmludDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZk11dGF0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5jcmVhdGVGcm9tUmF3UHJvcHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgcmF3UHJvcHMsIGxhcmdlVW5pdCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2UuZGVmO1xyXG4gICAgICAgIHZhciBkYXRlUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBtaXNjUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgdmVyYmF0aW1TdGFuZGFyZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBudWxsO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZGVmTXV0YXRpb247XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQuaXNTdGFuZGFyZFByb3AocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50RGVmLmlzU3RhbmRhcmRQcm9wKHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnREZWYubWlzY1Byb3BzW3Byb3BOYW1lXSAhPT0gcmF3UHJvcHNbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVQcm9maWxlID0gRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQucGFyc2UoZGF0ZVByb3BzLCBldmVudERlZi5zb3VyY2UpO1xyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQuY3JlYXRlRnJvbURpZmYoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGUsIGxhcmdlVW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFuZGFyZFByb3BzLmlkICE9PSBldmVudERlZi5pZCkge1xyXG4gICAgICAgICAgICBldmVudERlZklkID0gc3RhbmRhcmRQcm9wcy5pZDsgLy8gb25seSBhcHBseSBpZiB0aGVyZSdzIGEgY2hhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXRpbF8xLmlzQXJyYXlzRXF1YWwoc3RhbmRhcmRQcm9wcy5jbGFzc05hbWUsIGV2ZW50RGVmLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gc3RhbmRhcmRQcm9wcy5jbGFzc05hbWU7IC8vIG9ubHkgYXBwbHkgaWYgdGhlcmUncyBhIGNoYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZl8xLmRlZmF1bHQuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyhzdGFuZGFyZFByb3BzLCAvLyBzcmNcclxuICAgICAgICB2ZXJiYXRpbVN0YW5kYXJkUHJvcHMgLy8gZGVzdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbigpO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmV2ZW50RGVmSWQgPSBldmVudERlZklkO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICBkZWZNdXRhdGlvbi52ZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSB2ZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICAgICAgZGVmTXV0YXRpb24ubWlzY1Byb3BzID0gbWlzY1Byb3BzO1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgZGVmTXV0YXRpb24uZGF0ZU11dGF0aW9uID0gZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGV2ZW50RGVmIGFzc3VtZWQgdG8gYmUgYSBTaW5nbGVFdmVudERlZi5cclxuICAgIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvbi5cclxuICAgICovXHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5tdXRhdGVTaW5nbGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb3JpZ0RhdGVQcm9maWxlO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBvcmlnRGF0ZVByb2ZpbGUgPSBldmVudERlZi5kYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgZXZlbnREZWYuZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVNdXRhdGlvbi5idWlsZE5ld0RhdGVQcm9maWxlKG9yaWdEYXRlUHJvZmlsZSwgZXZlbnREZWYuc291cmNlLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggRXZlbnREZWY6OmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wc1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50RGVmSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudERlZi5pZCA9IEV2ZW50RGVmXzEuZGVmYXVsdC5ub3JtYWxpemVJZCgoZXZlbnREZWYucmF3SWQgPSB0aGlzLmV2ZW50RGVmSWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggRXZlbnREZWY6OmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wc1xyXG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICBldmVudERlZi5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIGlmICh0aGlzLnZlcmJhdGltU3RhbmRhcmRQcm9wcykge1xyXG4gICAgICAgICAgICBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLnZlcmJhdGltU3RhbmRhcmRQcm9wcywgLy8gc3JjXHJcbiAgICAgICAgICAgIGV2ZW50RGVmIC8vIGRlc3RcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIGlmICh0aGlzLm1pc2NQcm9wcykge1xyXG4gICAgICAgICAgICBldmVudERlZi5hcHBseU1pc2NQcm9wcyh0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnRGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmLmRhdGVQcm9maWxlID0gb3JpZ0RhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUuc2V0RGF0ZU11dGF0aW9uID0gZnVuY3Rpb24gKGRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24gJiYgIWRhdGVNdXRhdGlvbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlTXV0YXRpb24gPSBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGVNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREZWZNdXRhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREZWZNdXRhdGlvbjtcclxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBzb3VyY2VDbGFzc2VzOiBbXSxcclxuICAgIHJlZ2lzdGVyQ2xhc3M6IGZ1bmN0aW9uIChFdmVudFNvdXJjZUNsYXNzKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VDbGFzc2VzLnVuc2hpZnQoRXZlbnRTb3VyY2VDbGFzcyk7IC8vIGdpdmUgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgfSxcclxuICAgIHBhcnNlOiBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZUNsYXNzZXMgPSB0aGlzLnNvdXJjZUNsYXNzZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQ2xhc3Nlc1tpXS5wYXJzZShyYXdJbnB1dCwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbi8qXHJcbkVtYm9kaWVzIGEgZGl2IHRoYXQgaGFzIHBvdGVudGlhbCBzY3JvbGxiYXJzXHJcbiovXHJcbnZhciBTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFNjcm9sbGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2Nyb2xsZXIob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgX3RoaXMub3ZlcmZsb3dYID0gb3B0aW9ucy5vdmVyZmxvd1ggfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XHJcbiAgICAgICAgX3RoaXMub3ZlcmZsb3dZID0gb3B0aW9ucy5vdmVyZmxvd1kgfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsID0gdGhpcy5yZW5kZXJFbCgpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlPdmVyZmxvdygpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5yZW5kZXJFbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2Nyb2xsRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtc2Nyb2xsZXJcIj48L2Rpdj4nKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gc2V0cyB0byBuYXR1cmFsIGhlaWdodCwgdW5sb2NrcyBvdmVyZmxvd1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KCdhdXRvJyk7XHJcbiAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBPdmVyZmxvd1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5hcHBseU92ZXJmbG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuY3NzKHtcclxuICAgICAgICAgICAgJ292ZXJmbG93LXgnOiB0aGlzLm92ZXJmbG93WCxcclxuICAgICAgICAgICAgJ292ZXJmbG93LXknOiB0aGlzLm92ZXJmbG93WVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhdXNlcyBhbnkgJ2F1dG8nIG92ZXJmbG93IHZhbHVlcyB0byByZXNvbHZlcyB0byAnc2Nyb2xsJyBvciAnaGlkZGVuJy5cclxuICAgIC8vIFVzZWZ1bCBmb3IgcHJlc2VydmluZyBzY3JvbGxiYXIgd2lkdGhzIHJlZ2FyZGxlc3Mgb2YgZnV0dXJlIHJlc2l6ZXMuXHJcbiAgICAvLyBDYW4gcGFzcyBpbiBzY3JvbGxiYXJXaWR0aHMgZm9yIG9wdGltaXphdGlvbi5cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5sb2NrT3ZlcmZsb3cgPSBmdW5jdGlvbiAoc2Nyb2xsYmFyV2lkdGhzKSB7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93WCA9IHRoaXMub3ZlcmZsb3dYO1xyXG4gICAgICAgIHZhciBvdmVyZmxvd1kgPSB0aGlzLm92ZXJmbG93WTtcclxuICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSBzY3JvbGxiYXJXaWR0aHMgfHwgdGhpcy5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICBpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYID0gKHNjcm9sbGJhcldpZHRocy50b3AgfHwgc2Nyb2xsYmFyV2lkdGhzLmJvdHRvbSB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAvLyBPUiBzY3JvbGxpbmcgcGFuZSB3aXRoIG1hc3NsZXNzIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbFdpZHRoIC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGgpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WSA9IChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQgfHwgLy8gdmVydGljYWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsSGVpZ2h0IC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuY3NzKHsgJ292ZXJmbG93LXgnOiBvdmVyZmxvd1gsICdvdmVyZmxvdy15Jzogb3ZlcmZsb3dZIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHRlcnMgLyBTZXR0ZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbEVsLmhlaWdodChoZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWwuc2Nyb2xsVG9wKCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcclxuICAgICAgICB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCh0b3ApO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aDtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudEhlaWdodDtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0U2Nyb2xsYmFyV2lkdGhzKHRoaXMuc2Nyb2xsRWwpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTY3JvbGxlcjtcclxufShDbGFzc18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQoX3ZpZXcsIF9vcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX3ZpZXcsIF9vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIHNlbGYtY29uZmlnLCBvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzXHJcbiAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgPSAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConOyAvLyB3aGF0IGNvbnN0aXR1dGVzIGFuIGV2ZW50IGVsZW1lbnQ/XHJcbiAgICAgICAgaWYgKF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlQ2xpY2tpbmcgPSBuZXcgX3RoaXMuZGF0ZUNsaWNraW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGVTZWxlY3RpbmcgPSBuZXcgX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gbmV3IF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudERyYWdnaW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudERyYWdnaW5nID0gbmV3IF90aGlzLmV2ZW50RHJhZ2dpbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFJlc2l6aW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJlc2l6aW5nID0gbmV3IF90aGlzLmV2ZW50UmVzaXppbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXh0ZXJuYWxEcm9wcGluZyA9IG5ldyBfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSB2aWV3IHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLCBkb2VzIGdsb2JhbCBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMsXHJcbiAgICAvLyBhbmQgcmVuZGVycyBhbGwgdGhlIG5vbi1kYXRlLXJlbGF0ZWQgY29udGVudCBpbnNpZGUuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEVsZW1lbnQuY2FsbCh0aGlzLCBlbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZUNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlbGVjdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcuYmluZFRvRWwoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwoZWwpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEludGVyYWN0aW9ucygpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbnMoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy5iaW5kVG9Eb2N1bWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy51bmJpbmRGcm9tRG9jdW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRGF0ZUhhbmRsZXJUb0VsID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIHRoZSBncmlkJ3Mgcm9vdCBlbGVtZW50LlxyXG4gICAgICAgIC8vIGpRdWVyeSB3aWxsIHRha2UgY2FyZSBvZiB1bnJlZ2lzdGVyaW5nIHRoZW0gd2hlbiByZW1vdmVFbGVtZW50IGdldHMgY2FsbGVkLlxyXG4gICAgICAgIHRoaXMuZWwub24obmFtZSwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghJChldi50YXJnZXQpLmlzKF90aGlzLnNlZ1NlbGVjdG9yICsgJzpub3QoLmZjLWhlbHBlciksJyArIC8vIGRpcmVjdGx5IG9uIGFuIGV2ZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yICsgJzpub3QoLmZjLWhlbHBlcikgKiwnICsgLy8gd2l0aGluIGFuIGV2ZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICcuZmMtbW9yZSwnICsgLy8gYSBcIm1vcmUuLlwiIGxpbmtcclxuICAgICAgICAgICAgICAgICdhW2RhdGEtZ290b10nIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXHJcbiAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZEFsbFNlZ0hhbmRsZXJzVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFBvaW50aW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZXNpemluZ1xyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGlvbi5iaW5kVG9FbChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmRTZWdIYW5kbGVyVG9FbCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZWwub24obmFtZSwgdGhpcy5zZWdTZWxlY3RvciwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmICghc2VnRWwuaXMoJy5mYy1oZWxwZXInKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ0VsLmRhdGEoJ2ZjLXNlZycpOyAvLyBncmFiIHNlZ21lbnQgZGF0YS4gcHV0IHRoZXJlIGJ5IFZpZXc6OnJlbmRlckV2ZW50c1BheWxvYWRcclxuICAgICAgICAgICAgICAgIGlmIChzZWcgJiYgIV90aGlzLnNob3VsZElnbm9yZUV2ZW50UG9pbnRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIHNlZywgZXYpOyAvLyBjb250ZXh0IHdpbGwgYmUgdGhlIEdyaWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSEFDS1xyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBzdGlsbCB3b3JrIGV2ZW4gdGhvdWdoIGJpbmREYXRlSGFuZGxlclRvRWwgZG9lc24ndCB1c2UgR2xvYmFsRW1pdHRlci5cclxuICAgICAgICByZXR1cm4gR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZElnbm9yZVRvdWNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIC8vIE9uIGlPUyAoYW5kIEFuZHJvaWQ/KSB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBpbml0aWF0ZWQgb3ZlcnRvcCBhbm90aGVyIHNlbGVjdGlvbixcclxuICAgICAgICAvLyB0aGUgdG91Y2hlbmQgbmV2ZXIgZmlyZXMgYmVjYXVzZSB0aGUgZWxlbWVudHMgZ2V0cyByZW1vdmVkIG1pZC10b3VjaC1pbnRlcmFjdGlvbiAobXkgdGhlb3J5KS5cclxuICAgICAgICAvLyBIQUNLOiBzaW1wbHkgZG9uJ3QgYWxsb3cgdGhpcyB0byBoYXBwZW4uXHJcbiAgICAgICAgLy8gQUxTTzogcHJldmVudCBzZWxlY3Rpb24gd2hlbiBhbiAqZXZlbnQqIGlzIGFscmVhZHkgcmFpc2VkLlxyXG4gICAgICAgIHJldHVybiB2aWV3LmlzU2VsZWN0ZWQgfHwgdmlldy5zZWxlY3RlZEV2ZW50O1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlRXZlbnRQb2ludGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBvbmx5IGNhbGwgdGhlIGhhbmRsZXJzIGlmIHRoZXJlIGlzIG5vdCBhIGRyYWcvcmVzaXplIGluIHByb2dyZXNzXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50RHJhZ2dpbmcgJiYgdGhpcy5ldmVudERyYWdnaW5nLmlzRHJhZ2dpbmcpIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmV2ZW50UmVzaXppbmcgJiYgdGhpcy5ldmVudFJlc2l6aW5nLmlzUmVzaXppbmcpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnREcmFnID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2FuU3RhcnRSZXNpemUoc2VnLCBldikgJiZcclxuICAgICAgICAgICAgdGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRSZXNpemUgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgcmV0dXJuICghdXRpbF8xLmdldEV2SXNUb3VjaChldikgfHwgdmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoZXZlbnREZWYpKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpICYmXHJcbiAgICAgICAgICAgICQoZXYudGFyZ2V0KS5pcygnLmZjLXJlc2l6ZXInKTtcclxuICAgIH07XHJcbiAgICAvLyBLaWxscyBhbGwgaW4tcHJvZ3Jlc3MgZHJhZ2dpbmcuXHJcbiAgICAvLyBVc2VmdWwgZm9yIHdoZW4gcHVibGljIEFQSSBtZXRob2RzIHRoYXQgcmVzdWx0IGluIHJlLXJlbmRlcmluZyBhcmUgaW52b2tlZCBkdXJpbmcgYSBkcmFnLlxyXG4gICAgLy8gQWxzbyB1c2VmdWwgZm9yIHdoZW4gdG91Y2ggZGV2aWNlcyBtaXNiZWhhdmUgYW5kIGRvbid0IGZpcmUgdGhlaXIgdG91Y2hlbmQuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmVuZEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLFxyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQb2ludGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudERyYWdnaW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVzaXppbmdcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEcmFnLW4tRHJvcFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSBkcmFnZ2VkIGJ5IHRoZSB1c2VyXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZEcmFnZ2FibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNFeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzRWRpdGFibGUgPSB0aGlzLm9wdCgnZWRpdGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBzdGFydGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0JykgJiYgdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIGVuZGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBieSB0aGUgdXNlciBhdCBhbGxcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZSA9IGV2ZW50RGVmLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNSZXNpemFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc1Jlc2l6YWJsZSA9IHRoaXMub3B0KCdldmVudER1cmF0aW9uRWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXphYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzaXphYmxlID0gdGhpcy5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1Jlc2l6YWJsZTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBNdXRhdGlvbiAvIENvbnN0cmFpbnRzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIERpZmZzIHRoZSB0d28gZGF0ZXMsIHJldHVybmluZyBhIGR1cmF0aW9uLCBiYXNlZCBvbiBncmFudWxhcml0eSBvZiB0aGUgZ3JpZFxyXG4gICAgLy8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHRoaXMgc3lzdGVtP1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5kaWZmRGF0ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlVW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoYSwgYiwgdGhpcy5sYXJnZVVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaXMgaXQgYWxsb3dlZCwgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXcncyB2YWxpZFJhbmdlP1xyXG4gICAgLy8gTk9URTogdmVyeSBzaW1pbGFyIHRvIGlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGp1c3QgdXNlIGdldEFsbEV2ZW50UmFuZ2VzIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICghZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQoZXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgIH07XHJcbiAgICAvLyBOT1RFOiB2ZXJ5IHNpbWlsYXIgdG8gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAvLyB3aGVuIGl0J3MgYSBjb21wbGV0ZWx5IGFub255bW91cyBleHRlcm5hbCBkcmFnLCBubyBldmVudC5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGVQcm9maWxlLnZhbGlkVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGluIGV2ZW50SW5zdGFuY2VHcm91cCBpbnN0ZWFkXHJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIHdlIGRvbid0IHdhbnQgY2FsZW5kYXIncyBjb25zdHJhaW50IHN5c3RlbSB0byBkZXBlbmQgb24gYSBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAvLyAgZGV0ZXJtaW5hdGlvbiBvZiBmb290cHJpbnRzLlxyXG4gICAgICAgICAgICBpZiAoIXZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudDtcclxufShEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbnZhciBEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjEpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIG90aGVyIHZpZXdzIGluaGVyaXQgZnJvbVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCB2aWV3U3BlYy5vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmJhdGNoUmVuZGVyRGVwdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gYm9vbGVhbiB3aGV0aGVyIGEgcmFuZ2Ugb2YgdGltZSBpcyB1c2VyLXNlbGVjdGVkIG9yIG5vdFxyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMudmlld1NwZWMgPSB2aWV3U3BlYztcclxuICAgICAgICAvLyBzaG9ydGN1dHNcclxuICAgICAgICBfdGhpcy50eXBlID0gdmlld1NwZWMudHlwZTtcclxuICAgICAgICAvLyAubmFtZSBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLnR5cGU7XHJcbiAgICAgICAgX3RoaXMuaW5pdFJlbmRlclF1ZXVlKCk7XHJcbiAgICAgICAgX3RoaXMuaW5pdEhpZGRlbkRheXMoKTtcclxuICAgICAgICBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvciA9IG5ldyBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5iaW5kQmFzZVJlbmRlckhhbmRsZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gdXRpbF8xLnBhcnNlRmllbGRTcGVjcyhfdGhpcy5vcHQoJ2V2ZW50T3JkZXInKSk7XHJcbiAgICAgICAgLy8gbGVnYWN5XHJcbiAgICAgICAgaWYgKF90aGlzWydpbml0aWFsaXplJ10pIHtcclxuICAgICAgICAgICAgX3RoaXNbJ2luaXRpYWxpemUnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYW4gb3B0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgIFZpZXcucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXIgUXVldWVcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0UmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZSA9IG5ldyBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBldmVudDogdGhpcy5vcHQoJ2V2ZW50UmVuZGVyV2FpdCcpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbignc3RhcnQnLCB0aGlzLm9uUmVuZGVyUXVldWVTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uKCdzdG9wJywgdGhpcy5vblJlbmRlclF1ZXVlU3RvcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6Y2hhbmdlJywgdGhpcy5zdGFydEJhdGNoUmVuZGVyKTtcclxuICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnN0b3BCYXRjaFJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHRoaXMucXVlcnlTY3JvbGwoKSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXIudXBkYXRlVmlld1NpemUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnRCYXRjaFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmJhdGNoUmVuZGVyRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wQmF0Y2hSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmJhdGNoUmVuZGVyRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RSZW5kZXIgPSBmdW5jdGlvbiAoZnVuYywgbmFtZXNwYWNlLCBhY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5xdWV1ZShmdW5jLCBuYW1lc3BhY2UsIGFjdGlvblR5cGUpO1xyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGZ1bmMgd2lsbCBhdXRvLWJpbmQgdG8gYHRoaXNgXHJcbiAgICBWaWV3LnByb3RvdHlwZS53aGVuU2l6ZVVwZGF0ZWQgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclF1ZXVlLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uZSgnc3RvcCcsIGZ1bmMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZVRpdGxlID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZTtcclxuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jYWxlbmRhci5tc1RvTW9tZW50KHVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiB0aGlzLmNhbGVuZGFyLm1zVG9Nb21lbnQodW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KVxyXG4gICAgICAgIH0sIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksIHRoaXMub3B0KCd0aXRsZUZvcm1hdCcpIHx8IHRoaXMuY29tcHV0ZVRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSwgdGhpcy5vcHQoJ3RpdGxlUmFuZ2VTZXBhcmF0b3InKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxyXG4gICAgLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cclxuICAgIFZpZXcucHJvdG90eXBlLmNvbXB1dGVUaXRsZUZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UmFuZ2VVbml0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdDtcclxuICAgICAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnWVlZWSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdtb250aFllYXJGb3JtYXQnKTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5hcygnZGF5cycpID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xsJzsgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnTEwnOyAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBTZXR0aW5nL1Vuc2V0dGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnNldERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50RGF0ZVByb2ZpbGUgPSB0aGlzLmdldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgICAgICB2YXIgbmV3RGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGRhdGUsIHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIGZvcmNlVG9WYWxpZD10cnVlXHJcbiAgICAgICAgaWYgKCFjdXJyZW50RGF0ZVByb2ZpbGUgfHxcclxuICAgICAgICAgICAgIWN1cnJlbnREYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZXF1YWxzKG5ld0RhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2RhdGVQcm9maWxlJywgbmV3RGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNldERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEYXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuZmV0Y2hJbml0aWFsRXZlbnRzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5ICYmICF0aGlzLnVzZXNNaW5NYXhUaW1lO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5yZXF1ZXN0RXZlbnRzKGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGZvcmNlQWxsRGF5KSwgY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZW5kTXMsIGZvcmNlQWxsRGF5KSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEV2ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcsIHRoaXMucmVzZXRFdmVudHMpOyAvLyBUT0RPOiBtYWtlIHRoaXMgYSByZWFsIGV2ZW50XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kRXZlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoJ2N1cnJlbnRFdmVudHMnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB0aGlzLnNldCgnaGFzRXZlbnRzJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnY3VycmVudEV2ZW50cycpO1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2hhc0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2hSZW5kZXIoKTtcclxuICAgICAgICB0aGlzLnVuc2V0RXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRFdmVudHMoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2hSZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlUmVuZGVyKGRhdGVQcm9maWxlKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlVW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gaWYgZGF0ZVByb2ZpbGUgbm90IHNwZWNpZmllZCwgdXNlcyBjdXJyZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3JlbmRlciddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlciddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGVzUmVuZGVyZWQnKTtcclxuICAgICAgICB0aGlzLmFkZFNjcm9sbCh7IGlzRGF0ZUluaXQ6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vd0luZGljYXRvcigpOyAvLyBzaG91bGRuJ3QgcmVuZGVyIHlldCBiZWNhdXNlIHVwZGF0ZVNpemUgd2lsbCBiZSBjYWxsZWQgc29vblxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgIHRoaXMuc3RvcE5vd0luZGljYXRvcigpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzWydkZXN0cm95J10pIHtcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveSddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBcIkJhc2VcIiByZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kQmFzZVJlbmRlckhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vbignZGF0ZXNSZW5kZXJlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJWaWV3UmVuZGVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6ZGF0ZXNVbnJlbmRlcmVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyVmlld0Rlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyVmlld1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlclZpZXdEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzUmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVFdmVudFJlbmRlcihldmVudHNQYXlsb2FkKTtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJBZnRlckV2ZW50c1JlbmRlcmVkKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnaW5pdCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RFdmVudHNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQoKTtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZUV2ZW50VW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1c2luZXNzIEhvdXIgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1JlbmRlciA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICB9LCAnYnVzaW5lc3NIb3VycycsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEJ1c2luZXNzSG91cnNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xyXG4gICAgICAgIH0sICdidXNpbmVzc0hvdXJzJywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBNaXNjIHZpZXcgcmVuZGVyaW5nIHV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKSwge1xyXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLnByb2Nlc3NVbnNlbGVjdCxcclxuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lclxyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpKTtcclxuICAgIH07XHJcbiAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBiZWdpbnMgcmUtcmVuZGVyaW5nIGl0IGF0IGFuIGludGVydmFsLFxyXG4gICAgLy8gd2hpY2ggaXMgZGVmaW5lZCBieSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKS5cclxuICAgIC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cclxuICAgIFZpZXcucHJvdG90eXBlLnN0YXJ0Tm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgdmFyIHVwZGF0ZTtcclxuICAgICAgICB2YXIgZGVsYXk7IC8vIG1zIHdhaXQgdmFsdWVcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ25vd0luZGljYXRvcicpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgICAgICAgICAgaWYgKHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHV0aWxfMS5wcm94eSh0aGlzLCAndXBkYXRlTm93SW5kaWNhdG9yJyk7IC8vIGJpbmQgdG8gYHRoaXNgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICBkZWxheSA9IHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5zdGFydE9mKHVuaXQpLmFkZCgxLCB1bml0KS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dEYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9ICttb21lbnQuZHVyYXRpb24oMSwgdW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgxMDAsIGRlbGF5KTsgLy8gcHJldmVudCB0b28gZnJlcXVlbnRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlLCBkZWxheSk7IC8vIHVwZGF0ZSBldmVyeSBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmluZyB3aWxsIGJlIGluaXRpYXRlZCBpbiB1cGRhdGVTaXplXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxyXG4gICAgLy8gc2luY2UgdGhlIGluaXRpYWwgZ2V0Tm93IGNhbGwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgLy8gYWN0aXZhdGVkIGJlZm9yZT9cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpOyAvLyB3b24ndCB1bnJlbmRlciBpZiB1bm5lY2Vzc2FyeVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vd0luZGljYXRvcih0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuYWRkKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXHJcbiAgICAvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc3RvcE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3NldEhlaWdodCddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3NldEhlaWdodCddKHRvdGFsSGVpZ2h0LCBpc0F1dG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbGVyXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuYWRkU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIHZhciBxdWV1ZWRTY3JvbGwgPSB0aGlzLnF1ZXVlZFNjcm9sbCB8fCAodGhpcy5xdWV1ZWRTY3JvbGwgPSB7fSk7XHJcbiAgICAgICAgJC5leHRlbmQocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnBvcFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFwcGx5UXVldWVkU2Nyb2xsKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZWRTY3JvbGwgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5UXVldWVkU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFNjcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U2Nyb2xsKHRoaXMucXVldWVkU2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Nyb2xsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwuaXNEYXRlSW5pdCAmJiB0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBseURhdGVTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWctbi1Ecm9wXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnREcm9wID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGV2ZW50TXV0YXRpb24sIGVsLCBldikge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgdW5kb0Z1bmMgPSBldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50SW5zdGFuY2UuZGVmLmlkLCBldmVudE11dGF0aW9uKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb247XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBFdmVudEluc3RhbmNlLCBmb3IgaGFuZGxlcnNcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUgPSBkYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnREcm9wKGV2ZW50SW5zdGFuY2UsIFxyXG4gICAgICAgIC8vIGEgZHJvcCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gYSBkYXRlIG11dGF0aW9uIChleDogcmVzb3VyY2UgY2hhbmdlKVxyXG4gICAgICAgIChkYXRlTXV0YXRpb24gJiYgZGF0ZU11dGF0aW9uLmRhdGVEZWx0YSkgfHwgbW9tZW50LmR1cmF0aW9uKCksIHVuZG9GdW5jLCBlbCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV2ZW50LWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFdmVudERyb3AgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGRhdGVEZWx0YSxcclxuICAgICAgICAgICAgICAgIHVuZG9GdW5jLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZy1uLURyb3BcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQsIHZpYSBqUXVlcnkgVUksIGhhcyBiZWVuIGRyb3BwZWQgb250byB0aGUgY2FsZW5kYXIuXHJcbiAgICAvLyBgbWV0YWAgaXMgdGhlIHBhcnNlZCBkYXRhIHRoYXQgaGFzIGJlZW4gZW1iZWRkZWQgaW50byB0aGUgZHJhZ2dpbmcgZXZlbnQuXHJcbiAgICAvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGlzU3RpY2t5LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgaWYgKGlzRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoc2luZ2xlRXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXh0ZXJuYWxEcm9wKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBleHRlcm5hbC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXh0ZXJuYWxEcm9wID0gZnVuY3Rpb24gKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgLy8gdHJpZ2dlciAnZHJvcCcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGVsZW1lbnQgcmVwcmVzZW50cyBhbiBldmVudFxyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkcm9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYuZGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdWksXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBzaWduYWwgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmLmJ1aWxkSW5zdGFuY2UoKS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBoYXMgYmVlbiByZXNpemVkIHRvIGEgbmV3IGxlbmd0aFxyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbiwgZWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bmRvRnVuYyA9IGV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnRJbnN0YW5jZS5kZWYuaWQsIGV2ZW50TXV0YXRpb24pO1xyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgRXZlbnRJbnN0YW5jZSwgZm9yIGhhbmRsZXJzXHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSA9IGV2ZW50TXV0YXRpb24uZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRSZXNpemUoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uZW5kRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV2ZW50LXJlc2l6ZSBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGR1cmF0aW9uRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemUnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbkRlbHRhLFxyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uICh0aW1lIHJhbmdlKVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFNlbGVjdHMgYSBkYXRlIHNwYW4gb24gdGhlIHZpZXcuIGBzdGFydGAgYW5kIGBlbmRgIGFyZSBib3RoIE1vbWVudHMuXHJcbiAgICAvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdpbiB0aGUgaW50ZXJhY3Rpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHRoaXMudW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGZvb3RwcmludCk7XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTZWxlY3Rpb24oZm9vdHByaW50LCBldik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzWydyZW5kZXJTZWxlY3Rpb24nXSkge1xyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXJTZWxlY3Rpb24nXShmb290cHJpbnQudG9MZWdhY3kodGhpcy5jYWxlbmRhcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQuY2FsbCh0aGlzLCBmb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgbWFkZS4gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VsZWN0KGZvb3RwcmludCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdzZWxlY3QnXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyU2VsZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZXYpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoZm9vdHByaW50KTsgLy8gYWJ1c2Ugb2YgXCJFdmVudFwiRGF0ZVByb2ZpbGU/XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3NlbGVjdCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZS5lbmQsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFVuZG9lcyBhIHNlbGVjdGlvbi4gdXBkYXRlcyBpbiB0aGUgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzLlxyXG4gICAgLy8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnYW4gdGhlIGludGVyYWN0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpc1snZGVzdHJveVNlbGVjdGlvbiddKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzWydkZXN0cm95U2VsZWN0aW9uJ10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndW5zZWxlY3QnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW2V2LCB0aGlzXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuc2VsZWN0RXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSAhPT0gZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZSA9PT0gZXZlbnRJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmlzRXZlbnREZWZTZWxlY3RlZCA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIC8vIGV2ZW50IHJlZmVyZW5jZXMgbWlnaHQgY2hhbmdlIG9uIHJlZmV0Y2hFdmVudHMoKSwgd2hpbGUgc2VsZWN0ZWRFdmVudEluc3RhbmNlIGRvZXNuJ3QsXHJcbiAgICAgICAgLy8gc28gY29tcGFyZSBJRHNcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgJiYgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UuZGVmLmlkID09PSBldmVudERlZi5pZDtcclxuICAgIH07XHJcbiAgICAvKiBNb3VzZSAvIFRvdWNoIFVuc2VsZWN0aW5nICh0aW1lIHJhbmdlICYgZXZlbnQgdW5zZWxlY3Rpb24pXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gVE9ETzogbW92ZSBjb25zaXN0ZW50bHkgdG8gZG93bi9zdGFydCBvciB1cC9lbmQ/XHJcbiAgICAvLyBUT0RPOiBkb24ndCBraWxsIHByZXZpb3VzIHNlbGVjdGlvbiBpZiB0b3VjaCBzY3JvbGxpbmdcclxuICAgIFZpZXcucHJvdG90eXBlLmhhbmRsZURvY3VtZW50TW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHV0aWxfMS5pc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzVW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSYW5nZVVuc2VsZWN0KGV2KTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudFVuc2VsZWN0KGV2KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzUmFuZ2VVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBpZ25vcmU7XHJcbiAgICAgICAgLy8gaXMgdGhlcmUgYSB0aW1lLXJhbmdlIHNlbGVjdGlvbj9cclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkICYmIHRoaXMub3B0KCd1bnNlbGVjdEF1dG8nKSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IHVuc2VsZWN0IGlmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IGlkZW50aWNhbCB0byBvciBpbnNpZGUgb2YgYW4gJ3Vuc2VsZWN0Q2FuY2VsJyBlbGVtZW50XHJcbiAgICAgICAgICAgIGlnbm9yZSA9IHRoaXMub3B0KCd1bnNlbGVjdENhbmNlbCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlnbm9yZSB8fCAhJChldi50YXJnZXQpLmNsb3Nlc3QoaWdub3JlKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NFdmVudFVuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJy5mYy1zZWxlY3RlZCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEV2ZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBUcmlnZ2Vyc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJCYXNlUmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdSZW5kZXInLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJCYXNlVW5yZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld0Rlc3Ryb3knLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdkYXlDbGljaydcclxuICAgIC8vIFNwYW4gaGFzIHN0YXJ0L2VuZCBvZiB0aGUgY2xpY2tlZCBhcmVhLiBPbmx5IHRoZSBzdGFydCBpcyB1c2VmdWwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBkYXlFbCwgZXYpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoZm9vdHByaW50KTsgLy8gYWJ1c2Ugb2YgXCJFdmVudFwiRGF0ZVByb2ZpbGU/XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2RheUNsaWNrJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBkYXlFbCxcclxuICAgICAgICAgICAgYXJnczogW2RhdGVQcm9maWxlLnN0YXJ0LCBldiwgdGhpc11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gRm9yIERhdGVDb21wb25lbnQ6OmdldERheUNsYXNzZXNcclxuICAgIFZpZXcucHJvdG90eXBlLmlzRGF0ZUluT3RoZXJNb250aCA9IGZ1bmN0aW9uIChkYXRlLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBBcmd1bWVudHMgYWZ0ZXIgbmFtZSB3aWxsIGJlIGZvcndhcmRlZCB0byBhIGh5cG90aGV0aWNhbCBmdW5jdGlvbiB2YWx1ZVxyXG4gICAgLy8gV0FSTklORzogcGFzc2VkLWluIGFyZ3VtZW50cyB3aWxsIGJlIGdpdmVuIHRvIGdlbmVyYXRvciBmdW5jdGlvbnMgYXMtaXMgYW5kIGNhbiBjYXVzZSBzaWRlLWVmZmVjdHMuXHJcbiAgICAvLyBBbHdheXMgY2xvbmUgeW91ciBvYmplY3RzIGlmIHlvdSBmZWFyIG11dGF0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0VW56b25lZFJhbmdlT3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5vcHQobmFtZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsID0gdmFsLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyLnBhcnNlVW56b25lZFJhbmdlKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhpZGRlbiBEYXlzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xyXG4gICAgVmlldy5wcm90b3R5cGUuaW5pdEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhpZGRlbkRheXMgPSB0aGlzLm9wdCgnaGlkZGVuRGF5cycpIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxyXG4gICAgICAgIHZhciBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxyXG4gICAgICAgIHZhciBkYXlDbnQgPSAwO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnd2Vla2VuZHMnKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9ICQuaW5BcnJheShpLCBoaWRkZW5EYXlzKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRheUNudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcclxuICAgIH07XHJcbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxyXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKGlucHV0VW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgZW5kID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIE1vbWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuaXNIaWRkZW5EYXkgPSBmdW5jdGlvbiAoZGF5KSB7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChkYXkpKSB7XHJcbiAgICAgICAgICAgIGRheSA9IGRheS5kYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XHJcbiAgICB9O1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxyXG4gICAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRVbnpvbmVkUmFuZ2UhXHJcbiAgICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxyXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcclxuICAgIFZpZXcucHJvdG90eXBlLnNraXBIaWRkZW5EYXlzID0gZnVuY3Rpb24gKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxyXG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGlzRXhjbHVzaXZlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgb3V0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsob3V0LmRheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddKSB7XHJcbiAgICAgICAgICAgIG91dC5hZGQoaW5jLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3O1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmlldztcclxuVmlldy5wcm90b3R5cGUudXNlc01pbk1heFRpbWUgPSBmYWxzZTtcclxuVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IERhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0RhdGVzJywgWydpc0luRG9tJywgJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlUmVuZGVyKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdCdXNpbmVzc0hvdXJzJywgWydkaXNwbGF5aW5nRGF0ZXMnLCAnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RCdXNpbmVzc0hvdXJzUmVuZGVyKGRlcHMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdpbml0aWFsRXZlbnRzJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hJbml0aWFsRXZlbnRzKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59KTtcclxuVmlldy53YXRjaCgnYmluZGluZ0V2ZW50cycsIFsnaW5pdGlhbEV2ZW50cyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdGhpcy5zZXRFdmVudHMoZGVwcy5pbml0aWFsRXZlbnRzKTtcclxuICAgIHRoaXMuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnVuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG4gICAgdGhpcy51bnNldEV2ZW50cygpO1xyXG59KTtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0V2ZW50cycsIFsnZGlzcGxheWluZ0RhdGVzJywgJ2hhc0V2ZW50cyddLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNSZW5kZXIodGhpcy5nZXQoJ2N1cnJlbnRFdmVudHMnKSk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEV2ZW50c1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCd0aXRsZScsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHJldHVybiAodGhpcy50aXRsZSA9IHRoaXMuY29tcHV0ZVRpdGxlKGRlcHMuZGF0ZVByb2ZpbGUpKTsgLy8gYXNzaWduIHRvIFZpZXcgZm9yIGxlZ2FjeSByZWFzb25zXHJcbn0pO1xyXG5WaWV3LndhdGNoKCdsZWdhY3lEYXRlUHJvcHMnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgdmFyIGRhdGVQcm9maWxlID0gZGVwcy5kYXRlUHJvZmlsZTtcclxuICAgIC8vIERFUFJFQ0FURUQsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXQgdXBkYXRlZC4uLlxyXG4gICAgdGhpcy5zdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgdGhpcy5lbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lbmRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsU3RhcnQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudFJlbmRlcmVyKGNvbXBvbmVudCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIgPSBmaWxsUmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmFuZ2VVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRUaW1lO1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgdGhpcy5ldmVudFRpbWVGb3JtYXQgPVxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnZXZlbnRUaW1lRm9ybWF0JykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0KCd0aW1lRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRXZlbnRUaW1lRm9ybWF0KCk7XHJcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IHRoaXMub3B0KCdkaXNwbGF5RXZlbnRUaW1lJyk7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50VGltZSgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gdGhpcy5vcHQoJ2Rpc3BsYXlFdmVudEVuZCcpO1xyXG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcGxheUV2ZW50VGltZSA9IGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRFbmQgPSBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNvbXBvbmVudC5fZ2V0RGF0ZVByb2ZpbGUoKTtcclxuICAgICAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VHcm91cDtcclxuICAgICAgICB2YXIgZXZlbnRSYW5nZXM7XHJcbiAgICAgICAgdmFyIGJnUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGZnUmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2VHcm91cCA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF07XHJcbiAgICAgICAgICAgIGV2ZW50UmFuZ2VzID0gaW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpLmhhc0JnUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2guYXBwbHkoYmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZnUmFuZ2VzLnB1c2guYXBwbHkoZmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckJnUmFuZ2VzKGJnUmFuZ2VzKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZnUmFuZ2VzKGZnUmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQmdSYW5nZXMoKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRmdSYW5nZXMoKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1JhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIC8vIHJlbmRlciBhbiBgLmVsYCBvbiBlYWNoIHNlZ1xyXG4gICAgICAgIC8vIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHNlZ3MuIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckZnU2Vncyh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICAgICAgdGhpcy5mZ1NlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyQmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckJnU2VncygpO1xyXG4gICAgICAgIHRoaXMuYmdTZWdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iZ1NlZ3MgfHwgW10pLmNvbmNhdCh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIHNlZ3MgYWxyZWFkeSBoYXMgcmVuZGVyZWQgZWxzLCBhbmQgaGFzIGJlZW4gZmlsdGVyZWQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaWduYWwgZmFpbHVyZSBpZiBub3QgaW1wbGVtZW50ZWRcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYmdFdmVudCcsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QmdDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldENzczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogX3RoaXMuZ2V0QmdDb2xvcihzZWcuZm9vdHByaW50LmV2ZW50RGVmKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyRWw6IGZ1bmN0aW9uIChzZWcsIGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2lnbmFsIGZhaWx1cmUgaWYgbm8gZmlsbFJlbmRlcmVyXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignYmdFdmVudCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdFbHMgPSBmdW5jdGlvbiAoc2VncywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZGlzYWJsZVJlc2l6aW5nID09PSB2b2lkIDApIHsgZGlzYWJsZVJlc2l6aW5nID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaGFzRXZlbnRSZW5kZXJIYW5kbGVycyA9IHRoaXMudmlldy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRSZW5kZXInKTtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIGV2ZW50IHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVGZ1NlZ0h0bWwoc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuZmdTZWdIdG1sKHNlZ3NbaV0sIGRpc2FibGVSZXNpemluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC4gQW4gZWwgbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnRSZW5kZXIgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UuXHJcbiAgICAgICAgICAgICQoaHRtbCkuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0V2ZW50UmVuZGVySGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9IF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZGF0YSgnZmMtc2VnJywgc2VnKTsgLy8gdXNlZCBieSBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRTZWdzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJlZm9yZUZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudC4gVXNlZCBieSByZW5kZXJGZ1NlZ0VscygpXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmljIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdGhlIEhUTUwgY2xhc3NOYW1lcyBmb3IgYW4gZXZlbnQgc2VnbWVudCdzIGVsZW1lbnRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ0NsYXNzZXMgPSBmdW5jdGlvbiAoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUpIHtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLWV2ZW50JyxcclxuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPyAnZmMtc3RhcnQnIDogJ2ZjLW5vdC1zdGFydCcsXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCA/ICdmYy1lbmQnIDogJ2ZjLW5vdC1lbmQnXHJcbiAgICAgICAgXS5jb25jYXQodGhpcy5nZXRDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKTtcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2FibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV2ZW50IGlzIGN1cnJlbnRseSBzZWxlY3RlZD8gYXR0YWNoIGEgY2xhc3NOYW1lLlxyXG4gICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlNlbGVjdGVkKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQgYW5kIHRoZSBkZWZhdWx0IGVsZW1lbnQgdXNlZCBmb3IgcmVuZGVyaW5nLCByZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGFjdHVhbGx5IGJlIHVzZWQuXHJcbiAgICAvLyBCYXNpY2FsbHkgcnVucyBldmVudHMgYW5kIGVsZW1lbnRzIHRocm91Z2ggdGhlIGV2ZW50UmVuZGVyIGhvb2suXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5maWx0ZXJFdmVudFJlbmRlckVsID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50LCBlbCkge1xyXG4gICAgICAgIHZhciBsZWdhY3kgPSBldmVudEZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgIHZhciBjdXN0b20gPSB0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBlbCwgdGhpcy52aWV3XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjdXN0b20gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tICYmIGN1c3RvbSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbCA9ICQoY3VzdG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIG9uIGFuIGV2ZW50J3MgZWxlbWVudC5cclxuICAgIC8vIGByYW5nZWAgY2FuIGJlIHRoZSBFdmVudCBvYmplY3QgaXRzZWxmLCBvciBzb21ldGhpbmcgcmFuZ2UtbGlrZSwgd2l0aCBhdCBsZWFzdCBhIGBzdGFydGAuXHJcbiAgICAvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXHJcbiAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBmb3JtYXRTdHIgd2lsbCBkZWZhdWx0IHRvIHRoZSBldmVudFRpbWVGb3JtYXQgc2V0dGluZyxcclxuICAgIC8vIGFuZCBkaXNwbGF5RW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgZGlzcGxheUV2ZW50RW5kIHNldHRpbmcuXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaW1lVGV4dCA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludCwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRpbWVUZXh0KGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuc3RhcnQsIGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuZW5kLCBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXksIGZvcm1hdFN0ciwgZGlzcGxheUVuZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuX2dldFRpbWVUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGlzQWxsRGF5LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0U3RyID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9ybWF0U3RyID0gdGhpcy5ldmVudFRpbWVGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUVuZCA9IHRoaXMuZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5RXZlbnRUaW1lICYmICFpc0FsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUVuZCAmJiBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcuZm9ybWF0UmFuZ2UoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0sIGZhbHNlLCAvLyBhbGxEYXlcclxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQuZm9ybWF0KGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJnQ2xhc3NlcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5nZXRDbGFzc2VzKGV2ZW50RGVmKTtcclxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWJnZXZlbnQnKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDbGFzc2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaC5hcHBseSgvLyBhcHBlbmRcclxuICAgICAgICAgICAgY2xhc3NOYW1lcywgb2Jqc1tpXS5ldmVudENsYXNzTmFtZSB8fCBvYmpzW2ldLmNsYXNzTmFtZSB8fCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgZXZlbnQgc2tpbi1yZWxhdGVkIENTUyBwcm9wZXJ0aWVzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTa2luQ3NzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldEJnQ29sb3IoZXZlbnREZWYpLFxyXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogdGhpcy5nZXRCb3JkZXJDb2xvcihldmVudERlZiksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmdldFRleHRDb2xvcihldmVudERlZilcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRCZ0NvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJhY2tncm91bmRDb2xvciB8fCBvYmpzW2ldLmV2ZW50Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0uYmFja2dyb3VuZENvbG9yIHx8IG9ianNbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudEJhY2tncm91bmRDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJvcmRlckNvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJvcmRlckNvbG9yIHx8IG9ianNbaV0uZXZlbnRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS5ib3JkZXJDb2xvciB8fCBvYmpzW2ldLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRleHRDb2xvciA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGggJiYgIXZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG9ianNbaV0uZXZlbnRUZXh0Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0udGV4dENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRUZXh0Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTdHlsaW5nT2JqcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRGYWxsYmFja1N0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICBvYmpzLnVuc2hpZnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHJldHVybiBvYmpzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEZhbGxiYWNrU3R5bGluZ09ianMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gW2V2ZW50RGVmLnNvdXJjZV07XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc29ydEV2ZW50U2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgc2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUV2ZW50U2VncycpKTtcclxuICAgIH07XHJcbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggc2VnbWVudHMgc2hvdWxkIHRha2UgdmlzdWFsIHByaW9yaXR5XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRXZlbnRTZWdzID0gZnVuY3Rpb24gKHNlZzEsIHNlZzIpIHtcclxuICAgICAgICB2YXIgZjEgPSBzZWcxLmZvb3RwcmludDtcclxuICAgICAgICB2YXIgZjIgPSBzZWcyLmZvb3RwcmludDtcclxuICAgICAgICB2YXIgY2YxID0gZjEuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciBjZjIgPSBmMi5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHIxID0gY2YxLnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgcjIgPSBjZjIudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHJldHVybiByMS5zdGFydE1zIC0gcjIuc3RhcnRNcyB8fCAvLyBlYXJsaWVyIGV2ZW50cyBnbyBmaXJzdFxyXG4gICAgICAgICAgICAocjIuZW5kTXMgLSByMi5zdGFydE1zKSAtIChyMS5lbmRNcyAtIHIxLnN0YXJ0TXMpIHx8IC8vIHRpZT8gbG9uZ2VyIGV2ZW50cyBnbyBmaXJzdFxyXG4gICAgICAgICAgICBjZjIuaXNBbGxEYXkgLSBjZjEuaXNBbGxEYXkgfHwgLy8gdGllPyBwdXQgYWxsLWRheSBldmVudHMgZmlyc3QgKGJvb2xlYW5zIGNhc3QgdG8gMC8xKVxyXG4gICAgICAgICAgICB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcyhmMS5ldmVudERlZiwgZjIuZXZlbnREZWYsIHRoaXMudmlldy5ldmVudE9yZGVyU3BlY3MsIGYxLmV2ZW50RGVmLm1pc2NQcm9wcywgZjIuZXZlbnREZWYubWlzY1Byb3BzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNDMgKi8sXG4vKiA0NCAqLyxcbi8qIDQ1ICovLFxuLyogNDYgKi8sXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuLy8gUGx1Z2luXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxubW9tZW50X2V4dF8xLm5ld01vbWVudFByb3RvLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIgJiYgYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICAvLyBtb21lbnQuZm9ybWF0KCkgZG9lc24ndCBlbnN1cmUgZW5nbGlzaCwgYnV0IHdlIHdhbnQgdG8uXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5tb21lbnRfZXh0XzEubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7XHJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIsIG1vbWVudCBtaWdodCBub3Qgb3V0cHV0IGVuZ2xpc2guIGVuc3VyZSBlbmdsaXNoLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMi4xOC4xL3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyNMMjJcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KGVuZ2xpc2hNb21lbnQodGhpcyksIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuZ2xpc2hNb21lbnQobW9tKSB7XHJcbiAgICBpZiAobW9tLmxvY2FsZSgpICE9PSAnZW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbS5jbG9uZSgpLmxvY2FsZSgnZW4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gQ29uZmlnXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5JbnNlcnRlZCBiZXR3ZWVuIGNodW5rcyBpbiB0aGUgZmFrZSAoXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0dGluZyBzdHJpbmcuXHJcbkltcG9ydGFudCB0aGF0IGl0IHBhc3NlcyBhcyB3aGl0ZXNwYWNlIChcXHMpIGJlY2F1c2UgbW9tZW50IG9mdGVuIGlkZW50aWZpZXMgbm9uLXN0YW5kYWxvbmUgbW9udGhzXHJcbnZpYSBhIHJlZ2V4cCB3aXRoIGFuIFxccy5cclxuKi9cclxudmFyIFBBUlRfU0VQQVJBVE9SID0gJ1xcdTAwMGInOyAvLyB2ZXJ0aWNhbCB0YWJcclxuLypcclxuSW5zZXJ0ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpdGVyYWwtdGV4dCBjaHVuayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBsaXRlcmFsIHRleHQgaXMgbm90IGFjdHVhbGx5IGxpdGVyYWwgdGV4dCxcclxuYnV0IHJhdGhlciwgYSBcInNwZWNpYWxcIiB0b2tlbiB0aGF0IGhhcyBjdXN0b20gcmVuZGVyaW5nIChzZWUgc3BlY2lhbFRva2VucyBtYXApLlxyXG4qL1xyXG52YXIgU1BFQ0lBTF9UT0tFTl9NQVJLRVIgPSAnXFx1MDAxZic7IC8vIGluZm9ybWF0aW9uIHNlcGFyYXRvciAxXHJcbi8qXHJcbkluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHNwYW4gb2YgdGV4dCB0aGF0IG11c3QgaGF2ZSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnMuXHJcbkhhbmRsaW5nIG9mIHRoZXNlIG1hcmtlcnMgaXMgZG9uZSBpbiBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0ZXh0IHJlbmRlcmluZy5cclxuKi9cclxudmFyIE1BWUJFX01BUktFUiA9ICdcXHUwMDFlJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDJcclxudmFyIE1BWUJFX1JFR0VYUCA9IG5ldyBSZWdFeHAoTUFZQkVfTUFSS0VSICsgJyhbXicgKyBNQVlCRV9NQVJLRVIgKyAnXSopJyArIE1BWUJFX01BUktFUiwgJ2cnKTsgLy8gbXVzdCBiZSBnbG9iYWxcclxuLypcclxuQWRkaXRpb24gZm9ybWF0dGluZyB0b2tlbnMgd2Ugd2FudCByZWNvZ25pemVkXHJcbiovXHJcbnZhciBzcGVjaWFsVG9rZW5zID0ge1xyXG4gICAgdDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcclxuICAgIH0sXHJcbiAgICBUOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xyXG4gICAgfVxyXG59O1xyXG4vKlxyXG5UaGUgZmlyc3QgY2hhcmFjdGVycyBvZiBmb3JtYXR0aW5nIHRva2VucyBmb3IgdW5pdHMgdGhhdCBhcmUgMSBkYXkgb3IgbGFyZ2VyLlxyXG5gdmFsdWVgIGlzIGZvciByYW5raW5nIHJlbGF0aXZlIHNpemUgKGxvd2VyIG1lYW5zIGJpZ2dlcikuXHJcbmB1bml0YCBpcyBhIG5vcm1hbGl6ZWQgdW5pdCwgdXNlZCBmb3IgY29tcGFyaW5nIG1vbWVudHMuXHJcbiovXHJcbnZhciBsYXJnZVRva2VuTWFwID0ge1xyXG4gICAgWTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXHJcbiAgICBNOiB7IHZhbHVlOiAyLCB1bml0OiAnbW9udGgnIH0sXHJcbiAgICBXOiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSxcclxuICAgIHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxyXG4gICAgRDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSxcclxuICAgIGQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0gLy8gZGF5IG9mIHdlZWtcclxufTtcclxuLy8gU2luZ2xlIERhdGUgRm9ybWF0dGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmQgc3BlY2lhbCB0b2tlblxyXG4qL1xyXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xyXG4gICAgcmV0dXJuIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikuZmFrZUZvcm1hdFN0cmluZywgZGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuLy8gRGF0ZSBSYW5nZSBGb3JtYXR0aW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVE9ETzogbWFrZSBpdCB3b3JrIHdpdGggdGltZXpvbmUgb2Zmc2V0XHJcbi8qXHJcblVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXHJcblwiU2VwIDIgLSA5IDIwMTNcIiwgdGhhdCBpbnRlbGxpZ2VudGx5IGluc2VydHMgYSBzZXBhcmF0b3Igd2hlcmUgdGhlIGRhdGVzIGRpZmZlci5cclxuSWYgdGhlIGRhdGVzIGFyZSB0aGUgc2FtZSBhcyBmYXIgYXMgdGhlIGZvcm1hdCBzdHJpbmcgaXMgY29uY2VybmVkLCBqdXN0IHJldHVybiBhIHNpbmdsZVxyXG5yZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cclxuKi9cclxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZGF0ZTEsIGRhdGUyLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgaXNSVEwpIHtcclxuICAgIHZhciBsb2NhbGVEYXRhO1xyXG4gICAgZGF0ZTEgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTEpO1xyXG4gICAgZGF0ZTIgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTIpO1xyXG4gICAgbG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcclxuICAgIC8vIEV4cGFuZCBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MsIGxpa2UgXCJMTFwiIC0+IFwiTU1NTSBEIFlZWVlcIi5cclxuICAgIC8vIEJUVywgdGhpcyBpcyBub3QgaW1wb3J0YW50IGZvciBgZm9ybWF0RGF0ZWAgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIHB1dCBjdXN0b20gdG9rZW5zXHJcbiAgICAvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXHJcbiAgICBmb3JtYXRTdHIgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KGZvcm1hdFN0cikgfHwgZm9ybWF0U3RyO1xyXG4gICAgcmV0dXJuIHJlbmRlclBhcnNlZEZvcm1hdChnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IgfHwgJyAtICcsIGlzUlRMKTtcclxufVxyXG5leHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XHJcbi8qXHJcblJlbmRlcnMgYSByYW5nZSB3aXRoIGFuIGFscmVhZHktcGFyc2VkIGZvcm1hdCBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlclBhcnNlZEZvcm1hdChwYXJzZWRGb3JtYXQsIGRhdGUxLCBkYXRlMiwgc2VwYXJhdG9yLCBpc1JUTCkge1xyXG4gICAgdmFyIHNhbWVVbml0cyA9IHBhcnNlZEZvcm1hdC5zYW1lVW5pdHM7XHJcbiAgICB2YXIgdW56b25lZERhdGUxID0gZGF0ZTEuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gZm9yIHNhbWUtdW5pdCBjb21wYXJpc29uc1xyXG4gICAgdmFyIHVuem9uZWREYXRlMiA9IGRhdGUyLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIFwiXHJcbiAgICB2YXIgcmVuZGVyZWRQYXJ0czEgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUxKTtcclxuICAgIHZhciByZW5kZXJlZFBhcnRzMiA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTIpO1xyXG4gICAgdmFyIGxlZnRJO1xyXG4gICAgdmFyIGxlZnRTdHIgPSAnJztcclxuICAgIHZhciByaWdodEk7XHJcbiAgICB2YXIgcmlnaHRTdHIgPSAnJztcclxuICAgIHZhciBtaWRkbGVJO1xyXG4gICAgdmFyIG1pZGRsZVN0cjEgPSAnJztcclxuICAgIHZhciBtaWRkbGVTdHIyID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlU3RyID0gJyc7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxyXG4gICAgLy8gdGhhdCBpcyBub3QgdGhlIHNhbWUgYmV0d2VlbiBkYXRlcy5cclxuICAgIGZvciAobGVmdEkgPSAwOyBsZWZ0SSA8IHNhbWVVbml0cy5sZW5ndGggJiYgKCFzYW1lVW5pdHNbbGVmdEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbbGVmdEldKSk7IGxlZnRJKyspIHtcclxuICAgICAgICBsZWZ0U3RyICs9IHJlbmRlcmVkUGFydHMxW2xlZnRJXTtcclxuICAgIH1cclxuICAgIC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XHJcbiAgICBmb3IgKHJpZ2h0SSA9IHNhbWVVbml0cy5sZW5ndGggLSAxOyByaWdodEkgPiBsZWZ0SSAmJiAoIXNhbWVVbml0c1tyaWdodEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbcmlnaHRJXSkpOyByaWdodEktLSkge1xyXG4gICAgICAgIC8vIElmIGN1cnJlbnQgY2h1bmsgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHVuaXF1ZSBkYXRlLWNvbnRlbnQsIGFuZCBpcyBhIHNwZWNpYWwtY2FzZVxyXG4gICAgICAgIC8vIGRhdGUtZm9ybWF0dGluZyBwb3N0Zml4IGNoYXJhY3RlciwgdGhlbiBkb24ndCBjb25zdW1lIGl0LiBDb25zaWRlciBpdCB1bmlxdWUgZGF0ZS1jb250ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXHJcbiAgICAgICAgaWYgKHJpZ2h0SSAtIDEgPT09IGxlZnRJICYmIHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gPT09ICcuJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRTdHIgPSByZW5kZXJlZFBhcnRzMVtyaWdodEldICsgcmlnaHRTdHI7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXHJcbiAgICAvLyBDb2xsZWN0IHRoZW0gZGlzdGluY3RseSBzbyB3ZSBjYW4gamFtIHRoZW0gdG9nZXRoZXIgbGF0ZXIuXHJcbiAgICBmb3IgKG1pZGRsZUkgPSBsZWZ0STsgbWlkZGxlSSA8PSByaWdodEk7IG1pZGRsZUkrKykge1xyXG4gICAgICAgIG1pZGRsZVN0cjEgKz0gcmVuZGVyZWRQYXJ0czFbbWlkZGxlSV07XHJcbiAgICAgICAgbWlkZGxlU3RyMiArPSByZW5kZXJlZFBhcnRzMlttaWRkbGVJXTtcclxuICAgIH1cclxuICAgIGlmIChtaWRkbGVTdHIxIHx8IG1pZGRsZVN0cjIpIHtcclxuICAgICAgICBpZiAoaXNSVEwpIHtcclxuICAgICAgICAgICAgbWlkZGxlU3RyID0gbWlkZGxlU3RyMiArIHNlcGFyYXRvciArIG1pZGRsZVN0cjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvY2Vzc01heWJlTWFya2VycyhsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHIpO1xyXG59XHJcbi8vIEZvcm1hdCBTdHJpbmcgUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxudmFyIHBhcnNlZEZvcm1hdFN0ckNhY2hlID0ge307XHJcbi8qXHJcblJldHVybnMgYSBwYXJzZWQgZm9ybWF0IHN0cmluZywgbGV2ZXJhZ2luZyBhIGNhY2hlLlxyXG4qL1xyXG5mdW5jdGlvbiBnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSB8fFxyXG4gICAgICAgIChwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdID0gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSk7XHJcbn1cclxuLypcclxuUGFyc2VzIGEgZm9ybWF0IHN0cmluZyBpbnRvIHRoZSBmb2xsb3dpbmc6XHJcbi0gZmFrZUZvcm1hdFN0cmluZzogYSBtb21lbnRKUyBmb3JtYXR0aW5nIHN0cmluZywgbGl0dGVyZWQgd2l0aCBzcGVjaWFsIGNvbnRyb2wgY2hhcmFjdGVycyB0aGF0IGdldCBwb3N0LXByb2Nlc3NlZC5cclxuLSBzYW1lVW5pdHM6IGZvciBldmVyeSBwYXJ0IGluIGZha2VGb3JtYXRTdHJpbmcsIGlmIHRoZSBwYXJ0IGlzIGEgdG9rZW4sIHRoZSB2YWx1ZSB3aWxsIGJlIGEgdW5pdCBzdHJpbmcgKGxpa2UgXCJkYXlcIiksXHJcbiAgdGhhdCBpbmRpY2F0ZXMgaG93IHNpbWlsYXIgYSByYW5nZSdzIHN0YXJ0ICYgZW5kIG11c3QgYmUgaW4gb3JkZXIgdG8gc2hhcmUgdGhlIHNhbWUgZm9ybWF0dGVkIHRleHQuXHJcbiAgSWYgbm90IGEgdG9rZW4sIHRoZW4gdGhlIHZhbHVlIGlzIG51bGwuXHJcbiAgQWx3YXlzIGEgZmxhdCBhcnJheSAobm90IG5lc3RlZCBsaWtlZCBcImNodW5rc1wiKS5cclxuKi9cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmFrZUZvcm1hdFN0cmluZzogYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcyksXHJcbiAgICAgICAgc2FtZVVuaXRzOiBidWlsZFNhbWVVbml0cyhjaHVua3MpXHJcbiAgICB9O1xyXG59XHJcbi8qXHJcbkJyZWFrIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGNodW5rcy5cclxuQSAnbWF5YmUnIGNodW5rIHdpbGwgaGF2ZSBuZXN0ZWQgY2h1bmtzLlxyXG4qL1xyXG5mdW5jdGlvbiBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBbXTtcclxuICAgIHZhciBtYXRjaDtcclxuICAgIC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cclxuICAgIC8vIFxcNCBpcyBhIGJhY2tyZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIG11bHRpLWNoYXJhY3RlciBzZXQuXHJcbiAgICB2YXIgY2h1bmtlciA9IC9cXFsoW15cXF1dKilcXF18XFwoKFteXFwpXSopXFwpfChMVFN8TFR8KFxcdylcXDQqbz8pfChbXlxcd1xcW1xcKF0rKS9nO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IGNodW5rZXIuZXhlYyhmb3JtYXRTdHIpKSkge1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaC5hcHBseShjaHVua3MsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBzcGxpdFN0cmluZ0xpdGVyYWwobWF0Y2hbMV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goeyBtYXliZTogY2h1bmtGb3JtYXRTdHJpbmcobWF0Y2hbMl0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCh7IHRva2VuOiBtYXRjaFszXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbNV0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgc3BsaXRTdHJpbmdMaXRlcmFsKG1hdGNoWzVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNodW5rcztcclxufVxyXG4vKlxyXG5Qb3RlbnRpYWxseSBzcGxpdHMgYSBsaXRlcmFsLXRleHQgc3RyaW5nIGludG8gbXVsdGlwbGUgcGFydHMuIEZvciBzcGVjaWFsIGNhc2VzLlxyXG4qL1xyXG5mdW5jdGlvbiBzcGxpdFN0cmluZ0xpdGVyYWwocykge1xyXG4gICAgaWYgKHMgPT09ICcuICcpIHtcclxuICAgICAgICByZXR1cm4gWycuJywgJyAnXTsgLy8gZm9yIGxvY2FsZXMgd2l0aCBwZXJpb2RzIGJvdW5kIHRvIHRoZSBlbmQgb2YgZWFjaCB5ZWFyL21vbnRoL2RhdGVcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbc107XHJcbiAgICB9XHJcbn1cclxuLypcclxuR2l2ZW4gY2h1bmtzIHBhcnNlZCBmcm9tIGEgcmVhbCBmb3JtYXQgc3RyaW5nLCBnZW5lcmF0ZSBhIGZha2UgKGFrYSBcImludGVybWVkaWF0ZVwiKSBmb3JtYXQgc3RyaW5nIHdpdGggc3BlY2lhbCBjb250cm9sXHJcbmNoYXJhY3RlcnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgZ2l2ZW4gdG8gbW9tZW50IGZvciBmb3JtYXR0aW5nLCBhbmQgdGhlbiBwb3N0LXByb2Nlc3NlZC5cclxuKi9cclxuZnVuY3Rpb24gYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcykge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjaHVuaztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdbJyArIGNodW5rICsgJ10nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNodW5rLnRva2VuIGluIHNwZWNpYWxUb2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goU1BFQ0lBTF9UT0tFTl9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICdbJyArIGNodW5rLnRva2VuICsgJ10nIC8vIHByZXNlcnZlIGFzIGxpdGVyYWwgdGV4dFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goY2h1bmsudG9rZW4pOyAvLyB1bnByb3RlY3RlZCB0ZXh0IGltcGxpZXMgYSBmb3JtYXQgc3RyaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChNQVlCRV9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rLm1heWJlKSArXHJcbiAgICAgICAgICAgICAgICBNQVlCRV9NQVJLRVIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJ0cy5qb2luKFBBUlRfU0VQQVJBVE9SKTtcclxufVxyXG4vKlxyXG5HaXZlbiBwYXJzZWQgY2h1bmtzIGZyb20gYSByZWFsIGZvcm1hdHRpbmcgc3RyaW5nLCBnZW5lcmF0ZXMgYW4gYXJyYXkgb2YgdW5pdCBzdHJpbmdzIChsaWtlIFwiZGF5XCIpIHRoYXQgaW5kaWNhdGVcclxuaW4gd2hpY2ggcmVnYXJkIHR3byBkYXRlcyBtdXN0IGJlIHNpbWlsYXIgaW4gb3JkZXIgdG8gc2hhcmUgcmFuZ2UgZm9ybWF0dGluZyB0ZXh0LlxyXG5UaGUgYGNodW5rc2AgY2FuIGJlIG5lc3RlZCAoYmVjYXVzZSBvZiBcIm1heWJlXCIgY2h1bmtzKSwgaG93ZXZlciwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgYmUgZmxhdC5cclxuKi9cclxuZnVuY3Rpb24gYnVpbGRTYW1lVW5pdHMoY2h1bmtzKSB7XHJcbiAgICB2YXIgdW5pdHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGNodW5rO1xyXG4gICAgdmFyIHRva2VuSW5mbztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgdG9rZW5JbmZvID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKHRva2VuSW5mbyA/IHRva2VuSW5mby51bml0IDogJ3NlY29uZCcpOyAvLyBkZWZhdWx0IHRvIGEgdmVyeSBzdHJpY3Qgc2FtZS1zZWNvbmRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcclxuICAgICAgICAgICAgdW5pdHMucHVzaC5hcHBseSh1bml0cywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGJ1aWxkU2FtZVVuaXRzKGNodW5rLm1heWJlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bml0cztcclxufVxyXG4vLyBSZW5kZXJpbmcgdG8gdGV4dFxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgd2l0aCBhIGZha2UgZm9ybWF0IHN0cmluZywgcG9zdC1wcm9jZXNzZXMgdGhlIGNvbnRyb2wgY2hhcmFjdGVycywgdGhlbiByZXR1cm5zLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHJldHVybiBwcm9jZXNzTWF5YmVNYXJrZXJzKHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKS5qb2luKCcnKSk7XHJcbn1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgaW50byBwYXJ0cyB0aGF0IHdpbGwgaGF2ZSBiZWVuIHBvc3QtcHJvY2Vzc2VkLCBFWENFUFQgZm9yIHRoZSBcIm1heWJlXCIgbWFya2Vycy5cclxuKi9cclxuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGZha2VSZW5kZXIgPSBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsIGZha2VGb3JtYXRTdHJpbmcpO1xyXG4gICAgdmFyIGZha2VQYXJ0cyA9IGZha2VSZW5kZXIuc3BsaXQoUEFSVF9TRVBBUkFUT1IpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZmFrZVBhcnQ7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmFrZVBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZmFrZVBhcnQgPSBmYWtlUGFydHNbaV07XHJcbiAgICAgICAgaWYgKGZha2VQYXJ0LmNoYXJBdCgwKSA9PT0gU1BFQ0lBTF9UT0tFTl9NQVJLRVIpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChcclxuICAgICAgICAgICAgLy8gdGhlIGxpdGVyYWwgc3RyaW5nIElTIHRoZSB0b2tlbidzIG5hbWUuXHJcbiAgICAgICAgICAgIC8vIGNhbGwgc3BlY2lhbCB0b2tlbidzIHJlZ2lzdGVyZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIHNwZWNpYWxUb2tlbnNbZmFrZVBhcnQuc3Vic3RyaW5nKDEpXShkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGZha2VQYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydHM7XHJcbn1cclxuLypcclxuQWNjZXB0cyBhbiBhbG1vc3QtZmluYWxseS1mb3JtYXR0ZWQgc3RyaW5nIGFuZCBwcm9jZXNzZXMgdGhlIFwibWF5YmVcIiBjb250cm9sIGNoYXJhY3RlcnMsIHJldHVybmluZyBhIG5ldyBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHByb2Nlc3NNYXliZU1hcmtlcnMocykge1xyXG4gICAgcmV0dXJuIHMucmVwbGFjZShNQVlCRV9SRUdFWFAsIGZ1bmN0aW9uIChtMCwgbTEpIHtcclxuICAgICAgICBpZiAobTEubWF0Y2goL1sxLTldLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vIE1pc2MgVXRpbHNcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5SZXR1cm5zIGEgdW5pdCBzdHJpbmcsIGVpdGhlciAneWVhcicsICdtb250aCcsICdkYXknLCBvciBudWxsIGZvciB0aGUgbW9zdCBncmFudWxhciBmb3JtYXR0aW5nIHRva2VuIGluIHRoZSBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdChmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY2h1bms7XHJcbiAgICB2YXIgY2FuZGlkYXRlO1xyXG4gICAgdmFyIGJlc3Q7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgaWYgKGNodW5rLnRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGxhcmdlVG9rZW5NYXBbY2h1bmsudG9rZW4uY2hhckF0KDApXTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiZXN0IHx8IGNhbmRpZGF0ZS52YWx1ZSA+IGJlc3QudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0ID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJlc3QpIHtcclxuICAgICAgICByZXR1cm4gYmVzdC51bml0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9kZWwoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fd2F0Y2hlcnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5fcHJvcHMgPSB7fTtcclxuICAgICAgICBfdGhpcy5hcHBseUdsb2JhbFdhdGNoZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuY29uc3RydWN0ZWQoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb2RlbC53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBtYWtlIGEgbWFza2VkLWNvcHkgb2YgdGhlIHN1cGVyY2xhc3MncyBtYXBcclxuICAgICAgICAvLyBUT0RPOiB3cml0ZSB0ZXN0XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX2dsb2JhbFdhdGNoQXJncycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzW25hbWVdID0gYXJncztcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtb25rZXlwYXRjaGluZy4gVE9ETzogQmFzZUNsYXNzP1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcHBseUdsb2JhbFdhdGNoZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9nbG9iYWxXYXRjaEFyZ3M7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLndhdGNoLmFwcGx5KHRoaXMsIFtuYW1lXS5jb25jYXQobWFwW25hbWVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lIGluIHRoaXMuX3Byb3BzO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lXSA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhuZXdQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIG9sZFByb3BzID0gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNldCA9IHt9OyAvLyB3aWxsIGhhdmUgdW5kZWZpbmVkJ3MgdG8gc2lnbmFsIHVuc2V0c1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSBuZXdQcm9wc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhjaGFuZ2VzZXQpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIG5hbWVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZXMgPSBbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuYW1lcyA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lc1tpXV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xyXG4gICAgICAgIHZhciBjaGFuZ2VkUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgY2hhbmdlZENudCA9IDA7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gbmV3UHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIC8vIGEgY2hhbmdlIGluIHZhbHVlP1xyXG4gICAgICAgICAgICAvLyBpZiBhbiBvYmplY3QsIGRvbid0IGNoZWNrIGVxdWFsaXR5LCBiZWNhdXNlIG1pZ2h0IGhhdmUgYmVlbiBtdXRhdGVkIGludGVybmFsbHkuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGV2ZW50dWFsbHkgZW5mb3JjZSBpbW11dGFiaWxpdHkuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgdmFsICE9PSB0aGlzLl9wcm9wc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BzW25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VkQ250KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmJhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcclxuICAgICAgICAgICAgZm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY2hhbmdlZFByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlJywgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZTonICsgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmF0Y2hDaGFuZ2UnLCBjaGFuZ2VkUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAobmFtZSwgZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51bndhdGNoKG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3dhdGNoZXJzW25hbWVdID0gdGhpcy5fd2F0Y2hEZXBzKGRlcExpc3QsIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBzdGFydEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVuc2V0KG5hbWUpOyAvLyBwdXQgaW4gYW4gdW5zZXQgc3RhdGUgd2hpbGUgcmVzb2x2aW5nXHJcbiAgICAgICAgICAgICAgICByZXMudGhlbihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldChuYW1lLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5zZXQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9wRnVuYykge1xyXG4gICAgICAgICAgICAgICAgc3RvcEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLl93YXRjaERlcHMgPSBmdW5jdGlvbiAoZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHF1ZXVlZENoYW5nZUNudCA9IDA7XHJcbiAgICAgICAgdmFyIGRlcENudCA9IGRlcExpc3QubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzYXRpc2Z5Q250ID0gMDtcclxuICAgICAgICB2YXIgdmFsdWVzID0ge307IC8vIHdoYXQncyBwYXNzZWQgYXMgdGhlIGBkZXBzYCBhcmd1bWVudHNcclxuICAgICAgICB2YXIgYmluZFR1cGxlcyA9IFtdOyAvLyBhcnJheSBvZiBbIGV2ZW50TmFtZSwgaGFuZGxlckZ1bmMgXSBhcnJheXNcclxuICAgICAgICB2YXIgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBvbkJlZm9yZURlcENoYW5nZSA9IGZ1bmN0aW9uIChkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgcXVldWVkQ2hhbmdlQ250Kys7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZWRDaGFuZ2VDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0NhbGxpbmdTdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uRGVwQ2hhbmdlID0gZnVuY3Rpb24gKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGRlcGVuZGVuY3kgdGhhdCB3YXMgcHJldmlvdXNseSBzZXQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXRpc2Z5Q250LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2RlcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHVuc2V0P1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2RlcE5hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXVlZENoYW5nZUNudC0tO1xyXG4gICAgICAgICAgICBpZiAoIXF1ZXVlZENoYW5nZUNudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm93IGZpbmFsbHkgc2F0aXNmaWVkIG9yIHNhdGlzZmllZCBhbGwgYWxvbmc/XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0b3BGdW5jIGluaXRpYXRlZCBhbm90aGVyIHZhbHVlIGNoYW5nZSwgaWdub3JlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGFub3RoZXIgY2hhbmdlIGV2ZW50IGFueXdheS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FsbGluZ1N0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBpbnRlcmNlcHQgZm9yIC5vbigpIHRoYXQgcmVtZW1iZXJzIGhhbmRsZXJzXHJcbiAgICAgICAgdmFyIGJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGJpbmRUdXBsZXMucHVzaChbZXZlbnROYW1lLCBoYW5kbGVyXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBsaXN0ZW4gdG8gZGVwZW5kZW5jeSBjaGFuZ2VzXHJcbiAgICAgICAgZGVwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXBOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChkZXBOYW1lLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiaW5kKCdiZWZvcmU6Y2hhbmdlOicgKyBkZXBOYW1lLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvbkJlZm9yZURlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYmluZCgnY2hhbmdlOicgKyBkZXBOYW1lLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvbkRlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBwcm9jZXNzIGN1cnJlbnQgZGVwZW5kZW5jeSB2YWx1ZXNcclxuICAgICAgICBkZXBMaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlcE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGRlcE5hbWUuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBkZXBOYW1lLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXMoZGVwTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tkZXBOYW1lXSA9IF90aGlzLmdldChkZXBOYW1lKTtcclxuICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBpbml0aWFsbHkgc2F0aXNmaWVkXHJcbiAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZFR1cGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihiaW5kVHVwbGVzW2ldWzBdLCBiaW5kVHVwbGVzW2ldWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJpbmRUdXBsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FzIHNhdGlzZmllZCwgc28gY2FsbCBzdG9wRnVuY1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZsYXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEZ1bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmZsYXNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXIuZmxhc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVsO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb2RlbDtcclxuTW9kZWwucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSB7fTsgLy8gbXV0YXRpb24gcHJvdGVjdGlvbiBpbiBNb2RlbC53YXRjaFxyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW9kZWwpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKE1vZGVsKTtcclxuXG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKGV2ZW50SW5wdXQsIHNvdXJjZSkge1xyXG4gICAgICAgIGlmICh1dGlsXzEuaXNUaW1lU3RyaW5nKGV2ZW50SW5wdXQuc3RhcnQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuc3RhcnQpIHx8XHJcbiAgICAgICAgICAgIHV0aWxfMS5pc1RpbWVTdHJpbmcoZXZlbnRJbnB1dC5lbmQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuZW5kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmRGF0ZU11dGF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlVGltZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlQWxsRGF5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5jcmVhdGVGcm9tRGlmZiA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZTAsIGRhdGVQcm9maWxlMSwgbGFyZ2VVbml0KSB7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gZGF0ZVByb2ZpbGUwLmVuZCAmJiAhZGF0ZVByb2ZpbGUxLmVuZDtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGRhdGVQcm9maWxlMC5pc0FsbERheSgpICYmICFkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKTtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSAhZGF0ZVByb2ZpbGUwLmlzQWxsRGF5KCkgJiYgZGF0ZVByb2ZpbGUxLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgdmFyIGRhdGVEZWx0YTtcclxuICAgICAgICB2YXIgZW5kRGlmZjtcclxuICAgICAgICB2YXIgZW5kRGVsdGE7XHJcbiAgICAgICAgdmFyIG11dGF0aW9uO1xyXG4gICAgICAgIC8vIHN1YnRyYWN0cyB0aGUgZGF0ZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHdheSwgcmV0dXJuaW5nIGEgZHVyYXRpb25cclxuICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdERhdGVzKGRhdGUxLCBkYXRlMCkge1xyXG4gICAgICAgICAgICBpZiAobGFyZ2VVbml0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoZGF0ZTEsIGRhdGUwLCBsYXJnZVVuaXQpOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5KGRhdGUxLCBkYXRlMCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShkYXRlMSwgZGF0ZTApOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlRGVsdGEgPSBzdWJ0cmFjdERhdGVzKGRhdGVQcm9maWxlMS5zdGFydCwgZGF0ZVByb2ZpbGUwLnN0YXJ0KTtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUxLmVuZCkge1xyXG4gICAgICAgICAgICAvLyB1c2UgdW56b25lZFJhbmdlcyBiZWNhdXNlIGRhdGVQcm9maWxlMC5lbmQgbWlnaHQgYmUgbnVsbFxyXG4gICAgICAgICAgICBlbmREaWZmID0gc3VidHJhY3REYXRlcyhkYXRlUHJvZmlsZTEudW56b25lZFJhbmdlLmdldEVuZCgpLCBkYXRlUHJvZmlsZTAudW56b25lZFJhbmdlLmdldEVuZCgpKTtcclxuICAgICAgICAgICAgZW5kRGVsdGEgPSBlbmREaWZmLnN1YnRyYWN0KGRhdGVEZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uKCk7XHJcbiAgICAgICAgbXV0YXRpb24uY2xlYXJFbmQgPSBjbGVhckVuZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZUFsbERheSA9IGZvcmNlQWxsRGF5O1xyXG4gICAgICAgIG11dGF0aW9uLnNldERhdGVEZWx0YShkYXRlRGVsdGEpO1xyXG4gICAgICAgIG11dGF0aW9uLnNldEVuZERlbHRhKGVuZERlbHRhKTtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvbi5cclxuICAgICovXHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuYnVpbGROZXdEYXRlUHJvZmlsZSA9IGZ1bmN0aW9uIChldmVudERhdGVQcm9maWxlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydCA9IGV2ZW50RGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZW5kID0gbnVsbDtcclxuICAgICAgICB2YXIgc2hvdWxkUmV6b25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0ZVByb2ZpbGUuZW5kICYmICF0aGlzLmNsZWFyRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGV2ZW50RGF0ZVByb2ZpbGUuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kRGVsdGEgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREYXRlUHJvZmlsZS5pc0FsbERheSgpLCBzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlVGltZWQpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCAmJiAhZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmIGVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRlRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRhdGVEZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG8gdGhpcyBiZWZvcmUgYWRkaW5nIHN0YXJ0RGVsdGEgdG8gc3RhcnQsIHNvIHdlIGNhbiB3b3JrIG9mZiBvZiBzdGFydFxyXG4gICAgICAgIGlmICh0aGlzLmVuZERlbHRhKSB7XHJcbiAgICAgICAgICAgIHNob3VsZFJlem9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGVuZC5hZGQodGhpcy5lbmREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuc3RhcnREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXpvbmUpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9rYXkgdG8gYWNjZXNzIGNhbGVuZGFyIG9wdGlvbj9cclxuICAgICAgICBpZiAoIWVuZCAmJiBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChzdGFydCwgZW5kLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldERhdGVEZWx0YSA9IGZ1bmN0aW9uIChkYXRlRGVsdGEpIHtcclxuICAgICAgICBpZiAoZGF0ZURlbHRhICYmIGRhdGVEZWx0YS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlRGVsdGEgPSBkYXRlRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5zZXRTdGFydERlbHRhID0gZnVuY3Rpb24gKHN0YXJ0RGVsdGEpIHtcclxuICAgICAgICBpZiAoc3RhcnREZWx0YSAmJiBzdGFydERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBzdGFydERlbHRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldEVuZERlbHRhID0gZnVuY3Rpb24gKGVuZERlbHRhKSB7XHJcbiAgICAgICAgaWYgKGVuZERlbHRhICYmIGVuZERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gZW5kRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNsZWFyRW5kICYmICF0aGlzLmZvcmNlVGltZWQgJiYgIXRoaXMuZm9yY2VBbGxEYXkgJiZcclxuICAgICAgICAgICAgIXRoaXMuZGF0ZURlbHRhICYmICF0aGlzLnN0YXJ0RGVsdGEgJiYgIXRoaXMuZW5kRGVsdGE7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmRGF0ZU11dGF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZkRhdGVNdXRhdGlvbjtcclxuXG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3RhbmRhcmRUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTMpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpO1xyXG52YXIgdGhlbWVDbGFzc0hhc2ggPSB7fTtcclxuZnVuY3Rpb24gZGVmaW5lVGhlbWVTeXN0ZW0odGhlbWVOYW1lLCB0aGVtZUNsYXNzKSB7XHJcbiAgICB0aGVtZUNsYXNzSGFzaFt0aGVtZU5hbWVdID0gdGhlbWVDbGFzcztcclxufVxyXG5leHBvcnRzLmRlZmluZVRoZW1lU3lzdGVtID0gZGVmaW5lVGhlbWVTeXN0ZW07XHJcbmZ1bmN0aW9uIGdldFRoZW1lU3lzdGVtQ2xhc3ModGhlbWVTZXR0aW5nKSB7XHJcbiAgICBpZiAoIXRoZW1lU2V0dGluZykge1xyXG4gICAgICAgIHJldHVybiBTdGFuZGFyZFRoZW1lXzEuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoZW1lU2V0dGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBKcXVlcnlVaVRoZW1lXzEuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGVtZUNsYXNzSGFzaFt0aGVtZVNldHRpbmddO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0VGhlbWVTeXN0ZW1DbGFzcyA9IGdldFRoZW1lU3lzdGVtQ2xhc3M7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEFycmF5RXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBcnJheUV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJyYXlFdmVudFNvdXJjZShjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmV2ZW50RGVmcyA9IFtdOyAvLyBmb3IgaWYgc2V0UmF3RXZlbnREZWZzIGlzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFycmF5RXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd0lucHV0LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgZXZlbnRzOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5zZXRSYXdFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdGhpcy5yYXdFdmVudERlZnMgPSByYXdFdmVudERlZnM7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSB0aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcyk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gdGhpcy5ldmVudERlZnM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRpbWV6b25lICE9IG51bGwgJiZcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgIT09IHRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZnNbaV0gaW5zdGFuY2VvZiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZnNbaV0ucmV6b25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgPSB0aW1lem9uZTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZShldmVudERlZnMpO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMucHVzaChldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGV2ZW50RGVmSWQgYWxyZWFkeSBub3JtYWxpemVkIHRvIGEgc3RyaW5nXHJcbiAgICAqL1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5yZW1vdmVNYXRjaGluZyh0aGlzLmV2ZW50RGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSBbXTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3RXZlbnREZWZzO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB0aGlzLnNldFJhd0V2ZW50RGVmcyhyYXdQcm9wcy5ldmVudHMpO1xyXG4gICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFycmF5RXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFycmF5RXZlbnRTb3VyY2U7XHJcbkFycmF5RXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBldmVudHM6IGZhbHNlIC8vIGRvbid0IGF1dG9tYXRpY2FsbHkgdHJhbnNmZXJcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLypcclxuQSBjYWNoZSBmb3IgdGhlIGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQgdmFsdWVzIGZvciBvbmUgb3IgbW9yZSBlbGVtZW50cy5cclxuV29ya3Mgd2l0aCBib3RoIG9mZnNldCAoZnJvbSB0b3BsZWZ0IGRvY3VtZW50KSBhbmQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50KS5cclxuXG5vcHRpb25zOlxyXG4tIGVsc1xyXG4tIGlzSG9yaXpvbnRhbFxyXG4tIGlzVmVydGljYWxcclxuKi9cclxudmFyIENvb3JkQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb29yZENhY2hlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IGZhbHNlOyAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciBsZWZ0L3JpZ2h0L3dpZHRoXHJcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gcXVlcnkgZm9yIHRvcC9ib3R0b20vaGVpZ2h0XHJcbiAgICAgICAgdGhpcy5lbHMgPSAkKG9wdGlvbnMuZWxzKTtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IG9wdGlvbnMuaXNIb3Jpem9udGFsO1xyXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IG9wdGlvbnMuaXNWZXJ0aWNhbDtcclxuICAgICAgICB0aGlzLmZvcmNlZE9mZnNldFBhcmVudEVsID0gb3B0aW9ucy5vZmZzZXRQYXJlbnQgPyAkKG9wdGlvbnMub2Zmc2V0UGFyZW50KSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyaWVzIHRoZSBlbHMgZm9yIGNvb3JkaW5hdGVzIGFuZCBzdG9yZXMgdGhlbS5cclxuICAgIC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEVsID0gdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbDtcclxuICAgICAgICBpZiAoIW9mZnNldFBhcmVudEVsICYmIHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50RWwgPSB0aGlzLmVscy5lcSgwKS5vZmZzZXRQYXJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBvZmZzZXRQYXJlbnRFbCA/XHJcbiAgICAgICAgICAgIG9mZnNldFBhcmVudEVsLm9mZnNldCgpIDpcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmVjdCA9IHRoaXMucXVlcnlCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGVzdHJveXMgYWxsIGludGVybmFsIGRhdGEgYWJvdXQgY29vcmRpbmF0ZXMsIGZyZWVpbmcgbWVtb3J5XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JlY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVmdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRvcHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm90dG9tcyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gV2hlbiBjYWxsZWQsIGlmIGNvb3JkIGNhY2hlcyBhcmVuJ3QgYnVpbHQsIGJ1aWxkcyB0aGVtXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5lbnN1cmVCdWlsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZEVsSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRzID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWxzLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGxlZnRzLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgIHJpZ2h0cy5wdXNoKGxlZnQgKyB3aWR0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xyXG4gICAgfTtcclxuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGRFbFZlcnRpY2FscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG9wcyA9IFtdO1xyXG4gICAgICAgIHZhciBib3R0b21zID0gW107XHJcbiAgICAgICAgdGhpcy5lbHMuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWwub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgdG9wcy5wdXNoKHRvcCk7XHJcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaCh0b3AgKyBoZWlnaHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XHJcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cclxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEhvcml6b250YWxJbmRleCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHZhciBsZWZ0cyA9IHRoaXMubGVmdHM7XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IHRoaXMucmlnaHRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0T2Zmc2V0ID49IGxlZnRzW2ldICYmIGxlZnRPZmZzZXQgPCByaWdodHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXHJcbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRWZXJ0aWNhbEluZGV4ID0gZnVuY3Rpb24gKHRvcE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICB2YXIgdG9wcyA9IHRoaXMudG9wcztcclxuICAgICAgICB2YXIgYm90dG9tcyA9IHRoaXMuYm90dG9tcztcclxuICAgICAgICB2YXIgbGVuID0gdG9wcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0b3BPZmZzZXQgPj0gdG9wc1tpXSAmJiB0b3BPZmZzZXQgPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldExlZnRPZmZzZXQgPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgbGVmdCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRMZWZ0UG9zaXRpb24gPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHJpZ2h0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodE9mZnNldCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodFBvc2l0aW9uID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VG9wT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRvcCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFRvcFBvc2l0aW9uID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBvZmZzZXQgKGZyb20gdGhlIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiAoZnJvbSB0aGUgb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tUG9zaXRpb24gPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBCb3VuZGluZyBSZWN0XHJcbiAgICAvLyBUT0RPOiBkZWNvdXBsZSB0aGlzIGZyb20gQ29vcmRDYWNoZVxyXG4gICAgLy8gQ29tcHV0ZSBhbmQgcmV0dXJuIHdoYXQgdGhlIGVsZW1lbnRzJyBib3VuZGluZyByZWN0YW5nbGUgaXMsIGZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZS5cclxuICAgIC8vIFJpZ2h0IG5vdywgb25seSByZXR1cm5zIGEgcmVjdGFuZ2xlIGlmIGNvbnN0cmFpbmVkIGJ5IGFuIG92ZXJmbG93OnNjcm9sbCBlbGVtZW50LlxyXG4gICAgLy8gUmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUucXVlcnlCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudEVsO1xyXG4gICAgICAgIGlmICh0aGlzLmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudCh0aGlzLmVscy5lcSgwKSk7XHJcbiAgICAgICAgICAgIGlmICghc2Nyb2xsUGFyZW50RWwuaXMoZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50RWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzUG9pbnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiB0aGlzLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc0xlZnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAobGVmdE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC5sZWZ0ICYmIGxlZnRPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5yaWdodCk7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNUb3BJbkJvdW5kcyA9IGZ1bmN0aW9uICh0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8ICh0b3BPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QudG9wICYmIHRvcE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LmJvdHRvbSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvb3JkQ2FjaGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvb3JkQ2FjaGU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuLyogVHJhY2tzIGEgZHJhZydzIG1vdXNlIG1vdmVtZW50LCBmaXJpbmcgdmFyaW91cyBoYW5kbGVyc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gVE9ETzogdXNlIEVtaXR0ZXJcclxudmFyIERyYWdMaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYWdMaXN0ZW5lcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVG91Y2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzR2VuZXJpYyA9IGZhbHNlOyAvLyBpbml0aWF0ZWQgYnkgJ2RyYWdzdGFydCcgKGpxdWkpXHJcbiAgICAgICAgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxBbHdheXNLaWxscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZGVmYXVsdHNcclxuICAgICAgICB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5ID0gMzA7IC8vIHBpeGVscyBmcm9tIGVkZ2UgZm9yIHNjcm9sbGluZyB0byBzdGFydFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kLCBhdCBtYXhpbXVtIHNwZWVkXHJcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbE1zID0gNTA7IC8vIG1pbGxpc2Vjb25kIHdhaXQgYmV0d2VlbiBzY3JvbGwgaW5jcmVtZW50XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIEludGVyYWN0aW9uIChoaWdoLWxldmVsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldiwgZXh0cmFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcbiAgICAgICAgICAgIGlmIChHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWxfMS5pc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIG5hdGl2ZSBzZWxlY3Rpb24gaW4gbW9zdCBicm93c2Vyc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3Mgb3B0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gdXRpbF8xLmZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGVsYXksIHRoaXMub3B0aW9ucy5kZWxheSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSB1dGlsXzEuZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kaXN0YW5jZSwgdGhpcy5vcHRpb25zLmRpc3RhbmNlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSB0aGlzLm9wdGlvbnMuc3ViamVjdEVsO1xyXG4gICAgICAgICAgICB1dGlsXzEucHJldmVudFNlbGVjdGlvbigkKCdib2R5JykpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2ggPSB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5pc0dlbmVyaWMgPSBldi50eXBlID09PSAnZHJhZ3N0YXJ0JztcclxuICAgICAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luWCA9IHV0aWxfMS5nZXRFdlgoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblkgPSB1dGlsXzEuZ2V0RXZZKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQoJChldi50YXJnZXQpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0QXV0b1Njcm9sbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25TdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmREcmFnKGV2KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUF1dG9TY3JvbGwoKTtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRIYW5kbGVycygpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB1dGlsXzEuYWxsb3dTZWxlY3Rpb24oJCgnYm9keScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZCA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uRW5kJywgZXYsIGlzQ2FuY2VsbGVkIHx8IGZhbHNlKTtcclxuICAgIH07XHJcbiAgICAvLyBCaW5kaW5nIFRvIERPTVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSBpbiBpT1MgMTApIGRvbid0IGFsbG93IHByZXZlbnREZWZhdWx0IG9uIHRvdWNoIGV2ZW50cyB0aGF0IGFyZSBib3VuZCBhZnRlciB0b3VjaHN0YXJ0LFxyXG4gICAgICAgIC8vIHNvIGxpc3RlbiB0byB0aGUgR2xvYmFsRW1pdHRlciBzaW5nbGV0b24sIHdoaWNoIGlzIGFsd2F5cyBib3VuZCwgaW5zdGVhZCBvZiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXHJcbiAgICAgICAgdmFyIGdsb2JhbEVtaXR0ZXIgPSBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0dlbmVyaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICAgICAgZHJhZzogdGhpcy5oYW5kbGVNb3ZlLFxyXG4gICAgICAgICAgICAgICAgZHJhZ3N0b3A6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5lbmRJbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgICAgIHNjcm9sbDogdGhpcy5oYW5kbGVUb3VjaFNjcm9sbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICAgIG1vdXNldXA6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdXRpbF8xLnByZXZlbnREZWZhdWx0LFxyXG4gICAgICAgICAgICBjb250ZXh0bWVudTogdXRpbF8xLnByZXZlbnREZWZhdWx0IC8vIGxvbmcgdGFwcyB3b3VsZCBvcGVuIG1lbnUgb24gQ2hyb21lIGRldiB0b29sc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTsgLy8gZm9yIGlzR2VuZXJpY1xyXG4gICAgfTtcclxuICAgIC8vIERyYWcgKGhpZ2gtbGV2ZWwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXh0cmFPcHRpb25zIGlnbm9yZWQgaWYgZHJhZyBhbHJlYWR5IHN0YXJ0ZWRcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2LCBleHRyYU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIGV4dHJhT3B0aW9ucyk7IC8vIGVuc3VyZSBpbnRlcmFjdGlvbiBiZWdhblxyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdTdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgZHggPSB1dGlsXzEuZ2V0RXZYKGV2KSAtIHRoaXMub3JpZ2luWDtcclxuICAgICAgICB2YXIgZHkgPSB1dGlsXzEuZ2V0RXZZKGV2KSAtIHRoaXMub3JpZ2luWTtcclxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZVNxOyAvLyBjdXJyZW50IGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiwgc3F1YXJlZFxyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlU3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWcoZHgsIGR5LCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGlsZSB0aGUgbW91c2UgaXMgYmVpbmcgbW92ZWQgYW5kIHdoZW4gd2Uga25vdyBhIGxlZ2l0aW1hdGUgZHJhZyBpcyB0YWtpbmcgcGxhY2VcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnJywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBdXRvU2Nyb2xsKGV2KTsgLy8gd2lsbCBwb3NzaWJseSBjYXVzZSBzY3JvbGxpbmdcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdFbmQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVsYXlcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0RGVsYXkgPSBmdW5jdGlvbiAoaW5pdGlhbEV2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWxheUVuZCA9IGZ1bmN0aW9uIChpbml0aWFsRXYpIHtcclxuICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhpbml0aWFsRXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEaXN0YW5jZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE1vdXNlIC8gVG91Y2hcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIHByZXZlbnQgaW5lcnRpYSBhbmQgdG91Y2htb3ZlLXNjcm9sbGluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBTY3JvbGxpbmcgKHVucmVsYXRlZCB0byBhdXRvLXNjcm9sbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGRyYWcgaXMgYmVpbmcgaW5pdGlhdGVkIGJ5IHRvdWNoLCBidXQgYSBzY3JvbGwgaGFwcGVucyBiZWZvcmVcclxuICAgICAgICAvLyB0aGUgZHJhZy1pbml0aWF0aW5nIGRlbGF5IGlzIG92ZXIsIGNhbmNlbCB0aGUgZHJhZ1xyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbihldiwgdHJ1ZSk7IC8vIGlzQ2FuY2VsbGVkPXRydWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2VzIF9tZXRob2RzIGNhbGxhYmxlIGJ5IGV2ZW50IG5hbWUuIFRPRE86IGtpbGwgdGhpc1xyXG4gICAgICAgIGlmICh0aGlzWydfJyArIG5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEF1dG8tc2Nyb2xsXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5pbml0QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbCAmJlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwgJiZcclxuICAgICAgICAgICAgICAgICFzY3JvbGxFbC5pcyh3aW5kb3cpICYmXHJcbiAgICAgICAgICAgICAgICAhc2Nyb2xsRWwuaXMoZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgICAvLyBkZWJvdW5jZSBtYWtlcyBzdXJlIHJhcGlkIGNhbGxzIGRvbid0IGhhcHBlblxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHNjcm9sbEVsLCAnc2Nyb2xsJywgdXRpbF8xLmRlYm91bmNlKHRoaXMuaGFuZGxlRGVib3VuY2VkU2Nyb2xsLCAxMDApKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTsgLy8ga2lsbCBhbnkgYW5pbWF0aW9uIGxvb3BcclxuICAgICAgICAvLyByZW1vdmUgdGhlIHNjcm9sbCBoYW5kbGVyIGlmIHRoZXJlIGlzIGEgc2Nyb2xsRWxcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpOyAvLyB3aWxsIHByb2JhYmx5IGdldCByZW1vdmVkIGJ5IHVuYmluZEhhbmRsZXJzIHRvbyA6KFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgc3RvcmVzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2Ygc2Nyb2xsRWxcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCb3VuZHMgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHRoaXMuc2Nyb2xsRWwpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB1c2UgZ2V0Q2xpZW50UmVjdCBpbiBmdXR1cmUuIGJ1dCBwcmV2ZW50cyBhdXRvIHNjcm9sbGluZyB3aGVuIG9uIHRvcCBvZiBzY3JvbGxiYXJzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzcyBhbmQgc2Nyb2xsaW5nIHNob3VsZCBiZSB1cGRhdGVkXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZUF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgc2Vuc2l0aXZpdHkgPSB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5O1xyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcclxuICAgICAgICB2YXIgdG9wQ2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciBib3R0b21DbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIGxlZnRDbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciB0b3BWZWwgPSAwO1xyXG4gICAgICAgIHZhciBsZWZ0VmVsID0gMDtcclxuICAgICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgY2xvc2VuZXNzIHRvIGVkZ2VzLiB2YWxpZCByYW5nZSBpcyBmcm9tIDAuMCAtIDEuMFxyXG4gICAgICAgICAgICB0b3BDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WShldikgLSBib3VuZHMudG9wKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgYm90dG9tQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5ib3R0b20gLSB1dGlsXzEuZ2V0RXZZKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIGxlZnRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WChldikgLSBib3VuZHMubGVmdCkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIHJpZ2h0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5yaWdodCAtIHV0aWxfMS5nZXRFdlgoZXYpKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHZlcnRpY2FsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5LlxyXG4gICAgICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGNvbXBsZXRlbHkgaW4gYm91bmRzIGZvciB2ZWxvY2l0eSB0byBoYXBwZW4uXHJcbiAgICAgICAgICAgIGlmICh0b3BDbG9zZW5lc3MgPj0gMCAmJiB0b3BDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wVmVsID0gdG9wQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyB1cFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvdHRvbUNsb3NlbmVzcyA+PSAwICYmIGJvdHRvbUNsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BWZWwgPSBib3R0b21DbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBob3Jpem9udGFsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2xvc2VuZXNzID49IDAgJiYgbGVmdENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0VmVsID0gbGVmdENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgbGVmdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Q2xvc2VuZXNzID49IDAgJiYgcmlnaHRDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdFZlbCA9IHJpZ2h0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFNjcm9sbFZlbCh0b3BWZWwsIGxlZnRWZWwpO1xyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIHNwZWVkLW9mLXNjcm9sbGluZyBmb3IgdGhlIHNjcm9sbEVsXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNldFNjcm9sbFZlbCA9IGZ1bmN0aW9uICh0b3BWZWwsIGxlZnRWZWwpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IHRvcFZlbDtcclxuICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSBsZWZ0VmVsO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIG1hc3NhZ2VzIGludG8gcmVhbGlzdGljIHZhbHVlc1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vbi16ZXJvIHZlbG9jaXR5LCBhbmQgYW4gYW5pbWF0aW9uIGxvb3AgaGFzbid0IGFscmVhZHkgc3RhcnRlZCwgdGhlbiBTVEFSVFxyXG4gICAgICAgIGlmICgodGhpcy5zY3JvbGxUb3BWZWwgfHwgdGhpcy5zY3JvbGxMZWZ0VmVsKSAmJiAhdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHV0aWxfMS5wcm94eSh0aGlzLCAnc2Nyb2xsSW50ZXJ2YWxGdW5jJyksIC8vIHNjb3BlIHRvIGB0aGlzYFxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsTXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBGb3JjZXMgc2Nyb2xsVG9wVmVsIGFuZCBzY3JvbGxMZWZ0VmVsIHRvIGJlIHplcm8gaWYgc2Nyb2xsaW5nIGhhcyBhbHJlYWR5IGdvbmUgYWxsIHRoZSB3YXlcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29uc3RyYWluU2Nyb2xsVmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgKyBlbFswXS5jbGllbnRIZWlnaHQgPj0gZWxbMF0uc2Nyb2xsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSArIGVsWzBdLmNsaWVudFdpZHRoID49IGVsWzBdLnNjcm9sbFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNjcm9sbEludGVydmFsRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHZhciBmcmFjID0gdGhpcy5zY3JvbGxJbnRlcnZhbE1zIC8gMTAwMDsgLy8gY29uc2lkZXJpbmcgYW5pbWF0aW9uIGZyZXF1ZW5jeSwgd2hhdCB0aGUgdmVsIHNob3VsZCBiZSBtdWx0J2QgYnlcclxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNjcm9sbEVsJ3Mgc2Nyb2xsXHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsKSB7XHJcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcChlbC5zY3JvbGxUb3AoKSArIHRoaXMuc2Nyb2xsVG9wVmVsICogZnJhYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnRWZWwpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdChlbC5zY3JvbGxMZWZ0KCkgKyB0aGlzLnNjcm9sbExlZnRWZWwgKiBmcmFjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gc2luY2UgdGhlIHNjcm9sbCB2YWx1ZXMgY2hhbmdlZCwgcmVjb21wdXRlIHRoZSB2ZWxvY2l0aWVzXHJcbiAgICAgICAgLy8gaWYgc2Nyb2xsZWQgYWxsIHRoZSB3YXksIHdoaWNoIGNhdXNlcyB0aGUgdmVscyB0byBiZSB6ZXJvLCBzdG9wIHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxUb3BWZWwgJiYgIXRoaXMuc2Nyb2xsTGVmdFZlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gS2lsbHMgYW55IGV4aXN0aW5nIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmRBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsSWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXQgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbEVsIGlzIHNjcm9sbGVkIChOT1RFOiB0aGlzIGlzIGRlbGF5ZWQgdmlhIGRlYm91bmNlKVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWJvdW5jZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcmVjb21wdXRlIGFsbCBjb29yZGluYXRlcywgYnV0ICpvbmx5KiBpZiB0aGlzIGlzICpub3QqIHBhcnQgb2Ygb3VyIHNjcm9sbGluZyBhbmltYXRpb25cclxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYWdMaXN0ZW5lcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ0xpc3RlbmVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKERyYWdMaXN0ZW5lcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuLypcclxuQSBzZXQgb2YgcmVuZGVyaW5nIGFuZCBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBmb3IgYSB2aXN1YWwgY29tcG9uZW50IGNvbXByaXNlZCBvZiBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjb2x1bW5zLlxyXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxyXG4qL1xyXG52YXIgRGF5VGFibGVNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheVRhYmxlTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlUYWJsZU1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS51cGRhdGVEYXlUYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF0ZSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBkYXlJbmRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIGZpcnN0RGF5O1xyXG4gICAgICAgIHZhciByb3dDbnQ7XHJcbiAgICAgICAgd2hpbGUgKGRhdGUuaXNCZWZvcmUoZW5kKSkge1xyXG4gICAgICAgICAgICBpZiAodmlldy5pc0hpZGRlbkRheShkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRlLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5icmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xyXG4gICAgICAgICAgICBmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xyXG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF5RGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PT0gZmlyc3REYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF5RGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByb3dDbnQgPSAxO1xyXG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF5RGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRheURhdGVzID0gZGF5RGF0ZXM7XHJcbiAgICAgICAgdGhpcy5kYXlJbmRpY2VzID0gZGF5SW5kaWNlcztcclxuICAgICAgICB0aGlzLmRheXNQZXJSb3cgPSBkYXlzUGVyUm93O1xyXG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGVDb2xzKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIGFzc2lnbmVkIHRoZSBjb2xDbnQgcHJvcGVydHkgYW5kIHVwZGF0ZXMgYW55IG9wdGlvbnMgdGhhdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBpdFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUudXBkYXRlRGF5VGFibGVDb2xzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ250ID0gdGhpcy5jb21wdXRlQ29sQ250KCk7XHJcbiAgICAgICAgdGhpcy5jb2xIZWFkRm9ybWF0ID1cclxuICAgICAgICAgICAgdGhpcy5vcHQoJ2NvbHVtbkhlYWRlckZvcm1hdCcpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdCgnY29sdW1uRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgaG93IG1hbnkgY29sdW1ucyB0aGVyZSBzaG91bGQgYmUgaW4gdGhlIHRhYmxlXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5jb21wdXRlQ29sQ250ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudCBmb3IgdGhlIGdpdmVuIGNlbGxcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxEYXRlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5RGF0ZXNbdGhpcy5nZXRDZWxsRGF5SW5kZXgocm93LCBjb2wpXS5jbG9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3Qgb2YgdGhlIGdyaWQgKDAtYmFzZWQpXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsRGF5SW5kZXggPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4gcm93ICogdGhpcy5kYXlzUGVyUm93ICsgdGhpcy5nZXRDb2xEYXlJbmRleChjb2wpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENvbERheUluZGV4ID0gZnVuY3Rpb24gKGNvbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbENudCAtIDEgLSBjb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXHJcbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cclxuICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcclxuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuZGF5RGF0ZXNbMF0sICdkYXlzJyk7XHJcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbZGF5SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1tkYXlPZmZzZXRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBPcHRpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuY29tcHV0ZUNvbEhlYWRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcclxuICAgICAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcclxuICAgICAgICBpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGQnOyAvLyBcIlNhdFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29sQ250ID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2RheU9mTW9udGhGb3JtYXQnKTsgLy8gXCJTYXQgMTIvMTBcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNsaWNpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSB3ZWVrLXJvdyBpdCBpbnRlcnNlY3RzIHdpdGhcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVJvdyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHVuem9uZWRSYW5nZSk7IC8vIG1ha2Ugd2hvbGUtZGF5IHJhbmdlLCBjb25zaWRlcmluZyBuZXh0RGF5VGhyZXNob2xkXHJcbiAgICAgICAgdmFyIHJhbmdlRmlyc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxyXG4gICAgICAgIHZhciByYW5nZUxhc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5lbmQuY2xvbmUoKS5zdWJ0cmFjdCgxLCAnZGF5cycpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIHJvd0ZpcnN0O1xyXG4gICAgICAgIHZhciByb3dMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBjdXJyZW50IHJvd1xyXG4gICAgICAgIHZhciBzZWdGaXJzdDtcclxuICAgICAgICB2YXIgc2VnTGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3Igc2VnbWVudFxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHJvd0ZpcnN0ID0gcm93ICogZGF5c1BlclJvdztcclxuICAgICAgICAgICAgcm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XHJcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgIHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgcm93Rmlyc3QpO1xyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5taW4ocmFuZ2VMYXN0LCByb3dMYXN0KTtcclxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5mbG9vcihzZWdMYXN0KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxyXG4gICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ0xhc3QgPT09IHJhbmdlTGFzdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxyXG4gICAgLy8gVE9ETzogbWFrZSBtb3JlIERSWSB3aXRoIHNsaWNlUmFuZ2VCeVJvdyBzb21laG93LlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5RGF5ID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcclxuICAgICAgICB2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgdmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgcm93Rmlyc3Q7XHJcbiAgICAgICAgdmFyIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZ0ZpcnN0O1xyXG4gICAgICAgIHZhciBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICByb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcclxuICAgICAgICAgICAgZm9yIChpID0gcm93Rmlyc3Q7IGkgPD0gcm93TGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Qgc2VnbWVudCdzIG9mZnNldCByYW5nZSB3aXRoIHRoZSByb3cnc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCBpKTtcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLmZsb29yKHNlZ0xhc3QpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ0ZpcnN0ID09PSByYW5nZUZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogSGVhZGVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdGhlbWUuZ2V0Q2xhc3MoJ2hlYWRlclJvdycpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90aGVhZD4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZFRySHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCgpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsc0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiB3aGVuIGludGVybmFsQXBpVmVyc2lvbiwgYWNjZXB0IGFuIG9iamVjdCBmb3IgSFRNTCBhdHRyaWJ1dGVzXHJcbiAgICAvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdC52aWV3O1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHQuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgaW5uZXJIdG1sO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlckh0bWwnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB0Lm9wdCgnY29sdW1uSGVhZGVySHRtbCcpKGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlclRleHQnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZSh0Lm9wdCgnY29sdW1uSGVhZGVyVGV4dCcpKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGRhdGUuZm9ybWF0KHQuY29sSGVhZEZvcm1hdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmx5IG9uZSByb3cgb2YgZGF5cywgdGhlIGNsYXNzTmFtZXMgb24gdGhlIGhlYWRlciBjYW4gcmVwcmVzZW50IHRoZSBzcGVjaWZpYyBkYXlzIGJlbmVhdGhcclxuICAgICAgICBpZiAodC5yb3dDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuY29uY2F0KFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICAgICAgLy8gbm9UaGVtZUhpZ2hsaWdodD10cnVlIChkb24ndCBoaWdobGlnaHQgdGhlIGhlYWRlcilcclxuICAgICAgICAgICAgdC5nZXREYXlDbGFzc2VzKGRhdGUsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoKGlzRGF0ZVZhbGlkICYmIHQucm93Q250KSA9PT0gMSA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoY29sc3BhbiA+IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXHJcbiAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCBmb3JjZU9mZjogdC5yb3dDbnQgPiAxIHx8IHQuY29sQ250ID09PSAxIH0sIGlubmVySHRtbCkgOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHZhbGlkLCBkaXNwbGF5IHRleHQsIGJ1dCBubyBsaW5rXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwpICtcclxuICAgICAgICAgICAgJzwvdGg+JztcclxuICAgIH07XHJcbiAgICAvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpOyAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJpY1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0NlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0LmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXknLCB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykpO1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6IC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XHJcbiAgICAgICAgICAgICAgICAnICcgKyBvdGhlckF0dHJzIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC90ZD4nO1xyXG4gICAgfTtcclxuICAgIC8qIEdlbmVyaWNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IEhUTUwgaW50cm8gZm9yIGFueSByb3cuIFVzZXIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBhIGdlbmVyaWMgbWV0aG9kIGZvciBkZWFsaW5nIHdpdGggPHRyPiwgUlRMLCBpbnRyb1xyXG4gICAgLy8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXHJcbiAgICAvLyB3cmFwVHIgKHNjaGVkdWxlcilcclxuICAgIC8qIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQXBwbGllcyB0aGUgZ2VuZXJpYyBcImludHJvXCIgYW5kIFwib3V0cm9cIiBIVE1MIHRvIHRoZSBnaXZlbiBjZWxscy5cclxuICAgIC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmJvb2tlbmRDZWxscyA9IGZ1bmN0aW9uICh0ckVsKSB7XHJcbiAgICAgICAgdmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICAgICAgaWYgKGludHJvSHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5hcHBlbmQoaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlUYWJsZU1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlUYWJsZU1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wbGVtZW50czpcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gZXZlbnRGb290cHJpbnRzVG9TZWdzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnVzaW5lc3NIb3VyUmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBjb21wb25lbnQuX2dldERhdGVQcm9maWxlKCkuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoY29tcG9uZW50Lmhhc0FsbERheUJ1c2luZXNzSG91cnMsIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IGV2ZW50SW5zdGFuY2VHcm91cCA/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyh1bnpvbmVkUmFuZ2UpKSA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VncyhzZWdzKTtcclxuICAgICAgICB0aGlzLnNlZ3MgPSBzZWdzO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYnVzaW5lc3NIb3VycycsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1ub25idXNpbmVzcycsICdmYy1iZ2V2ZW50J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdidXNpbmVzc0hvdXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVzaW5lc3NIb3VyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91clJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWxsUmVuZGVyZXIoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5maWxsU2VnVGFnID0gJ2Rpdic7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5lbHNCeUZpbGwgPSB7fTtcclxuICAgIH1cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRm9vdHByaW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudEZvb3RwcmludCwgcHJvcHMpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclNlZ3ModHlwZSwgdGhpcy5jb21wb25lbnQuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGNvbXBvbmVudEZvb3RwcmludCksIHByb3BzKTtcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2VncywgcHJvcHMpIHtcclxuICAgICAgICB2YXIgZWxzO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmJ1aWxkU2VnRWxzKHR5cGUsIHNlZ3MsIHByb3BzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcclxuICAgICAgICBlbHMgPSB0aGlzLmF0dGFjaFNlZ0Vscyh0eXBlLCBzZWdzKTtcclxuICAgICAgICBpZiAoZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RWxzKHR5cGUsIGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MsIHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmJ1aWxkU2VnSHRtbCh0eXBlLCBzZWdzW2ldLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5maWx0ZXJFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gcHJvcHMuZmlsdGVyRWwoc2VnLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9ICQoZWwpOyAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIHRvIHJldHVybiByYXcgRE9NIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGVsZW1lbnQgdHlwZT8gKHdvdWxkIGJlIGJhZCBpZiBhIG5vbi1URCB3ZXJlIGluc2VydGVkIGludG8gYSB0YWJsZSBmb3IgZXhhbXBsZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuaXMoX3RoaXMuZmlsbFNlZ1RhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkU2VncztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgZmlsbCBzZWdtZW50LiBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZFNlZ0h0bWwgPSBmdW5jdGlvbiAodHlwZSwgc2VnLCBwcm9wcykge1xyXG4gICAgICAgIC8vIGN1c3RvbSBob29rcyBwZXItdHlwZVxyXG4gICAgICAgIHZhciBjbGFzc2VzID0gcHJvcHMuZ2V0Q2xhc3NlcyA/IHByb3BzLmdldENsYXNzZXMoc2VnKSA6IFtdO1xyXG4gICAgICAgIHZhciBjc3MgPSB1dGlsXzEuY3NzVG9TdHIocHJvcHMuZ2V0Q3NzID8gcHJvcHMuZ2V0Q3NzKHNlZykgOiB7fSk7XHJcbiAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuZmlsbFNlZ1RhZyArXHJcbiAgICAgICAgICAgIChjbGFzc2VzLmxlbmd0aCA/ICcgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInIDogJycpICtcclxuICAgICAgICAgICAgKGNzcyA/ICcgc3R5bGU9XCInICsgY3NzICsgJ1wiJyA6ICcnKSArXHJcbiAgICAgICAgICAgICcgLz4nO1xyXG4gICAgfTtcclxuICAgIC8vIFNob3VsZCByZXR1cm4gd3JhcHBpbmcgRE9NIHN0cnVjdHVyZVxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlcG9ydEVscyA9IGZ1bmN0aW9uICh0eXBlLCBub2Rlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmVsc0J5RmlsbFt0eXBlXSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9IHRoaXMuZWxzQnlGaWxsW3R5cGVdLmFkZChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9ICQobm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsbFJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxsUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWxwZXJSZW5kZXJlcihjb21wb25lbnQsIGV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIgPSBldmVudFJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudEZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhbXHJcbiAgICAgICAgICAgIHRoaXMuZmFicmljYXRlRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtZHJhZ2dpbmcnLCBpc1RvdWNoID8gbnVsbCA6IHRoaXMudmlldy5vcHQoJ2RyYWdPcGFjaXR5JykpO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtcmVzaXppbmcnKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCBleHRyYUNsYXNzTmFtZXMsIG9wYWNpdHkpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2ZjLWhlbHBlciAnICsgKGV4dHJhQ2xhc3NOYW1lcyB8fCAnJyk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gYXNzaWducyBlYWNoIHNlZydzIGVsIGFuZCByZXR1cm5zIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzW2ldLmVsLmFkZENsYXNzKGNsYXNzTmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmVsLmNzcygnb3BhY2l0eScsIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyRWxzID0gdGhpcy5yZW5kZXJTZWdzKHNlZ3MsIHNvdXJjZVNlZyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE11c3QgcmV0dXJuIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzXHJcbiAgICAqL1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWxwZXJFbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJFbHMucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLmZhYnJpY2F0ZUV2ZW50Rm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnREYXRlUHJvZmlsZSA9IGNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB2YXIgZHVtbXlFdmVudCA9IG5ldyBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQobmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHZhciBkdW1teUluc3RhbmNlO1xyXG4gICAgICAgIGR1bW15RXZlbnQuZGF0ZVByb2ZpbGUgPSBldmVudERhdGVQcm9maWxlO1xyXG4gICAgICAgIGR1bW15SW5zdGFuY2UgPSBkdW1teUV2ZW50LmJ1aWxkSW5zdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChjb21wb25lbnRGb290cHJpbnQsIGR1bW15RXZlbnQsIGR1bW15SW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIZWxwZXJSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGVscGVyUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFdmVudFBvaW50aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnRQb2ludGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBtdXN0IGltcGxlbWVudDpcclxuICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICovXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWVudGVyJywgdGhpcy5oYW5kbGVNb3VzZW92ZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZU1vdXNlb3V0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudENsaWNrJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3ZlclxyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VvdmVyID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAoIUdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgIXRoaXMubW91c2VkT3ZlclNlZykge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlZE92ZXJTZWcgPSBzZWc7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3ZlcicsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdXQuXHJcbiAgICAvLyBDYW4gYmUgZ2l2ZW4gbm8gYXJndW1lbnRzLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgbW91c2VvdXQgdGhlIHNlZ21lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VzZWQgb3Zlci5cclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlb3V0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VkT3ZlclNlZyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3V0Jywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgICAgICBldiB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VvdXQodGhpcy5tb3VzZWRPdmVyU2VnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UG9pbnRpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UG9pbnRpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgRGF0ZUNsaWNraW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NSk7XHJcbnZhciBEYXRlU2VsZWN0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI0KTtcclxudmFyIEV2ZW50UmVzaXppbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIzKTtcclxudmFyIEV4dGVybmFsRHJvcHBpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIyKTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFuZGFyZEludGVyYWN0aW9uc01peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZGF0ZUNsaWNraW5nQ2xhc3MgPSBEYXRlQ2xpY2tpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5kYXRlU2VsZWN0aW5nQ2xhc3MgPSBEYXRlU2VsZWN0aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gRXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50RHJhZ2dpbmdDbGFzcyA9IEV2ZW50RHJhZ2dpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudFJlc2l6aW5nQ2xhc3MgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzID0gRXh0ZXJuYWxEcm9wcGluZ18xLmRlZmF1bHQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBQb3BvdmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0OSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcbnZhciBEYXlHcmlkRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTApO1xyXG52YXIgRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MSk7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1Mik7XHJcbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhIGdyaWQgb2Ygd2hvbGUtZGF5cyB0aGF0IHJ1bnMgaG9yaXpvbnRhbGx5LiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgcm93cywgb25lIHBlciB3ZWVrLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZCh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7IC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGluIGRheSBjZWxsP1xyXG4gICAgICAgIF90aGlzLmJvdHRvbUNvb3JkUGFkZGluZyA9IDA7IC8vIGhhY2sgZm9yIGV4dGVuZGluZyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBsYXN0IHJvdyBvZiB0aGUgY29vcmRpbmF0ZSBncmlkXHJcbiAgICAgICAgLy8gaXNSaWdpZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGluZGl2aWR1YWwgcm93cyBzaG91bGQgaWdub3JlIHRoZSBjb250ZW50cyBhbmQgYmUgYSBjb25zdGFudCBoZWlnaHQuXHJcbiAgICAgICAgLy8gUmVsaWVzIG9uIHRoZSB2aWV3J3MgY29sQ250IGFuZCByb3dDbnQuIEluIHRoZSBmdXR1cmUsIHRoaXMgY29tcG9uZW50IHNob3VsZCBwcm9iYWJseSBiZSBzZWxmLXN1ZmZpY2llbnQuXHJcbiAgICAgICAgX3RoaXMuaXNSaWdpZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmhhc0FsbERheUJ1c2luZXNzSG91cnMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5Um93KGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5sYXN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZWcucmlnaHRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWcubGVmdENvbCA9IHNlZy5maXJzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICAgICAgc2VnLnJpZ2h0Q29sID0gc2VnLmxhc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckdyaWQoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU2VnUG9wb3ZlcigpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIHJvd3MgYW5kIGNvbHVtbnMgaW50byB0aGUgY29tcG9uZW50J3MgYHRoaXMuZWxgLCB3aGljaCBzaG91bGQgYWxyZWFkeSBiZSBhc3NpZ25lZC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHJvd0NudCA9IHRoaXMucm93Q250O1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBpZiAodGhpcy5oZWFkQ29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkQ29udGFpbmVyRWwuaHRtbCh0aGlzLnJlbmRlckhlYWRIdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLnJlbmRlckRheVJvd0h0bWwocm93LCB0aGlzLmlzUmlnaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmh0bWwoaHRtbCk7XHJcbiAgICAgICAgdGhpcy5yb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3cnKTtcclxuICAgICAgICB0aGlzLmNlbGxFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXksIC5mYy1kaXNhYmxlZC1kYXknKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMucm93RWxzLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLmNlbGxFbHMuc2xpY2UoMCwgdGhpcy5jb2xDbnQpLFxyXG4gICAgICAgICAgICBpc0hvcml6b250YWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5UmVuZGVyJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF5Um93SHRtbCA9IGZ1bmN0aW9uIChyb3csIGlzUmlnaWQpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLXJvdycsICdmYy13ZWVrJywgdGhlbWUuZ2V0Q2xhc3MoJ2RheVJvdycpXTtcclxuICAgICAgICBpZiAoaXNSaWdpZCkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXJpZ2lkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnVHJIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT4nICtcclxuICAgICAgICAgICAgKHRoaXMuZ2V0SXNOdW1iZXJzVmlzaWJsZSgpID9cclxuICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOdW1iZXJUckh0bWwocm93KSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSB8fCB0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3dDbnQgPiAxO1xyXG4gICAgfTtcclxuICAgIC8qIEdyaWQgTnVtYmVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlclRySHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck51bWJlckNlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyTnVtYmVyQ2VsbEh0bWwoZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgPHRkPnMgb2YgdGhlIFwibnVtYmVyXCIgcm93IGluIHRoZSBEYXlHcmlkJ3MgY29udGVudCBza2VsZXRvbi5cclxuICAgIC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSB0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cclxuICAgICAgICB2YXIgaXNEYXlOdW1iZXJWaXNpYmxlID0gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgJiYgaXNEYXRlVmFsaWQ7XHJcbiAgICAgICAgdmFyIGNsYXNzZXM7XHJcbiAgICAgICAgdmFyIHdlZWtDYWxjRmlyc3REb1c7XHJcbiAgICAgICAgaWYgKCFpc0RheU51bWJlclZpc2libGUgJiYgIXRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBubyBudW1iZXJzIGluIGRheSBjZWxsICh3ZWVrIG51bWJlciBtdXN0IGJlIGFsb25nIHRoZSBzaWRlKVxyXG4gICAgICAgICAgICByZXR1cm4gJzx0ZC8+JzsgLy8gIHdpbGwgY3JlYXRlIGFuIGVtcHR5IHNwYWNlIGFib3ZlIGV2ZW50cyA6KFxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LXRvcCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gVG8gZGV0ZXJtaW5lIHRoZSBkYXkgb2Ygd2VlayBudW1iZXIgY2hhbmdlIHVuZGVyIElTTywgd2UgY2Fubm90XHJcbiAgICAgICAgICAgIC8vIHJlbHkgb24gbW9tZW50LmpzIG1ldGhvZHMgc3VjaCBhcyBmaXJzdERheU9mV2VlaygpIG9yIHdlZWtkYXkoKSxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHJlbHkgb24gdGhlIGxvY2FsZSdzIGRvdyAocG9zc2libHkgb3ZlcnJpZGRlbiBieVxyXG4gICAgICAgICAgICAvLyBvdXIgZmlyc3REYXkgb3B0aW9uKSwgd2hpY2ggbWF5IG5vdCBiZSBNb25kYXkuIFdlIGNhbm5vdCBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gZG93LCBiZWNhdXNlIHRoYXQgd291bGQgYWZmZWN0IHRoZSBjYWxlbmRhciBzdGFydCBkYXkgYXMgd2VsbC5cclxuICAgICAgICAgICAgaWYgKGRhdGUuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgd2Vla0NhbGNGaXJzdERvVyA9IDE7IC8vIE1vbmRheSBieSBJU08gODYwMSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gZGF0ZS5fbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPic7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSAmJiAoZGF0ZS5kYXkoKSA9PT0gd2Vla0NhbGNGaXJzdERvVykpIHtcclxuICAgICAgICAgICAgaHRtbCArPSB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCB0eXBlOiAnd2VlaycgfSwgeyAnY2xhc3MnOiAnZmMtd2Vlay1udW1iZXInIH0sIGRhdGUuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEYXlOdW1iZXJWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKGRhdGUsIHsgJ2NsYXNzJzogJ2ZjLWRheS1udW1iZXInIH0sIGRhdGUuZm9ybWF0KCdEJykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8L3RkPic7XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5ib3R0b21zW3RoaXMucm93Q250IC0gMV0gKz0gdGhpcy5ib3R0b21Db29yZFBhZGRpbmc7IC8vIGhhY2tcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMucm93Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldENlbGxSYW5nZShoaXQucm93LCBoaXQuY29sKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCksIHRydWUgLy8gYWxsLWRheT9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxFbChoaXQucm93LCBoaXQuY29sKTtcclxuICAgIH07XHJcbiAgICAvKiBDZWxsIFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEZZSTogdGhlIGZpcnN0IGNvbHVtbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uLCByZWdhcmRsZXNzIG9mIGRhdGVcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxIaXQgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgY29sOiBjb2wsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sKSxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICB0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0Qm90dG9tT2Zmc2V0KHJvdylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxFbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxFbHMuZXEocm93ICogdGhpcy5jb2xDbnQgKyBjb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBcIm1vcmUuLi5cIiBwb3BvdmVyXHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0T3duRXZlbnRTZWdzLmNhbGwodGhpcykuY29uY2F0KHRoaXMucG9wb3ZlclNlZ3MgfHwgW10pO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXHJcbiAgICAvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlciBkcmFncyBmcm9tIE9USEVSIGNvbXBvbmVudHMgYXMgaGVscGVyc1xyXG4gICAgICAgIGlmIChldmVudEZvb3RwcmludHMubGVuZ3RoICYmIHNlZyAmJiBzZWcuY29tcG9uZW50ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIGhlbHBlcnMgcmVuZGVyZWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGhvdmVyaW5nIGV2ZW50XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBNb3JlKyBMaW5rIFBvcG92ZXJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW1vdmVTZWdQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWdQb3BvdmVyLmhpZGUoKTsgLy8gaW4gaGFuZGxlciwgd2lsbCBjYWxsIHNlZ1BvcG92ZXIncyByZW1vdmVFbGVtZW50XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgbnVtYmVyIG9mIFwibGV2ZWxzXCIgKHZlcnRpY2FsbHkgc3RhY2tpbmcgbGF5ZXJzIG9mIGV2ZW50cykgZm9yIGVhY2ggcm93IG9mIHRoZSBncmlkLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGNhbiBiZSBmYWxzZSAoZG9uJ3QgbGltaXQpLCBhIG51bWJlciwgb3IgdHJ1ZSAoc2hvdWxkIGJlIGNvbXB1dGVkKS5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmxpbWl0Um93cyA9IGZ1bmN0aW9uIChsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0cyB8fCBbXTtcclxuICAgICAgICB2YXIgcm93OyAvLyByb3cgI1xyXG4gICAgICAgIHZhciByb3dMZXZlbExpbWl0O1xyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93U3RydWN0cy5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5saW1pdFJvdyhyb3cpO1xyXG4gICAgICAgICAgICBpZiAoIWxldmVsTGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGV2ZWxMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBsZXZlbExpbWl0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IHRoaXMuY29tcHV0ZVJvd0xldmVsTGltaXQocm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm93TGV2ZWxMaW1pdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRSb3cocm93LCByb3dMZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIGxldmVscyBhIHJvdyB3aWxsIGFjY29tb2RhdGUgd2l0aG91dCBnb2luZyBvdXRzaWRlIGl0cyBib3VuZHMuXHJcbiAgICAvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXB1dGVSb3dMZXZlbExpbWl0ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHRoZSBjb250YWluaW5nIFwiZmFrZVwiIHJvdyBkaXZcclxuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gcm93RWwuaGVpZ2h0KCk7IC8vIFRPRE86IGNhY2hlIHNvbWVob3c/XHJcbiAgICAgICAgdmFyIHRyRWxzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XS50Ym9keUVsLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRyRWw7XHJcbiAgICAgICAgdmFyIHRySGVpZ2h0O1xyXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJJbm5lckhlaWdodHMoaSwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gTWF0aC5tYXgodHJIZWlnaHQsICQoY2hpbGROb2RlKS5vdXRlckhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV2ZWFsIG9uZSBsZXZlbCA8dHI+IGF0IGEgdGltZSBhbmQgc3RvcCB3aGVuIHdlIGZpbmQgb25lIG91dCBvZiBib3VuZHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJFbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJFbCA9IHRyRWxzLmVxKGkpLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXHJcbiAgICAgICAgICAgIC8vIHdpdGggcm93c3BhbnM+MSBhbmQgSUU4LCB0ckVsLm91dGVySGVpZ2h0KCkgd291bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgY2VsbCxcclxuICAgICAgICAgICAgLy8gc28gaW5zdGVhZCwgZmluZCB0aGUgdGFsbGVzdCBpbm5lciBjb250ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdHJFbC5maW5kKCc+IHRkID4gOmZpcnN0LWNoaWxkJykuZWFjaChpdGVySW5uZXJIZWlnaHRzKTtcclxuICAgICAgICAgICAgaWYgKHRyRWwucG9zaXRpb24oKS50b3AgKyB0ckhlaWdodCA+IHJvd0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaG91bGQgbm90IGxpbWl0IGF0IGFsbFxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgZ2l2ZW4gZ3JpZCByb3cgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBhbmQgaW5qZWN0cyBcIm1vcmVcIiBsaW5rcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIC8vIGBsZXZlbExpbWl0YCBpcyBhIG51bWJlciBmb3IgdGhlIG1heGltdW0gKGluY2x1c2l2ZSkgbnVtYmVyIG9mIGxldmVscyBhbGxvd2VkLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3cgPSBmdW5jdGlvbiAocm93LCBsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcm93U3RydWN0ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XTtcclxuICAgICAgICB2YXIgbW9yZU5vZGVzID0gW107IC8vIGFycmF5IG9mIFwibW9yZVwiIDxhPiBsaW5rcyBhbmQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXHJcbiAgICAgICAgdmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXg7IC8vIGEgbWF0cml4IChieSBsZXZlbCwgdGhlbiBjb2x1bW4pIG9mIGFsbCA8dGQ+IGpRdWVyeSBlbGVtZW50cyBpbiB0aGUgcm93XHJcbiAgICAgICAgdmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxyXG4gICAgICAgIHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xyXG4gICAgICAgIHZhciBjb2xTZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzLCBiZWxvdyBzZWcsIG9uZSBmb3IgZWFjaCBjb2x1bW4gKG9mZnNldCBmcm9tIHNlZ3MncyBmaXJzdCBjb2x1bW4pXHJcbiAgICAgICAgdmFyIHRkO1xyXG4gICAgICAgIHZhciByb3dzcGFuO1xyXG4gICAgICAgIHZhciBzZWdNb3JlTm9kZXM7IC8vIGFycmF5IG9mIFwibW9yZVwiIDx0ZD4gY2VsbHMgdGhhdCB3aWxsIHN0YW5kLWluIGZvciB0aGUgY3VycmVudCBzZWcncyBjZWxsXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIG1vcmVUZDtcclxuICAgICAgICB2YXIgbW9yZVdyYXA7XHJcbiAgICAgICAgdmFyIG1vcmVMaW5rO1xyXG4gICAgICAgIC8vIEl0ZXJhdGVzIHRocm91Z2ggZW1wdHkgbGV2ZWwgY2VsbHMgYW5kIHBsYWNlcyBcIm1vcmVcIiBsaW5rcyBpbnNpZGUgaWYgbmVlZCBiZVxyXG4gICAgICAgIHZhciBlbXB0eUNlbGxzVW50aWwgPSBmdW5jdGlvbiAoZW5kQ29sKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdzQmVsb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIHRkLmFwcGVuZChtb3JlV3JhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVdyYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSByb3dTdHJ1Y3Quc2VnTGV2ZWxzW2xldmVsTGltaXQgLSAxXTtcclxuICAgICAgICAgICAgY2VsbE1hdHJpeCA9IHJvd1N0cnVjdC5jZWxsTWF0cml4O1xyXG4gICAgICAgICAgICBsaW1pdGVkTm9kZXMgPSByb3dTdHJ1Y3QudGJvZHlFbC5jaGlsZHJlbigpLnNsaWNlKGxldmVsTGltaXQpIC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5nZXQoKTsgLy8gaGlkZSBlbGVtZW50cyBhbmQgZ2V0IGEgc2ltcGxlIERPTS1ub2RlcyBhcnJheVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHRob3VnaCBzZWdtZW50cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWxcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTsgLy8gcHJvY2VzcyBlbXB0eSBjZWxscyBiZWZvcmUgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSAqYWxsKiBzZWdtZW50cyBiZWxvdyBgc2VnYCB0aGF0IG9jY3VweSB0aGUgc2FtZSBjb2x1bW5zXHJcbiAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPD0gc2VnLnJpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sU2Vnc0JlbG93LnB1c2goc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFNlZ3NCZWxvdyArPSBzZWdzQmVsb3cubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsU2Vnc0JlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtzZWcubGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcclxuICAgICAgICAgICAgICAgICAgICByb3dzcGFuID0gdGQuYXR0cigncm93c3BhbicpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIHJlcGxhY2VtZW50IDx0ZD4gZm9yIGVhY2ggY29sdW1uIHRoZSBzZWdtZW50IG9jY3VwaWVzLiB3aWxsIGJlIG9uZSBmb3IgZWFjaCBjb2xzcGFuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1tb3JlLWNlbGxcIi8+JykuYXR0cigncm93c3BhbicsIHJvd3NwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSBjb2xTZWdzQmVsb3dbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIHNlZy5sZWZ0Q29sICsgaiwgW3NlZ10uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQuYXBwZW5kKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5hZnRlcigkKHNlZ01vcmVOb2RlcykpOyAvLyBoaWRlIG9yaWdpbmFsIDx0ZD4gYW5kIGluamVjdCByZXBsYWNlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMucHVzaCh0ZFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHRoaXMuY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgbGV2ZWxcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSAkKG1vcmVOb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSAkKGxpbWl0ZWROb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmV2ZWFscyBhbGwgbGV2ZWxzIGFuZCByZW1vdmVzIGFsbCBcIm1vcmVcIi1yZWxhdGVkIGVsZW1lbnRzIGZvciBhIGdyaWQncyByb3cuXHJcbiAgICAvLyBgcm93YCBpcyBhIHJvdyBudW1iZXIuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bmxpbWl0Um93ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubW9yZUVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93U3RydWN0LmxpbWl0ZWRFbHMpIHtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxyXG4gICAgLy8gUmVzcG9uc2libGUgZm9yIGF0dGFjaGluZyBjbGljayBoYW5kbGVyIGFzIHdlbGwuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJNb3JlTGluayA9IGZ1bmN0aW9uIChyb3csIGNvbCwgaGlkZGVuU2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICQoJzxhIGNsYXNzPVwiZmMtbW9yZVwiLz4nKVxyXG4gICAgICAgICAgICAudGV4dCh0aGlzLmdldE1vcmVMaW5rVGV4dChoaWRkZW5TZWdzLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGNsaWNrT3B0aW9uID0gX3RoaXMub3B0KCdldmVudExpbWl0Q2xpY2snKTtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHZhciBtb3JlRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZGF5RWwgPSBfdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB2YXIgYWxsU2VncyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sKTtcclxuICAgICAgICAgICAgLy8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxyXG4gICAgICAgICAgICB2YXIgcmVzbGljZWRBbGxTZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoYWxsU2VncywgZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBhdG9taWMgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICBjbGlja09wdGlvbiA9IF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbDogZGF5RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlRWw6IG1vcmVFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3M6IHJlc2xpY2VkQWxsU2VncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2Vnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbGlja09wdGlvbiA9PT0gJ3BvcG92ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIuem9vbVRvKGRhdGUsIGNsaWNrT3B0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFJldmVhbHMgdGhlIHBvcG92ZXIgdGhhdCBkaXNwbGF5cyBhbGwgZXZlbnRzIHdpdGhpbiBhIGNlbGxcclxuICAgIERheUdyaWQucHJvdG90eXBlLnNob3dTZWdQb3BvdmVyID0gZnVuY3Rpb24gKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG1vcmVXcmFwID0gbW9yZUxpbmsucGFyZW50KCk7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XHJcbiAgICAgICAgdmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLnJvd0NudCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0b3BFbCA9IHZpZXcuZWw7IC8vIHdpbGwgY2F1c2UgdGhlIHBvcG92ZXIgdG8gY292ZXIgYW55IHNvcnQgb2YgaGVhZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHdpbGwgYWxpZ24gd2l0aCB0b3Agb2Ygcm93XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZjLW1vcmUtcG9wb3ZlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxyXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50KHJvdywgY29sLCBzZWdzKSxcclxuICAgICAgICAgICAgcGFyZW50RWw6IHZpZXcuZWwsXHJcbiAgICAgICAgICAgIHRvcDogdG9wRWwub2Zmc2V0KCkudG9wLFxyXG4gICAgICAgICAgICBhdXRvSGlkZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmlld3BvcnRDb25zdHJhaW46IHRoaXMub3B0KCdwb3BvdmVyVmlld3BvcnRDb25zdHJhaW4nKSxcclxuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8ga2lsbCBldmVyeXRoaW5nIHdoZW4gdGhlIHBvcG92ZXIgaXMgaGlkZGVuXHJcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgZXZlbnRzIHRvIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wb3BvdmVyU2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQoX3RoaXMucG9wb3ZlclNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3Zlci5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBvcG92ZXJTZWdzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGhvcml6b250YWwgY29vcmRpbmF0ZS5cclxuICAgICAgICAvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cclxuICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnJpZ2h0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCArIG1vcmVXcmFwLm91dGVyV2lkdGgoKSArIDE7IC8vICsxIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgLSAxOyAvLyAtMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VnUG9wb3ZlciA9IG5ldyBQb3BvdmVyXzEuZGVmYXVsdChvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnNlZ1BvcG92ZXIuc2hvdygpO1xyXG4gICAgICAgIC8vIHRoZSBwb3BvdmVyIGRvZXNuJ3QgbGl2ZSB3aXRoaW4gdGhlIGdyaWQncyBjb250YWluZXIgZWxlbWVudCwgYW5kIHRodXMgd29uJ3QgZ2V0IHRoZSBldmVudFxyXG4gICAgICAgIC8vIGRlbGVnYXRlZC1oYW5kbGVycyBmb3IgZnJlZS4gYXR0YWNoIGV2ZW50LXJlbGF0ZWQgaGFuZGxlcnMgdG8gdGhlIHBvcG92ZXIuXHJcbiAgICAgICAgdGhpcy5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsKHRoaXMuc2VnUG9wb3Zlci5lbCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZChzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIGlubmVyIERPTSBjb250ZW50cyBvZiB0aGUgc2VnbWVudCBwb3BvdmVyXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWdQb3BvdmVyQ29udGVudCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc2Vncykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCkuZm9ybWF0KHRoaXMub3B0KCdkYXlQb3BvdmVyRm9ybWF0JykpO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSArICdcIj48L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRpdGxlKSArXHJcbiAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHZhciBzZWdDb250YWluZXIgPSBjb250ZW50LmZpbmQoJy5mYy1ldmVudC1jb250YWluZXInKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICAvLyByZW5kZXIgZWFjaCBzZWcncyBgZWxgIGFuZCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSBzZWdzXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzLCB0cnVlKTsgLy8gZGlzYWJsZVJlc2l6aW5nPXRydWVcclxuICAgICAgICB0aGlzLnBvcG92ZXJTZWdzID0gc2VncztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHNlZ21lbnRzIGluIHRoZSBwb3BvdmVyIGFyZSBub3QgcGFydCBvZiBhIGdyaWQgY29vcmRpbmF0ZSBzeXN0ZW0sIHByb3ZpZGUgYSBoaW50IHRvIGFueVxyXG4gICAgICAgICAgICAvLyBncmlkcyB0aGF0IHdhbnQgdG8gZG8gZHJhZy1uLWRyb3AgYWJvdXQgd2hpY2ggY2VsbCBpdCBjYW1lIGZyb21cclxuICAgICAgICAgICAgdGhpcy5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ3NbaV0uaGl0ID0gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcclxuICAgICAgICAgICAgdGhpcy5oaXRzTm90TmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ0NvbnRhaW5lci5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHRoZSBldmVudHMgd2l0aGluIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cywgcmVzbGljZSB0aGVtIHRvIGJlIGluIGEgc2luZ2xlIGRheVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVzbGljZURheVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZGF5RGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXlTdGFydCA9IGRheURhdGUuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZGF5RW5kID0gZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlTdGFydCwgZGF5RW5kKTtcclxuICAgICAgICB2YXIgbmV3U2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNsaWNlZFJhbmdlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNsaWNlZFJhbmdlID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2Vncy5wdXNoKCQuZXh0ZW5kKHt9LCBzZWcsIHtcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQ6IG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQoc2xpY2VkUmFuZ2UsIHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSwgc2VnLmZvb3RwcmludC5ldmVudERlZiwgc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuaXNFbmRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3JjZSBhbiBvcmRlciBiZWNhdXNlIGV2ZW50c1RvU2VncyBkb2Vzbid0IGd1YXJhbnRlZSBvbmVcclxuICAgICAgICAvLyBUT0RPOiByZXNlYXJjaCBpZiBzdGlsbCBuZWVkZWRcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhuZXdTZWdzKTtcclxuICAgICAgICByZXR1cm4gbmV3U2VncztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0TW9yZUxpbmtUZXh0ID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdFRleHQnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0KG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJysnICsgbnVtICsgJyAnICsgb3B0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHNlZ21lbnRzIHdpdGhpbiBhIGdpdmVuIGNlbGwuXHJcbiAgICAvLyBJZiBgc3RhcnRMZXZlbGAgaXMgc3BlY2lmaWVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGluY2x1ZGluZyBhbmQgYmVsb3cgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlIHJldHVybnMgYWxsIHNlZ3MuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsU2VncyA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xyXG4gICAgICAgIHZhciBzZWdNYXRyaXggPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnNlZ01hdHJpeDtcclxuICAgICAgICB2YXIgbGV2ZWwgPSBzdGFydExldmVsIHx8IDA7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHdoaWxlIChsZXZlbCA8IHNlZ01hdHJpeC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xyXG4gICAgICAgICAgICBpZiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXZlbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZDtcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheUdyaWQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IERheUdyaWRFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IERheUdyaWRIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmZpbGxSZW5kZXJlckNsYXNzID0gRGF5R3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcbkRheVRhYmxlTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjgpO1xyXG52YXIgRGF5R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgXCJiYXNpY1wiIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cclxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxudmFyIEJhc2ljVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJhc2ljVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2ljVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IF90aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpO1xyXG4gICAgICAgIF90aGlzLmRheUdyaWQuaXNSaWdpZCA9IF90aGlzLmhhc1JpZ2lkUm93cygpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIERheUdyaWQgb2JqZWN0IHRoaXMgdmlldyBuZWVkcy4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5pbnN0YW50aWF0ZURheUdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSBzdWJjbGFzcyBvbiB0aGUgZmx5IHdpdGggQmFzaWNWaWV3LXNwZWNpZmljIGJlaGF2aW9yXHJcbiAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhpcyBzdWJjbGFzc1xyXG4gICAgICAgIHZhciBzdWJjbGFzcyA9IG1ha2VEYXlHcmlkU3ViY2xhc3ModGhpcy5kYXlHcmlkQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5icmVha09uV2Vla3MgPSAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF5R3JpZENvbnRhaW5lckVsO1xyXG4gICAgICAgIHZhciBkYXlHcmlkRWw7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtYmFzaWMtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICBkYXlHcmlkQ29udGFpbmVyRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICBkYXlHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIiAvPicpLmFwcGVuZFRvKGRheUdyaWRDb250YWluZXJFbCk7XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQoZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLm9wdCgnY29sdW1uSGVhZGVyJykgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiPiZuYnNwOzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLndlZWtOdW1iZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLndlZWtOdW1iZXJXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5oYXNSaWdpZFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICB2YXIgaGVhZFJvd0VsID0gdGhpcy5kYXlHcmlkLmhlYWRDb250YWluZXJFbC5maW5kKCcuZmMtcm93Jyk7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIGRheUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyBkYXlHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy5kYXlHcmlkLnJvd0Vscykge1xyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cclxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSB3aWR0aCBmb3IgY2VsbHMgY3JlYXRlZCBsYXRlci5cclxuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzKHRoaXMuZWwuZmluZCgnLmZjLXdlZWstbnVtYmVyJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCBhbGwgaGVpZ2h0cyB0byBiZSBuYXR1cmFsXHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgIC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBmaXJzdCBzbyB0aGUgaGVpZ2h0IGNhbiByZWRpc3RyaWJ1dGUgYWZ0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXHJcbiAgICAgICAgLy8gKHRvdGFsSGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcclxuICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldEdyaWRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XHJcbiAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgYWZ0ZXIgdGhlIGdyaWQncyByb3cgaGVpZ2h0cyBoYXZlIGJlZW4gc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZG9pbmcgdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjcmVhdGVkIHRleHQgb3ZlcmZsb3cgd2hpY2ggY3JlYXRlZCBtb3JlIGhlaWdodC4gcmVkb1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIGhlaWdodCBvZiBqdXN0IHRoZSBEYXlHcmlkIGNvbXBvbmVudCBpbiB0aGlzIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIGlmIChpc0F1dG8pIHtcclxuICAgICAgICAgICAgdXRpbF8xLnVuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzKTsgLy8gbGV0IHRoZSByb3dzIGJlIHRoZWlyIG5hdHVyYWwgaGVpZ2h0IHdpdGggbm8gZXhwYW5kaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1dGlsXzEuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsIHRydWUpOyAvLyB0cnVlID0gY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTY3JvbGxcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IDAgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlldztcclxuQmFzaWNWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5CYXNpY1ZpZXcucHJvdG90eXBlLmRheUdyaWRDbGFzcyA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG4vLyBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiBCYXNpY1ZpZXcncyBkYXlHcmlkXHJcbmZ1bmN0aW9uIG1ha2VEYXlHcmlkU3ViY2xhc3MoU3VwZXJDbGFzcykge1xyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlOyAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBhbG9uZyB0aGUgc2lkZT9cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnd2Vla051bWJlclRpdGxlJykpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVyTnVtYmVySW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgdmFyIHdlZWtTdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB7IGRhdGU6IHdlZWtTdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPT09IDEgfSwgd2Vla1N0YXJ0LmZvcm1hdCgndycpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgZXZlcnkgb3RoZXIgdHlwZSBvZiByb3cgZ2VuZXJhdGVkIGJ5IERheUdyaWQuXHJcbiAgICAgICAgLy8gQWZmZWN0cyBoZWxwZXItc2tlbGV0b24gYW5kIGhpZ2hsaWdodC1za2VsZXRvbiByb3dzLlxyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUuZ2V0SXNOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERheUdyaWRfMS5kZWZhdWx0LnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9KFN1cGVyQ2xhc3MpKTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiA2MyAqLyxcbi8qIDY0ICovLFxuLyogNjUgKi8sXG4vKiA2NiAqLyxcbi8qIDY3ICovLFxuLyogNjggKi8sXG4vKiA2OSAqLyxcbi8qIDcwICovLFxuLyogNzEgKi8sXG4vKiA3MiAqLyxcbi8qIDczICovLFxuLyogNzQgKi8sXG4vKiA3NSAqLyxcbi8qIDc2ICovLFxuLyogNzcgKi8sXG4vKiA3OCAqLyxcbi8qIDc5ICovLFxuLyogODAgKi8sXG4vKiA4MSAqLyxcbi8qIDgyICovLFxuLyogODMgKi8sXG4vKiA4NCAqLyxcbi8qIDg1ICovLFxuLyogODYgKi8sXG4vKiA4NyAqLyxcbi8qIDg4ICovLFxuLyogODkgKi8sXG4vKiA5MCAqLyxcbi8qIDkxICovLFxuLyogOTIgKi8sXG4vKiA5MyAqLyxcbi8qIDk0ICovLFxuLyogOTUgKi8sXG4vKiA5NiAqLyxcbi8qIDk3ICovLFxuLyogOTggKi8sXG4vKiA5OSAqLyxcbi8qIDEwMCAqLyxcbi8qIDEwMSAqLyxcbi8qIDEwMiAqLyxcbi8qIDEwMyAqLyxcbi8qIDEwNCAqLyxcbi8qIDEwNSAqLyxcbi8qIDEwNiAqLyxcbi8qIDEwNyAqLyxcbi8qIDEwOCAqLyxcbi8qIDEwOSAqLyxcbi8qIDExMCAqLyxcbi8qIDExMSAqLyxcbi8qIDExMiAqLyxcbi8qIDExMyAqLyxcbi8qIDExNCAqLyxcbi8qIDExNSAqLyxcbi8qIDExNiAqLyxcbi8qIDExNyAqLyxcbi8qIDExOCAqLyxcbi8qIDExOSAqLyxcbi8qIDEyMCAqLyxcbi8qIDEyMSAqLyxcbi8qIDEyMiAqLyxcbi8qIDEyMyAqLyxcbi8qIDEyNCAqLyxcbi8qIDEyNSAqLyxcbi8qIDEyNiAqLyxcbi8qIDEyNyAqLyxcbi8qIDEyOCAqLyxcbi8qIDEyOSAqLyxcbi8qIDEzMCAqLyxcbi8qIDEzMSAqLyxcbi8qIDEzMiAqLyxcbi8qIDEzMyAqLyxcbi8qIDEzNCAqLyxcbi8qIDEzNSAqLyxcbi8qIDEzNiAqLyxcbi8qIDEzNyAqLyxcbi8qIDEzOCAqLyxcbi8qIDEzOSAqLyxcbi8qIDE0MCAqLyxcbi8qIDE0MSAqLyxcbi8qIDE0MiAqLyxcbi8qIDE0MyAqLyxcbi8qIDE0NCAqLyxcbi8qIDE0NSAqLyxcbi8qIDE0NiAqLyxcbi8qIDE0NyAqLyxcbi8qIDE0OCAqLyxcbi8qIDE0OSAqLyxcbi8qIDE1MCAqLyxcbi8qIDE1MSAqLyxcbi8qIDE1MiAqLyxcbi8qIDE1MyAqLyxcbi8qIDE1NCAqLyxcbi8qIDE1NSAqLyxcbi8qIDE1NiAqLyxcbi8qIDE1NyAqLyxcbi8qIDE1OCAqLyxcbi8qIDE1OSAqLyxcbi8qIDE2MCAqLyxcbi8qIDE2MSAqLyxcbi8qIDE2MiAqLyxcbi8qIDE2MyAqLyxcbi8qIDE2NCAqLyxcbi8qIDE2NSAqLyxcbi8qIDE2NiAqLyxcbi8qIDE2NyAqLyxcbi8qIDE2OCAqLyxcbi8qIDE2OSAqLyxcbi8qIDE3MCAqLyxcbi8qIDE3MSAqLyxcbi8qIDE3MiAqLyxcbi8qIDE3MyAqLyxcbi8qIDE3NCAqLyxcbi8qIDE3NSAqLyxcbi8qIDE3NiAqLyxcbi8qIDE3NyAqLyxcbi8qIDE3OCAqLyxcbi8qIDE3OSAqLyxcbi8qIDE4MCAqLyxcbi8qIDE4MSAqLyxcbi8qIDE4MiAqLyxcbi8qIDE4MyAqLyxcbi8qIDE4NCAqLyxcbi8qIDE4NSAqLyxcbi8qIDE4NiAqLyxcbi8qIDE4NyAqLyxcbi8qIDE4OCAqLyxcbi8qIDE4OSAqLyxcbi8qIDE5MCAqLyxcbi8qIDE5MSAqLyxcbi8qIDE5MiAqLyxcbi8qIDE5MyAqLyxcbi8qIDE5NCAqLyxcbi8qIDE5NSAqLyxcbi8qIDE5NiAqLyxcbi8qIDE5NyAqLyxcbi8qIDE5OCAqLyxcbi8qIDE5OSAqLyxcbi8qIDIwMCAqLyxcbi8qIDIwMSAqLyxcbi8qIDIwMiAqLyxcbi8qIDIwMyAqLyxcbi8qIDIwNCAqLyxcbi8qIDIwNSAqLyxcbi8qIDIwNiAqLyxcbi8qIDIwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIENvbnN0cmFpbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uc3RyYWludHMoZXZlbnRNYW5hZ2VyLCBfY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IF9jYWxlbmRhcjtcclxuICAgIH1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhci5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGRldGVybWluZXMgaWYgZXZlbnRJbnN0YW5jZUdyb3VwIGlzIGFsbG93ZWQsXHJcbiAgICBpbiByZWxhdGlvbiB0byBvdGhlciBFVkVOVFMgYW5kIGJ1c2luZXNzIGhvdXJzLlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRJbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZ2V0UGVlckV2ZW50SW5zdGFuY2VzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50UmFuZ2VzID0gcGVlckV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMocGVlckV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgY29uc3RyYWludFZhbCA9IGV2ZW50RGVmLmdldENvbnN0cmFpbnQoKTtcclxuICAgICAgICB2YXIgb3ZlcmxhcFZhbCA9IGV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICB2YXIgZXZlbnRBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnZXZlbnRBbGxvdycpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9vdHByaW50QWxsb3dlZChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCBjb25zdHJhaW50VmFsLCBvdmVybGFwVmFsLCBldmVudEZvb3RwcmludHNbaV0uZXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRBbGxvd0Z1bmMpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QWxsb3dGdW5jKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpLCBldmVudEZvb3RwcmludHNbaV0uZ2V0RXZlbnRMZWdhY3koKSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5nZXRQZWVyRXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXNXaXRob3V0SWQoZXZlbnREZWYuaWQpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudFJhbmdlcyA9IHBlZXJFdmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdEFsbG93RnVuYztcclxuICAgICAgICBpZiAodGhpcy5pc0Zvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCB0aGlzLm9wdCgnc2VsZWN0Q29uc3RyYWludCcpLCB0aGlzLm9wdCgnc2VsZWN0T3ZlcmxhcCcpKSkge1xyXG4gICAgICAgICAgICBzZWxlY3RBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnc2VsZWN0QWxsb3cnKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdEFsbG93RnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdEFsbG93RnVuYyhjb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpKSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHMsIGNvbnN0cmFpbnRWYWwsIG92ZXJsYXBWYWwsIHN1YmplY3RFdmVudEluc3RhbmNlIC8vIG9wdGlvbmFsXHJcbiAgICApIHtcclxuICAgICAgICB2YXIgY29uc3RyYWludEZvb3RwcmludHM7IC8vIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAgICAgdmFyIG92ZXJsYXBFdmVudEZvb3RwcmludHM7IC8vIEV2ZW50Rm9vdHByaW50W11cclxuICAgICAgICBpZiAoY29uc3RyYWludFZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRGb290cHJpbnRzID0gdGhpcy5jb25zdHJhaW50VmFsVG9Gb290cHJpbnRzKGNvbnN0cmFpbnRWYWwsIGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zvb3RwcmludFdpdGhpbkNvbnN0cmFpbnRzKGNvbXBvbmVudEZvb3RwcmludCwgY29uc3RyYWludEZvb3RwcmludHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29sbGVjdE92ZXJsYXBFdmVudEZvb3RwcmludHMocGVlckV2ZW50Rm9vdHByaW50cywgY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBFdmVudEZvb3RwcmludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG92ZXJsYXBWYWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBzQWxsb3dlZEJ5RnVuYyhvdmVybGFwRXZlbnRGb290cHJpbnRzLCBvdmVybGFwVmFsLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29uc3RyYWludFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNGb290cHJpbnRXaXRoaW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIGNvbnN0cmFpbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50KGNvbnN0cmFpbnRGb290cHJpbnRzW2ldLCBjb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbnN0cmFpbnRWYWxUb0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludFZhbCwgaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRWYWwgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEN1cnJlbnRCdXNpbmVzc0Zvb3RwcmludHMoaXNBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludFZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLnBhcnNlRXZlbnREZWZUb0luc3RhbmNlcyhjb25zdHJhaW50VmFsKTsgLy8gaGFuZGxlcyByZWN1cnJpbmcgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9vdHByaW50cyhjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25zdHJhaW50VmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlc1dpdGhJZChjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyByZXR1cm5zIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAvLyB1c2VzIGN1cnJlbnQgdmlldydzIHJhbmdlXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuYnVpbGRDdXJyZW50QnVzaW5lc3NGb290cHJpbnRzID0gZnVuY3Rpb24gKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jYWxlbmRhci52aWV3O1xyXG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJHZW5lcmF0b3IgPSB2aWV3LmdldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJyk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IHZpZXcuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoaXNBbGxEYXksIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjb252ZXJzaW9uIHV0aWxcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlcykge1xyXG4gICAgICAgIHZhciBldmVudFJhbmdlcyA9IGV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cy5tYXAodXRpbF8xLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJsYXBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbGxlY3RPdmVybGFwRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKHBlZXJFdmVudEZvb3RwcmludHMsIHRhcmdldEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvdmVybGFwRXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBlZXJFdmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdHByaW50c0ludGVyc2VjdCh0YXJnZXRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5wdXNoKHBlZXJFdmVudEZvb3RwcmludHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdmVybGFwRXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIC8vIENvbnZlcnNpb246IGV2ZW50RGVmcyAtPiBldmVudEluc3RhbmNlcyAtPiBldmVudFJhbmdlcyAtPiBldmVudEZvb3RwcmludHMgLT4gY29tcG9uZW50Rm9vdHByaW50c1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBOT1RFOiB0aGlzIG1pZ2h0IHNlZW0gbGlrZSByZXBldGl0aXZlIGNvZGUgd2l0aCB0aGUgR3JpZCBjbGFzcywgaG93ZXZlciwgdGhpcyBjb2RlIGlzIHJlbGF0ZWQgdG9cclxuICAgIC8vIGNvbnN0cmFpbnRzIHdoZXJlYXMgdGhlIEdyaWQgY29kZSBpcyByZWxhdGVkIHRvIHJlbmRlcmluZy4gRWFjaCBhcHByb2FjaCBtaWdodCB3YW50IHRvIGNvbnZlcnRcclxuICAgIC8vIGV2ZW50UmFuZ2VzIC0+IGV2ZW50Rm9vdHByaW50cyBpbiBhIGRpZmZlcmVudCB3YXkuIFJlZ2FyZGxlc3MsIHRoZXJlIGFyZSBvcHBvcnR1bml0aWVzIHRvIG1ha2VcclxuICAgIC8vIHRoaXMgbW9yZSBEUlkuXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBmYWxzZSBvbiBpbnZhbGlkIGlucHV0LlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUV2ZW50RGVmVG9JbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLl9jYWxlbmRhcikpO1xyXG4gICAgICAgIGlmICghZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoZXZlbnRNYW5hZ2VyLmN1cnJlbnRQZXJpb2QudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gZm9vdHByaW50c1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzEuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBQYXJzZXMgZm9vdHByaW50cyBkaXJlY3RseS5cclxuICAgIFZlcnkgc2ltaWxhciB0byBFdmVudERhdGVQcm9maWxlOjpwYXJzZSA6KFxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUZvb3RwcmludHMgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAocmF3SW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jYWxlbmRhci5tb21lbnQocmF3SW5wdXQuc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdJbnB1dC5lbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5fY2FsZW5kYXIubW9tZW50KHJhd0lucHV0LmVuZCk7XHJcbiAgICAgICAgICAgIGlmICghZW5kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgKHN0YXJ0ICYmICFzdGFydC5oYXNUaW1lKCkpIHx8IChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIC8vIGlzQWxsRGF5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIC8vIEZvb3RwcmludCBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50ID0gZnVuY3Rpb24gKG91dGVyRm9vdHByaW50LCBpbm5lckZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBvdXRlckZvb3RwcmludC51bnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShpbm5lckZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5mb290cHJpbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICByZXR1cm4gZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0c1dpdGgoZm9vdHByaW50MS51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25zdHJhaW50cztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uc3RyYWludHM7XHJcbi8vIG9wdGlvbmFsIHN1YmplY3RFdmVudEluc3RhbmNlXHJcbmZ1bmN0aW9uIGlzT3ZlcmxhcHNBbGxvd2VkQnlGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIG92ZXJsYXBGdW5jLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb3ZlcmxhcEZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlLnRvTGVnYWN5KCksIHN1YmplY3RFdmVudEluc3RhbmNlID8gc3ViamVjdEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSA6IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHZhciBzdWJqZWN0TGVnYWN5SW5zdGFuY2UgPSBzdWJqZWN0RXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50SW5zdGFuY2U7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50RGVmO1xyXG4gICAgdmFyIG92ZXJsYXBWYWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG92ZXJsYXBFdmVudEluc3RhbmNlID0gb3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIG92ZXJsYXBFdmVudERlZiA9IG92ZXJsYXBFdmVudEluc3RhbmNlLmRlZjtcclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHBhc3MgaW4gY2FsZW5kYXIsIGJlY2F1c2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBnbG9iYWwgZXZlbnRPdmVybGFwIHByb3BlcnR5LFxyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBjb25zaWRlcmVkIHRoYXQgZWFybGllciBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICAgICBvdmVybGFwVmFsID0gb3ZlcmxhcEV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBWYWwob3ZlcmxhcEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSwgc3ViamVjdExlZ2FjeUluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgUGFyc2FibGVNb2RlbE1peGluLCBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlIH0gZnJvbSAnLi9QYXJzYWJsZU1vZGVsTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIGFwcGx5UHJvcHM6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2FwcGx5UHJvcHMnXVxyXG4gIGFwcGx5TWFudWFsU3RhbmRhcmRQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzJ11cclxuICBhcHBseU1pc2NQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNaXNjUHJvcHMnXVxyXG4gIGlzU3RhbmRhcmRQcm9wOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydpc1N0YW5kYXJkUHJvcCddXHJcbiAgc3RhdGljIGRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wc1xyXG4gIHN0YXRpYyBjb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHNcclxuYWZ0ZXIgY2xhc3M6XHJcbiAgUGFyc2FibGVNb2RlbE1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNhYmxlTW9kZWxNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhcnNhYmxlTW9kZWxNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wRGVmcykge1xyXG4gICAgICAgIHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ3N0YW5kYXJkUHJvcE1hcCcpKSB7XHJcbiAgICAgICAgICAgIHByb3RvLnN0YW5kYXJkUHJvcE1hcCA9IE9iamVjdC5jcmVhdGUocHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhwcm9wRGVmcywgcHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgIH07XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5wcm90b3R5cGUuc3RhbmRhcmRQcm9wTWFwO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICBpZiAoc3JjW3Byb3BOYW1lXSAhPSBudWxsICYmIC8vIGluIHRoZSBzcmMgb2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgbWFwW3Byb3BOYW1lXSA9PT0gdHJ1ZSAvLyBmYWxzZSBtZWFucyBcImNvcHkgdmVyYmF0aW1cIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbcHJvcE5hbWVdID0gc3JjW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyB0cnVlL2ZhbHNlIGZvciBzdWNjZXNzLlxyXG4gICAgTWVhbnQgdG8gYmUgb25seSBjYWxsZWQgT05DRSwgYXQgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BNYXAgPSB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgICAgICB2YXIgbWFudWFsUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbWlzY1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYW51YWxQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlNaXNjUHJvcHMobWlzY1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMobWFudWFsUHJvcHMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBJZiBzdWJjbGFzc2VzIG92ZXJyaWRlLCB0aGV5IG11c3QgY2FsbCB0aGlzIHN1cGVybWV0aG9kIGFuZCByZXR1cm4gdGhlIGJvb2xlYW4gcmVzcG9uc2UuXHJcbiAgICBNZWFudCB0byBiZSBvbmx5IGNhbGxlZCBPTkNFLCBhdCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQ2FuIGJlIGNhbGxlZCBldmVuIGFmdGVyIGluaXRpYWwgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgVE9ETzogd2h5IGlzIHRoaXMgYSBtZXRob2Qgd2hlbiBkZWZpbmVTdGFuZGFyZFByb3BzIGlzIHN0YXRpY1xyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuaXNTdGFuZGFyZFByb3AgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcE5hbWUgaW4gdGhpcy5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhcnNhYmxlTW9kZWxNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFyc2FibGVNb2RlbE1peGluO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLnN0YW5kYXJkUHJvcE1hcCA9IHt9OyAvLyB3aWxsIGJlIGNsb25lZCBieSBkZWZpbmVTdGFuZGFyZFByb3BzXHJcblxuXG4vKioqLyB9KSxcbi8qIDIwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudEluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZShkZWYsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZS5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5kZWYudG9MZWdhY3koKTtcclxuICAgICAgICBvYmouc3RhcnQgPSBkYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIG9iai5lbmQgPSBkYXRlUHJvZmlsZS5lbmQgPyBkYXRlUHJvZmlsZS5lbmQuY2xvbmUoKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRJbnN0YW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDkpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFJlY3VycmluZ0V2ZW50RGVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVjdXJyaW5nRXZlbnREZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydFRpbWUgJiYgIXRoaXMuZW5kVGltZTtcclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHVuem9uZWREYXRlID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRFbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgdmFyIHpvbmVkRGF5U3RhcnQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlRW5kO1xyXG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAodW56b25lZERhdGUuaXNCZWZvcmUodW56b25lZEVuZCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG93SGFzaCB8fCB0aGlzLmRvd0hhc2hbdW56b25lZERhdGUuZGF5KCldKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lZERheVN0YXJ0ID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZSh1bnpvbmVkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gem9uZWREYXlTdGFydC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydC50aW1lKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSB6b25lZERheVN0YXJ0LmNsb25lKCkudGltZSh0aGlzLmVuZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2gobmV3IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0KHRoaXMsIC8vIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICAgIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChpbnN0YW5jZVN0YXJ0LCBpbnN0YW5jZUVuZCwgY2FsZW5kYXIpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW56b25lZERhdGUuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLnNldERvdyA9IGZ1bmN0aW9uIChkb3dOdW1iZXJzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5kb3dIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG93TnVtYmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRvd0hhc2hbZG93TnVtYmVyc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IF9zdXBlci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoZGVmLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBkZWYuc3RhcnRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgIGRlZi5lbmRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuZW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgZGVmLmRvd0hhc2ggPSAkLmV4dGVuZCh7fSwgdGhpcy5kb3dIYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWY7XHJcbn0oRXZlbnREZWZfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3VycmluZ0V2ZW50RGVmO1xyXG4vKlxyXG5IQUNLIHRvIHdvcmsgd2l0aCBUeXBlU2NyaXB0IG1peGluc1xyXG5OT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiovXHJcblJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5hcHBseVByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICB2YXIgc3VwZXJTdWNjZXNzID0gRXZlbnREZWZfMS5kZWZhdWx0LnByb3RvdHlwZS5hcHBseVByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgaWYgKHJhd1Byb3BzLnN0YXJ0KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBtb21lbnQuZHVyYXRpb24ocmF3UHJvcHMuc3RhcnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmVuZCkge1xyXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG1vbWVudC5kdXJhdGlvbihyYXdQcm9wcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmRvdykge1xyXG4gICAgICAgIHRoaXMuc2V0RG93KHJhd1Byb3BzLmRvdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG59O1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5SZWN1cnJpbmdFdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIHN0YXJ0OiBmYWxzZSxcclxuICAgIGVuZDogZmFsc2UsXHJcbiAgICBkb3c6IGZhbHNlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UmFuZ2UodW56b25lZFJhbmdlLCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJhbmdlO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTID0ge1xyXG4gICAgc3RhcnQ6ICcwOTowMCcsXHJcbiAgICBlbmQ6ICcxNzowMCcsXHJcbiAgICBkb3c6IFsxLCAyLCAzLCA0LCA1XSxcclxuICAgIHJlbmRlcmluZzogJ2ludmVyc2UtYmFja2dyb3VuZCdcclxuICAgIC8vIGNsYXNzTmFtZXMgYXJlIGRlZmluZWQgaW4gYnVzaW5lc3NIb3Vyc1NlZ0NsYXNzZXNcclxufTtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1c2luZXNzSG91ckdlbmVyYXRvcihyYXdDb21wbGV4RGVmLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMucmF3Q29tcGxleERlZiA9IHJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgfVxyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChpc0FsbERheSwgdW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuYnVpbGRFdmVudERlZnMoaXNBbGxEYXkpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQodXRpbF8xLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpKTtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBpbnZlcnNlLWJhY2tncm91bmQgcmVuZGVyaW5nIGNhbiBoYXBwZW4gZXZlbiB3aGVuIG5vIGV2ZW50UmFuZ2VzIGluIHZpZXdcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV4cGxpY2l0RXZlbnREZWYgPSBldmVudERlZnNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudERlZnMgPSBmdW5jdGlvbiAoaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmF3Q29tcGxleERlZiA9IHRoaXMucmF3Q29tcGxleERlZjtcclxuICAgICAgICB2YXIgcmF3RGVmcyA9IFtdO1xyXG4gICAgICAgIHZhciByZXF1aXJlRG93ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBbXTtcclxuICAgICAgICBpZiAocmF3Q29tcGxleERlZiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QocmF3Q29tcGxleERlZikpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFtyYXdDb21wbGV4RGVmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0NvbXBsZXhEZWYpKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSByYXdDb21wbGV4RGVmO1xyXG4gICAgICAgICAgICByZXF1aXJlRG93ID0gdHJ1ZTsgLy8gZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVEb3cgfHwgcmF3RGVmc1tpXS5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGRlZnMucHVzaCh0aGlzLmJ1aWxkRXZlbnREZWYoaXNBbGxEYXksIHJhd0RlZnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmcztcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnREZWYgPSBmdW5jdGlvbiAoaXNBbGxEYXksIHJhd0RlZikge1xyXG4gICAgICAgIHZhciBmdWxsUmF3RGVmID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIHJhd0RlZik7XHJcbiAgICAgICAgaWYgKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGZ1bGxSYXdEZWYuc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICBmdWxsUmF3RGVmLmVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZnVsbFJhd0RlZiwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLmNhbGVuZGFyKSAvLyBkdW1teSBzb3VyY2VcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdXNpbmVzc0hvdXJHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZFRoZW1lO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAnZmMtdW50aGVtZWQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICdmYy1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ2ZjLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICdmYy1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnZmMtc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdmYy1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAnZmMtc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAnZmMtc3RhdGUtZG93bicsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdmYy13aWRnZXQtY29udGVudCdcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXHJcbiAgICBwcmV2OiAnZmMtaWNvbi1sZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBuZXh0OiAnZmMtaWNvbi1yaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWxlZnQtZG91YmxlLWFycm93JyxcclxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1yaWdodC1kb3VibGUtYXJyb3cnXHJcbn07XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXG5cbi8qKiovIH0pLFxuLyogMjE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpxdWVyeVVpVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKcXVlcnlVaVRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBKcXVlcnlVaVRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBKcXVlcnlVaVRoZW1lO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAndWktd2lkZ2V0JyxcclxuICAgIHdpZGdldEhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgd2lkZ2V0Q29udGVudDogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcclxuICAgIGJ1dHRvbjogJ3VpLWJ1dHRvbicsXHJcbiAgICBjb3JuZXJMZWZ0OiAndWktY29ybmVyLWxlZnQnLFxyXG4gICAgY29ybmVyUmlnaHQ6ICd1aS1jb3JuZXItcmlnaHQnLFxyXG4gICAgc3RhdGVEZWZhdWx0OiAndWktc3RhdGUtZGVmYXVsdCcsXHJcbiAgICBzdGF0ZUFjdGl2ZTogJ3VpLXN0YXRlLWFjdGl2ZScsXHJcbiAgICBzdGF0ZURpc2FibGVkOiAndWktc3RhdGUtZGlzYWJsZWQnLFxyXG4gICAgc3RhdGVIb3ZlcjogJ3VpLXN0YXRlLWhvdmVyJyxcclxuICAgIHN0YXRlRG93bjogJ3VpLXN0YXRlLWRvd24nLFxyXG4gICAgdG9kYXk6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBkYXkgZ3JpZFxyXG4gICAgaGVhZGVyUm93OiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBkYXlSb3c6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAndWktd2lkZ2V0LWNvbnRlbnQnXHJcbn07XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAndWktaWNvbic7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICd1aS1pY29uLWNsb3NldGhpY2snLFxyXG4gICAgcHJldjogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLXcnLFxyXG4gICAgbmV4dDogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgcHJldlllYXI6ICd1aS1pY29uLXNlZWstcHJldicsXHJcbiAgICBuZXh0WWVhcjogJ3VpLWljb24tc2Vlay1uZXh0J1xyXG59O1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAndGhlbWVCdXR0b25JY29ucyc7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICd0aGVtZUljb24nO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAndWktaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGdW5jRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGdW5jRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRnVuY0V2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciByYXdQcm9wcztcclxuICAgICAgICAvLyBub3JtYWxpemUgcmF3IGlucHV0XHJcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihyYXdJbnB1dC5ldmVudHMpKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0gcmF3SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSB7IGV2ZW50czogcmF3SW5wdXQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudFNvdXJjZV8xLmRlZmF1bHQucGFyc2UuY2FsbCh0aGlzLCByYXdQcm9wcywgY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci5wdXNoTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5mdW5jLmNhbGwoX3RoaXMuY2FsZW5kYXIsIHN0YXJ0LmNsb25lKCksIGVuZC5jbG9uZSgpLCB0aW1lem9uZSwgZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdW5jO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHRoaXMuZnVuYyA9IHJhd1Byb3BzLmV2ZW50cztcclxuICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGdW5jRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZ1bmNFdmVudFNvdXJjZTtcclxuRnVuY0V2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgZXZlbnRzOiBmYWxzZSAvLyBkb24ndCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpzb25GZWVkRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKc29uRmVlZEV2ZW50U291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAodHlwZW9mIHJhd0lucHV0LnVybCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhd0lucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgdXJsOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFqYXhTZXR0aW5ncyA9IHRoaXMuYWpheFNldHRpbmdzO1xyXG4gICAgICAgIHZhciBvblN1Y2Nlc3MgPSBhamF4U2V0dGluZ3Muc3VjY2VzcztcclxuICAgICAgICB2YXIgb25FcnJvciA9IGFqYXhTZXR0aW5ncy5lcnJvcjtcclxuICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IHRoaXMuYnVpbGRSZXF1ZXN0UGFyYW1zKHN0YXJ0LCBlbmQsIHRpbWV6b25lKTtcclxuICAgICAgICAvLyB0b2RvOiBldmVudHVhbGx5IGhhbmRsZSB0aGUgcHJvbWlzZSdzIHRoZW4sXHJcbiAgICAgICAgLy8gZG9uJ3QgaW50ZXJjZXB0IHN1Y2Nlc3MvZXJyb3JcclxuICAgICAgICAvLyB0aG8gd2lsbCBiZSBhIGJyZWFraW5nIEFQSSBjaGFuZ2VcclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnB1c2hMb2FkaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LmNvbnN0cnVjdChmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgICAgICAkLmFqYXgoJC5leHRlbmQoe30sIC8vIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgICAgIEpzb25GZWVkRXZlbnRTb3VyY2UuQUpBWF9ERUZBVUxUUywgYWpheFNldHRpbmdzLCB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IF90aGlzLnVybCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3RQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmF3RXZlbnREZWZzLCBzdGF0dXMsIHhocikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja1JlcztcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxlbmRhci5wb3BMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1JlcyA9IHV0aWxfMS5hcHBseUFsbChvblN1Y2Nlc3MsIF90aGlzLCBbcmF3RXZlbnREZWZzLCBzdGF0dXMsIHhocl0pOyAvLyByZWRpcmVjdCBgdGhpc2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShjYWxsYmFja1JlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50RGVmcyA9IGNhbGxiYWNrUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZShfdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXNUZXh0LCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXBwbHlBbGwob25FcnJvciwgX3RoaXMsIFt4aHIsIHN0YXR1c1RleHQsIGVycm9yVGhyb3duXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5idWlsZFJlcXVlc3RQYXJhbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBhamF4U2V0dGluZ3MgPSB0aGlzLmFqYXhTZXR0aW5ncztcclxuICAgICAgICB2YXIgc3RhcnRQYXJhbTtcclxuICAgICAgICB2YXIgZW5kUGFyYW07XHJcbiAgICAgICAgdmFyIHRpbWV6b25lUGFyYW07XHJcbiAgICAgICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHN0YXJ0UGFyYW0gPSB0aGlzLnN0YXJ0UGFyYW07XHJcbiAgICAgICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFBhcmFtID0gY2FsZW5kYXIub3B0KCdzdGFydFBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFBhcmFtID0gdGhpcy5lbmRQYXJhbTtcclxuICAgICAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnZW5kUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZXpvbmVQYXJhbSA9IHRoaXMudGltZXpvbmVQYXJhbTtcclxuICAgICAgICBpZiAodGltZXpvbmVQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRpbWV6b25lUGFyYW0gPSBjYWxlbmRhci5vcHQoJ3RpbWV6b25lUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUICQuYWpheCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcclxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGFqYXhTZXR0aW5ncy5kYXRhKSkge1xyXG4gICAgICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xyXG4gICAgICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IHN0YXJ0LmZvcm1hdCgpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBlbmQuZm9ybWF0KCk7XHJcbiAgICAgICAgaWYgKHRpbWV6b25lICYmIHRpbWV6b25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lem9uZVBhcmFtXSA9IHRpbWV6b25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB0aGlzLmFqYXhTZXR0aW5ncyA9IHJhd1Byb3BzO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UuQUpBWF9ERUZBVUxUUyA9IHtcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGNhY2hlOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBKc29uRmVlZEV2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBKc29uRmVlZEV2ZW50U291cmNlO1xyXG5Kc29uRmVlZEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgLy8gYXV0b21hdGljYWxseSB0cmFuc2ZlciAodHJ1ZSkuLi5cclxuICAgIHVybDogdHJ1ZSxcclxuICAgIHN0YXJ0UGFyYW06IHRydWUsXHJcbiAgICBlbmRQYXJhbTogdHJ1ZSxcclxuICAgIHRpbWV6b25lUGFyYW06IHRydWVcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgVGFza1F1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFza1F1ZXVlKCkge1xyXG4gICAgICAgIHRoaXMucSA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5xLnB1c2guYXBwbHkodGhpcy5xLCBhcmdzKTsgLy8gYXBwZW5kXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmdldElzSWRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUudHJ5U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiB0aGlzLmNhblJ1bk5leHQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5SZW1haW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiB0aGlzLnEubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLnEuc2hpZnQoKTsgLy8gYWx3YXlzIGZyZXNobHkgcmVmZXJlbmNlIHEuIG1pZ2h0IGhhdmUgYmVlbiByZWFzc2lnbmVkLlxyXG4gICAgICAgICAgICByZXMgPSB0aGlzLnJ1blRhc2sodGFzayk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBwcmV2ZW50IG1hcmtpbmcgYXMgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5SdW5OZXh0KCkpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBub3QgcmVhbGx5IGEgJ3N0b3AnIC4uLiBtb3JlIG9mIGEgJ2RyYWluZWQnXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBpZiAnc3RvcCcgaGFuZGxlciBhZGRlZCBtb3JlIHRhc2tzLi4uLiBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhc2soKTsgLy8gdGFzayAqaXMqIHRoZSBmdW5jdGlvbiwgYnV0IHN1YmNsYXNzZXMgY2FuIGNoYW5nZSB0aGUgZm9ybWF0IG9mIGEgdGFza1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrUXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhc2tRdWV1ZTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRhc2tRdWV1ZSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRhc2tRdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTcpO1xyXG52YXIgUmVuZGVyUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZW5kZXJRdWV1ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclF1ZXVlKHdhaXRzQnlOYW1lc3BhY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndhaXRzQnlOYW1lc3BhY2UgPSB3YWl0c0J5TmFtZXNwYWNlIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICh0YXNrRnVuYywgbmFtZXNwYWNlLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHRhc2sgPSB7XHJcbiAgICAgICAgICAgIGZ1bmM6IHRhc2tGdW5jLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdhaXRNcztcclxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IHRoaXMud2FpdHNCeU5hbWVzcGFjZVtuYW1lc3BhY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVdhaXQod2FpdE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG91bmRUYXNrKHRhc2spKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V2FpdChuYW1lc3BhY2UsIHdhaXRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnN0YXJ0V2FpdCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIHdhaXRNcykge1xyXG4gICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5kZWxheVdhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5zcGF3bldhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLndhaXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMudHJ5U3RhcnQoKTtcclxuICAgICAgICB9LCB3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jbGVhcldhaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xyXG4gICAgICAgICAgICB0aGlzLndhaXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3N1cGVyLnByb3RvdHlwZS5jYW5SdW5OZXh0LmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YWl0aW5nIGZvciBhIGNlcnRhaW4gbmFtZXNwYWNlIHRvIHN0b3AgcmVjZWl2aW5nIHRhc2tzP1xyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnE7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGRpZmZlcmVudCBuYW1lc3BhY2UgdGFzayBpbiB0aGUgbWVhbnRpbWUsXHJcbiAgICAgICAgICAgIC8vIHRoYXQgZm9yY2VzIGFsbCBwcmV2aW91c2x5LXdhaXRpbmcgdGFza3MgdG8gc3VkZGVubHkgZXhlY3V0ZS5cclxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBkbyB0aGlzIGluIGNvbnN0YW50IHRpbWUuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHFbaV0ubmFtZXNwYWNlICE9PSB0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gYWxsb3cgZXhlY3V0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgdGFzay5mdW5jKCk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmNvbXBvdW5kVGFzayA9IGZ1bmN0aW9uIChuZXdUYXNrKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLnE7XHJcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgaWYgKG5ld1Rhc2submFtZXNwYWNlICYmIG5ld1Rhc2sudHlwZSA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgaW5pdC9hZGQvcmVtb3ZlIG9wcyB3aXRoIHNhbWUgbmFtZXNwYWNlLCByZWdhcmRsZXNzIG9mIG9yZGVyXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHRhc2sgPSBxW2ldO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YXNrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbml0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQXBwZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxhdGVzdCBkZXN0cm95IGlzIGNhbmNlbGxlZCBvdXQgYnkgbm90IGRvaW5nIHRoZSBpbml0XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgdGFza1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRBcHBlbmQpIHtcclxuICAgICAgICAgICAgcS5wdXNoKG5ld1Rhc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hvdWxkQXBwZW5kO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZW5kZXJRdWV1ZTtcclxufShUYXNrUXVldWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlclF1ZXVlO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBkYXRlX2Zvcm1hdHRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG52YXIgQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNyk7XHJcbnZhciB1dGlsXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudChfdmlldywgX29wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzUlRMID0gZmFsc2U7IC8vIGZyZXF1ZW50bHkgYWNjZXNzZWQgb3B0aW9uc1xyXG4gICAgICAgIF90aGlzLmhpdHNOZWVkZWREZXB0aCA9IDA7IC8vIG5lY2Vzc2FyeSBiZWNhdXNlIG11bHRpcGxlIGNhbGxlcnMgbWlnaHQgbmVlZCB0aGUgc2FtZSBoaXRzXHJcbiAgICAgICAgX3RoaXMuaGFzQWxsRGF5QnVzaW5lc3NIb3VycyA9IGZhbHNlOyAvLyBUT0RPOiB1bmlmeSB3aXRoIGxhcmdlVW5pdCBhbmQgaXNUaW1lU2NhbGU/XHJcbiAgICAgICAgX3RoaXMuaXNEYXRlc1JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gaGFjayB0byBzZXQgb3B0aW9ucyBwcmlvciB0byB0aGUgdGhpcy5vcHQgY2FsbHNcclxuICAgICAgICBpZiAoX3ZpZXcpIHtcclxuICAgICAgICAgICAgX3RoaXNbJ3ZpZXcnXSA9IF92aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX29wdGlvbnMpIHtcclxuICAgICAgICAgICAgX3RoaXNbJ29wdGlvbnMnXSA9IF9vcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy51aWQgPSBTdHJpbmcoRGF0ZUNvbXBvbmVudC5ndWlkKyspO1xyXG4gICAgICAgIF90aGlzLmNoaWxkcmVuQnlVaWQgPSB7fTtcclxuICAgICAgICBfdGhpcy5uZXh0RGF5VGhyZXNob2xkID0gbW9tZW50LmR1cmF0aW9uKF90aGlzLm9wdCgnbmV4dERheVRocmVzaG9sZCcpKTtcclxuICAgICAgICBfdGhpcy5pc1JUTCA9IF90aGlzLm9wdCgnaXNSVEwnKTtcclxuICAgICAgICBpZiAoX3RoaXMuZmlsbFJlbmRlcmVyQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZmlsbFJlbmRlcmVyID0gbmV3IF90aGlzLmZpbGxSZW5kZXJlckNsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJlbmRlcmVyID0gbmV3IF90aGlzLmV2ZW50UmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZmlsbFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmhlbHBlclJlbmRlcmVyQ2xhc3MgJiYgX3RoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5oZWxwZXJSZW5kZXJlciA9IG5ldyBfdGhpcy5oZWxwZXJSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5ldmVudFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MgJiYgX3RoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyID0gbmV3IF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmZpbGxSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSA9IGNoaWxkO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBvbmx5IGRvIGlmIGlzSW5Eb20/XHJcbiAgICAvLyBUT0RPOiBtYWtlIHBhcnQgb2YgQ29tcG9uZW50LCBhbG9uZyB3aXRoIGNoaWxkcmVuL2JhdGNoLXJlbmRlciBzeXN0ZW0/XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VwZGF0ZVNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIE9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWV3KCkub3B0KG5hbWUpOyAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uXHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5wdWJsaWNseVRyaWdnZXIuYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5oYXNQdWJsaWNIYW5kbGVycy5hcHBseShjYWxlbmRhciwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlOyAvLyBmb3IgcmVuZGVyaW5nXHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRlcyhkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRGF0ZVJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZURhdGVVbnJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckRhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIGRhdGUtY2VsbCBjb250ZW50IG9ubHlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvLyBOb3ctSW5kaWNhdG9yXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyB1bml0LCBsaWtlICdzZWNvbmQnIG9yICdtaW51dGUnIHRoYXQgZGVmaW5lZCBob3cgb2Z0ZW4gdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3JcclxuICAgIC8vIHNob3VsZCBiZSByZWZyZXNoZWQuIElmIHNvbWV0aGluZyBmYWxzeSBpcyByZXR1cm5lZCwgbm8gdGltZSBpbmRpY2F0b3IgaXMgcmVuZGVyZWQgYXQgYWxsLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGEgY3VycmVudCB0aW1lIGluZGljYXRvciBhdCB0aGUgZ2l2ZW4gZGF0ZXRpbWVcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlck5vd0luZGljYXRvcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5kb2VzIHRoZSByZW5kZXJpbmcgYWN0aW9ucyBmcm9tIHJlbmRlck5vd0luZGljYXRvclxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyTm93SW5kaWNhdG9yJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBCdXNpbmVzcyBIb3Vyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIucmVuZGVyKGJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJCdXNpbmVzc0hvdXJzJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgcHJldmlvdXNseS1yZW5kZXJlZCBidXNpbmVzcy1ob3Vyc1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckJ1c2luZXNzSG91cnMnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgRGlzcGxheWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVFdmVudFJlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmFuZ2VVcGRhdGVkKCk7IC8vIHBvb3JseSBuYW1lZCBub3dcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlcihldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpc1sncmVuZGVyRXZlbnRzJ10pIHtcclxuICAgICAgICAgICAgdGhpc1sncmVuZGVyRXZlbnRzJ10oY29udmVydEV2ZW50c1BheWxvYWRUb0xlZ2FjeUFycmF5KGV2ZW50c1BheWxvYWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVFdmVudFJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVFdmVudFVucmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzWydkZXN0cm95RXZlbnRzJ10pIHtcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveUV2ZW50cyddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEJ1c2luZXNzSG91clNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkJ1c2luZXNzSG91clNlZ3MoKTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIGNoaWxkLmdldEJ1c2luZXNzSG91clNlZ3MoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3duQnVzaW5lc3NIb3VyU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci5nZXRTZWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRFdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkV2ZW50U2VncygpO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgY2hpbGQuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVuZGVyZXIuZ2V0U2VncygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVuZGVyaW5nIFRyaWdnZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudHNSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyQWxsUmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpc11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhbiBvcHRpbWl6YXRpb24sIGJlY2F1c2UgZ2V0RXZlbnRMZWdhY3kgaXMgZXhwZW5zaXZlXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50QWZ0ZXJSZW5kZXInKSkge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2FjeTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdhY3kgPSBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyUmVuZGVyJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIHNlZy5lbCwgX3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQmVmb3JlRXZlbnRzRGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckJlZm9yZUV2ZW50U2Vnc0Rlc3Ryb3llZCh0aGlzLmdldEV2ZW50U2VncygpKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudERlc3Ryb3knKSkge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2FjeTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdhY3kgPSBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudERlc3Ryb3knLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGxlZ2FjeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xlZ2FjeSwgc2VnLmVsLCBfdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEhpZGVzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XHJcbiAgICAvLyBSRUNVUlNJVkUgd2l0aCBzdWJjb21wb25lbnRzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG93RXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZCAmJlxyXG4gICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3Nob3dFdmVudHNXaXRoSWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFNob3dzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XHJcbiAgICAvLyBSRUNVUlNJVkUgd2l0aCBzdWJjb21wb25lbnRzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZCAmJlxyXG4gICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpZGVFdmVudHNXaXRoSWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIERyYWctbi1Ecm9wIFJlbmRlcmluZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBkcmFnIG92ZXIgdGhlIGdpdmVuIGRyb3Agem9uZS5cclxuICAgIC8vIElmIGFuIGV4dGVybmFsLWVsZW1lbnQsIHNlZyB3aWxsIGJlIGBudWxsYC5cclxuICAgIC8vIE11c3QgcmV0dXJuIGVsZW1lbnRzIHVzZWQgZm9yIGFueSBtb2NrIGV2ZW50cy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRIZWxwZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnJlbmRlckRyYWcoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRIZWxwZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckRyYWcnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyRXZlbnRSZXNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckV2ZW50UmVzaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWxlY3Rpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHRoZSBzZWxlY3Rpb25cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBgcmVuZGVyU2VsZWN0aW9uYCBhZnRlciBsZWdhY3kgaXMgZ29uZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlclNlbGVjdGlvbkZvb3RwcmludCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2Ygc2VsZWN0aW9uXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyU2VsZWN0aW9uJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBIaWdobGlnaHRcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhbiBlbXBoYXNpcyBvbiB0aGUgZ2l2ZW4gZGF0ZSByYW5nZS4gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVySGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci5yZW5kZXJGb290cHJpbnQoJ2hpZ2hsaWdodCcsIGNvbXBvbmVudEZvb3RwcmludCwge1xyXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZjLWhpZ2hsaWdodCddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckhpZ2hsaWdodCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBlbXBoYXNpcyBvbiBhIGRhdGUgcmFuZ2VcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVySGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignaGlnaGxpZ2h0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckhpZ2hsaWdodCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSGl0IEFyZWFzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGp1c3QgYmVjYXVzZSBhbGwgRGF0ZUNvbXBvbmVudHMgc3VwcG9ydCB0aGlzIGludGVyZmFjZVxyXG4gICAgLy8gZG9lc24ndCBtZWFuIHRoZXkgbmVlZCB0byBoYXZlIHRoZWlyIG93biBpbnRlcm5hbCBjb29yZCBzeXN0ZW0uIHRoZXkgY2FuIGRlZmVyIHRvIHN1Yi1jb21wb25lbnRzLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGl0c05lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmhpdHNOZWVkZWREZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXBhcmVIaXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaXRzTmVlZGVkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaXRzTm90TmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdHNOZWVkZWREZXB0aCAmJiAhKC0tdGhpcy5oaXRzTmVlZGVkRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpdHNOb3ROZWVkZWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGNvb3JkaW5hdGVzIGZyb20gdGhlIHRvcGxlZnQgb2YgdGhlIGRvY3VtZW50LCByZXR1cm4gZGF0YSBhYm91dCB0aGUgZGF0ZS1yZWxhdGVkIGFyZWEgdW5kZXJuZWF0aC5cclxuICAgIC8vIENhbiByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXJiaXRyYXJ5IHByb3BlcnRpZXMgKGFsdGhvdWdoIHRvcC9yaWdodC9sZWZ0L2JvdHRvbSBhcmUgZW5jb3VyYWdlZCkuXHJcbiAgICAvLyBNdXN0IGhhdmUgYSBgZ3JpZGAgcHJvcGVydHksIGEgcmVmZXJlbmNlIHRvIHRoaXMgY3VycmVudCBncmlkLiBUT0RPOiBhdm9pZCB0aGlzXHJcbiAgICAvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGdldEhpdEZvb3RwcmludCBhbmQgZ2V0SGl0RWwuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW5CeVVpZCA9IHRoaXMuY2hpbGRyZW5CeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gY2hpbGRyZW5CeVVpZCkge1xyXG4gICAgICAgICAgICBoaXQgPSBjaGlsZHJlbkJ5VWlkW3VpZF0ucXVlcnlIaXQobGVmdE9mZnNldCwgdG9wT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRTYWZlSGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBmb290cHJpbnQgPSB0aGlzLmdldEhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShmb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvb3RwcmludDtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gd2hhdCBhYm91dCBiZWluZyBhYnN0cmFjdCE/XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gcG9zaXRpb24tbGV2ZWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLXJlbGF0ZWQgYXJlYSB3aXRoaW4gdGhlIGdyaWQsXHJcbiAgICAvLyBzaG91bGQgcmV0dXJuIGEgalF1ZXJ5IGVsZW1lbnQgdGhhdCBiZXN0IHJlcHJlc2VudHMgaXQuIHBhc3NlZCB0byBkYXlDbGljayBjYWxsYmFjay5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIHdoYXQgYWJvdXQgYmVpbmcgYWJzdHJhY3QhP1xyXG4gICAgfTtcclxuICAgIC8qIENvbnZlcnRpbmcgZXZlbnRSYW5nZSAtPiBldmVudEZvb3RwcmludFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gW3V0aWxfMi5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludChldmVudFJhbmdlKV07XHJcbiAgICB9O1xyXG4gICAgLyogQ29udmVydGluZyBjb21wb25lbnRGb290cHJpbnQvZXZlbnRGb290cHJpbnQgLT4gc2Vnc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50Rm9vdHByaW50c1RvU2VncyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIHRoaXMuZXZlbnRGb290cHJpbnRUb1NlZ3MoZXZlbnRGb290cHJpbnRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGV2ZW50J3Mgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxyXG4gICAgLy8gc2xpY2VzIGludG8gc2VnbWVudHMgYW5kIGF0dGFjaGVzIGV2ZW50LWRlcml2ZWQgcHJvcGVydGllcyB0byB0aGVtLlxyXG4gICAgLy8gZXZlbnRTcGFuIC0geyBzdGFydCwgZW5kLCBpc1N0YXJ0LCBpc0VuZCwgb3RoZXJ0aGluZ3MuLi4gfVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgc2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyhldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICghdW56b25lZFJhbmdlLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1bnpvbmVkUmFuZ2UuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZy5mb290cHJpbnQgPSBldmVudEZvb3RwcmludDtcclxuICAgICAgICAgICAgLy8gVE9ETzogcmVuYW1lIHRvIHNlZy5ldmVudEZvb3RwcmludFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNhbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGNoaWxkW21ldGhvZE5hbWVdLmFwcGx5KGNoaWxkLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkJ5VWlkID0gdGhpcy5jaGlsZHJlbkJ5VWlkO1xyXG4gICAgICAgIHZhciB1aWQ7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gY2hpbGRyZW5CeVVpZCkge1xyXG4gICAgICAgICAgICBmdW5jKGNoaWxkcmVuQnlVaWRbdWlkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXRDYWxlbmRhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHQuY2FsZW5kYXIgfHwgdC52aWV3LmNhbGVuZGFyO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldERhdGVQcm9maWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWV3KCkuZ2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBhbmNob3IgdG8gYW5vdGhlciB2aWV3IGludG8gdGhlIGNhbGVuZGFyLlxyXG4gICAgLy8gV2lsbCBlaXRoZXIgZ2VuZXJhdGUgYW4gPGE+IHRhZyBvciBhIG5vbi1jbGlja2FibGUgPHNwYW4+IHRhZywgZGVwZW5kaW5nIG9uIGVuYWJsZWQgc2V0dGluZ3MuXHJcbiAgICAvLyBgZ290b09wdGlvbnNgIGNhbiBlaXRoZXIgYmUgYSBtb21lbnQgaW5wdXQsIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBmb3JtOlxyXG4gICAgLy8geyBkYXRlLCB0eXBlLCBmb3JjZU9mZiB9XHJcbiAgICAvLyBgdHlwZWAgaXMgYSB2aWV3LXR5cGUgbGlrZSBcImRheVwiIG9yIFwid2Vla1wiLiBkZWZhdWx0IHZhbHVlIGlzIFwiZGF5XCIuXHJcbiAgICAvLyBgYXR0cnNgIGFuZCBgaW5uZXJIdG1sYCBhcmUgdXNlIHRvIGdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBIVE1MIHRhZy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkR290b0FuY2hvckh0bWwgPSBmdW5jdGlvbiAoZ290b09wdGlvbnMsIGF0dHJzLCBpbm5lckh0bWwpIHtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICB2YXIgZm9yY2VPZmY7XHJcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucztcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGdvdG9PcHRpb25zKSkge1xyXG4gICAgICAgICAgICBkYXRlID0gZ290b09wdGlvbnMuZGF0ZTtcclxuICAgICAgICAgICAgdHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XHJcbiAgICAgICAgICAgIGZvcmNlT2ZmID0gZ290b09wdGlvbnMuZm9yY2VPZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRlID0gZ290b09wdGlvbnM7IC8vIGEgc2luZ2xlIG1vbWVudCBpbnB1dFxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlID0gbW9tZW50X2V4dF8xLmRlZmF1bHQoZGF0ZSk7IC8vIGlmIGEgc3RyaW5nLCBwYXJzZSBpdFxyXG4gICAgICAgIGZpbmFsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnZGF5J1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaW5uZXJIdG1sID0gYXR0cnM7XHJcbiAgICAgICAgICAgIGF0dHJzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXR0cnMgPSBhdHRycyA/ICcgJyArIHV0aWxfMS5hdHRyc1RvU3RyKGF0dHJzKSA6ICcnOyAvLyB3aWxsIGhhdmUgYSBsZWFkaW5nIHNwYWNlXHJcbiAgICAgICAgaW5uZXJIdG1sID0gaW5uZXJIdG1sIHx8ICcnO1xyXG4gICAgICAgIGlmICghZm9yY2VPZmYgJiYgdGhpcy5vcHQoJ25hdkxpbmtzJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8YScgKyBhdHRycyArXHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZ290bz1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShmaW5hbE9wdGlvbnMpKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCArXHJcbiAgICAgICAgICAgICAgICAnPC9hPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxzcGFuJyArIGF0dHJzICsgJz4nICtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCArXHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPic7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEFsbERheUh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdhbGxEYXlIdG1sJykgfHwgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ2FsbERheVRleHQnKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgSFRNTCBjbGFzc05hbWVzIGZvciBhIHNpbmdsZS1kYXkgZWxlbWVudFxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGF5Q2xhc3NlcyA9IGZ1bmN0aW9uIChkYXRlLCBub1RoZW1lSGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuICAgICAgICB2YXIgdG9kYXk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSkpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kaXNhYmxlZC1kYXknKTsgLy8gVE9ETzogalF1ZXJ5IFVJIHRoZW1lP1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy0nICsgdXRpbF8xLmRheUlEc1tkYXRlLmRheSgpXSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmlzRGF0ZUluT3RoZXJNb250aChkYXRlLCB0aGlzLmRhdGVQcm9maWxlKSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1vdGhlci1tb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvZGF5ID0gdmlldy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgaWYgKGRhdGUuaXNTYW1lKHRvZGF5LCAnZGF5JykpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtdG9kYXknKTtcclxuICAgICAgICAgICAgICAgIGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGUgPCB0b2RheSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1wYXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXHJcbiAgICAvLyBEaXNwbGF5cyBhbGwtZGF5IHJhbmdlcyBuYXR1cmFsbHksIHdpdGggYW4gaW5jbHVzaXZlIGVuZC4gVGFrZXMgdGhlIGN1cnJlbnQgaXNSVEwgaW50byBhY2NvdW50LlxyXG4gICAgLy8gVGhlIHRpbWV6b25lcyBvZiB0aGUgZGF0ZXMgd2l0aGluIGByYW5nZWAgd2lsbCBiZSByZXNwZWN0ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgaXNBbGxEYXksIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICBpZiAoaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIGVuZCwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIHRoaXMuaXNSVEwpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiB0aGUgZ2l2ZSB1bml0cyBpbiB0aGUgXCJjdXJyZW50XCIgcmFuZ2UuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gV29uJ3Qgcm91bmQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50UmFuZ2VBcyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERhdGVQcm9maWxlKCkuY3VycmVudFVuem9uZWRSYW5nZS5hcyh1bml0KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBkYXRlIHJhbmdlIG9mIHRoZSBmdWxsIGRheXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhcnMgdG8gb2NjdXB5LlxyXG4gICAgLy8gUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIHN0YXJ0L2VuZCwgTk9UIGFuIFVuem9uZWRSYW5nZSFcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNvbXB1dGVEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHZhciBzdGFydERheSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xyXG4gICAgICAgIHZhciBlbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KHVuem9uZWRSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9ICtlbmQudGltZSgpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXHJcbiAgICAgICAgdmFyIGVuZERheSA9IGVuZC5jbG9uZSgpLnN0cmlwVGltZSgpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIGV4Y2x1c2l2ZWx5IGVuZHNcclxuICAgICAgICAvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXHJcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxyXG4gICAgICAgIGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBlbmREYXkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXHJcbiAgICAgICAgaWYgKGVuZERheSA8PSBzdGFydERheSkge1xyXG4gICAgICAgICAgICBlbmREYXkgPSBzdGFydERheS5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XHJcbiAgICB9O1xyXG4gICAgLy8gRG9lcyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFyIHRvIG9jY3VweSBtb3JlIHRoYW4gb25lIGRheT9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzTXVsdGlEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSB0aGlzLmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiBkYXlSYW5nZS5lbmQuZGlmZihkYXlSYW5nZS5zdGFydCwgJ2RheXMnKSA+IDE7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5ndWlkID0gMDsgLy8gVE9ETzogYmV0dGVyIHN5c3RlbSBmb3IgdGhpcz9cclxuICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xyXG59KENvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNvbXBvbmVudDtcclxuLy8gbGVnYWN5XHJcbmZ1bmN0aW9uIGNvbnZlcnRFdmVudHNQYXlsb2FkVG9MZWdhY3lBcnJheShldmVudHNQYXlsb2FkKSB7XHJcbiAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgIHZhciBldmVudEluc3RhbmNlcztcclxuICAgIHZhciBsZWdhY3lFdmVudHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICBldmVudEluc3RhbmNlcyA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF0uZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUV2ZW50cy5wdXNoKGV2ZW50SW5zdGFuY2VzW2ldLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdhY3lFdmVudHM7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIEl0ZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOCk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgVG9vbGJhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzkpO1xyXG52YXIgT3B0aW9uc01hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQwKTtcclxudmFyIFZpZXdTcGVjTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDEpO1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3KTtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50TWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDIpO1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMik7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcbnZhciBDYWxlbmRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhbGVuZGFyKGVsLCBvdmVycmlkZXMpIHtcclxuICAgICAgICB0aGlzLmxvYWRpbmdMZXZlbCA9IDA7IC8vIG51bWJlciBvZiBzaW11bHRhbmVvdXMgbG9hZGluZyB0YXNrc1xyXG4gICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoID0gMDtcclxuICAgICAgICAvLyBkZWNsYXJlIHRoZSBjdXJyZW50IGNhbGVuZGFyIGluc3RhbmNlIHJlbGllcyBvbiBHbG9iYWxFbWl0dGVyLiBuZWVkZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICAgICAgICAvLyB1bm5lZWRlZCgpIGlzIGNhbGxlZCBpbiBkZXN0cm95LlxyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0Lm5lZWRlZCgpO1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLnZpZXdzQnlUeXBlID0ge307XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcl8xLmRlZmF1bHQodGhpcywgb3ZlcnJpZGVzKTtcclxuICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlciA9IG5ldyBWaWV3U3BlY01hbmFnZXJfMS5kZWZhdWx0KHRoaXMub3B0aW9uc01hbmFnZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdE1vbWVudEludGVybmFscygpOyAvLyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgb3B0aW9ucyBoYXNoIGluaXRpYWxpemVkXHJcbiAgICAgICAgdGhpcy5pbml0Q3VycmVudERhdGUoKTtcclxuICAgICAgICB0aGlzLmluaXRFdmVudE1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gbmV3IENvbnN0cmFpbnRzXzEuZGVmYXVsdCh0aGlzLmV2ZW50TWFuYWdlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RlZCgpO1xyXG4gICAgfVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbnN0cnVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgbW9ua2V5cGF0Y2hpbmcuIHVzZWQ/XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIHRyaWdnZXJJbmZvKSB7XHJcbiAgICAgICAgdmFyIG9wdEhhbmRsZXIgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICB2YXIgY29udGV4dDtcclxuICAgICAgICB2YXIgYXJncztcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRyaWdnZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gdHJpZ2dlckluZm8uY29udGV4dDtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvLmFyZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheSh0cmlnZ2VySW5mbykpIHtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmVsWzBdOyAvLyBmYWxsYmFjayBjb250ZXh0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJncykge1xyXG4gICAgICAgICAgICBhcmdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcldpdGgobmFtZSwgY29udGV4dCwgYXJncyk7IC8vIEVtaXR0ZXIncyBtZXRob2RcclxuICAgICAgICBpZiAob3B0SGFuZGxlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0SGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNIYW5kbGVycyhuYW1lKSB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdChuYW1lKTsgLy8gaGFuZGxlciBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIC8vIE9wdGlvbnMgUHVibGljIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHB1YmxpYyBnZXR0ZXIvc2V0dGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5ld09wdGlvbkhhc2g7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGQobmV3T3B0aW9uSGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuYWRkKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBwcml2YXRlIGdldHRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluc3RhbnRpYXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIGlmICghc3BlYykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3IHR5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IHZhbGlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IHNwZWNbJ2NsYXNzJ10odGhpcywgc3BlYyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc1ZhbGlkVmlld1R5cGUgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jaGFuZ2VWaWV3ID0gZnVuY3Rpb24gKHZpZXdOYW1lLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnJlY29yZE92ZXJyaWRlcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGF0ZU9yUmFuZ2UpLnN0cmlwWm9uZSgpOyAvLyBqdXN0IGxpa2UgZ290b0RhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodmlld05hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAobmV3RGF0ZSwgdmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgc3BlYztcclxuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXHJcbiAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXdEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcclxuICAgIH07XHJcbiAgICAvLyBDdXJyZW50IERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEN1cnJlbnREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0RGF0ZUlucHV0ID0gdGhpcy5vcHQoJ2RlZmF1bHREYXRlJyk7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXHJcbiAgICAgICAgaWYgKGRlZmF1bHREYXRlSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGVmYXVsdERhdGVJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAocHJldkluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gcHJldkluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAobmV4dEluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gbmV4dEluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2WWVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlLmFkZCgtMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKDEsICd5ZWFycycpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gc2hvdWxkIGRlbnkgbGlrZSBwcmV2L25leHQ/XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KHpvbmVkRGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIC8vIGZvciBleHRlcm5hbCBBUElcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VGltZXpvbmUodGhpcy5jdXJyZW50RGF0ZSk7IC8vIGluZnVzZSB0aGUgY2FsZW5kYXIncyB0aW1lem9uZVxyXG4gICAgfTtcclxuICAgIC8vIExvYWRpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGJlZ2luc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1c2hMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW3RydWUsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBjb21wbGV0ZXNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wb3BMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKC0tdGhpcy5sb2FkaW5nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW2ZhbHNlLCB0aGlzLnZpZXddKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RWwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAvLyBtYWlubHkgZm9yIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3U2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdGlhbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgZWwuYWRkQ2xhc3MoJ2ZjJyk7XHJcbiAgICAgICAgLy8gZXZlbnQgZGVsZWdhdGlvbiBmb3IgbmF2IGxpbmtzXHJcbiAgICAgICAgZWwub24oJ2NsaWNrLmZjJywgJ2FbZGF0YS1nb3RvXScsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5kYXRhKCdnb3RvJyk7IC8vIHdpbGwgYXV0b21hdGljYWxseSBwYXJzZSBKU09OXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gX3RoaXMubW9tZW50KGdvdG9PcHRpb25zLmRhdGUpO1xyXG4gICAgICAgICAgICB2YXIgdmlld1R5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBsaWtlIFwibmF2TGlua0RheUNsaWNrXCIuIG1pZ2h0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXcub3B0KCduYXZMaW5rJyArIHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIodmlld1R5cGUpICsgJ0NsaWNrJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tVG8oZGF0ZSwgdmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnc2V0dGluZ1RoZW1lJywgWyc/dGhlbWUnLCAnP3RoZW1lU3lzdGVtJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzID0gVGhlbWVSZWdpc3RyeV8xLmdldFRoZW1lU3lzdGVtQ2xhc3Mob3B0cy50aGVtZVN5c3RlbSB8fCBvcHRzLnRoZW1lKTtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gbmV3IHRoZW1lQ2xhc3MoX3RoaXMub3B0aW9uc01hbmFnZXIpO1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3Mod2lkZ2V0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSBfdGhpcy50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHdpZGdldENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyh3aWRnZXRDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdzZXR0aW5nQnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgWyc/YnVzaW5lc3NIb3VycyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBuZXcgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEuZGVmYXVsdChkZXBzLmJ1c2luZXNzSG91cnMsIF90aGlzKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuc2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InLCBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHVwb24gb3B0aW9uIGNoYW5nZS5cclxuICAgICAgICAvLyBIQUNLOiBsb2NhbGUgb2Z0ZW4gYWZmZWN0cyBpc1JUTCwgc28gd2UgZXhwbGljaXRseSBsaXN0ZW4gdG8gdGhhdCB0b28uXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYXBwbHlpbmdEaXJDbGFzc2VzJywgWyc/aXNSVEwnLCAnP2xvY2FsZSddLCBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtbHRyJywgIW9wdHMuaXNSVEwpO1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtcnRsJywgb3B0cy5pc1JUTCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdmlldy1jb250YWluZXInLz5cIikucHJlcGVuZFRvKGVsKTtcclxuICAgICAgICB0aGlzLmluaXRUb29sYmFycygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVySGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGb290ZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodGhpcy5vcHQoJ2RlZmF1bHRWaWV3JykpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnaGFuZGxlV2luZG93UmVzaXplJykpIHtcclxuICAgICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gdXRpbF8xLmRlYm91bmNlKC8vIHByZXZlbnRzIHJhcGlkIGNhbGxzXHJcbiAgICAgICAgICAgIHRoaXMud2luZG93UmVzaXplLmJpbmQodGhpcyksIHRoaXMub3B0KCd3aW5kb3dSZXNpemVEZWxheScpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdyZW1vdmVFbGVtZW50Jyk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVDbGFzcygnZmMgZmMtbHRyIGZjLXJ0bCcpO1xyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlbWUtcmVsYXRlZCByb290IGNsYXNzTmFtZVxyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIudW53YXRjaCgnc2V0dGluZ1RoZW1lJyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci51bndhdGNoKCdzZXR0aW5nQnVzaW5lc3NIb3VyR2VuZXJhdG9yJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJy5mYycpOyAvLyB1bmJpbmQgbmF2IGxpbmsgaGFuZGxlcnNcclxuICAgICAgICBpZiAodGhpcy53aW5kb3dSZXNpemVQcm94eSkge1xyXG4gICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemVQcm94eSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LnVubmVlZGVkKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmVsZW1lbnRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlzKCc6dmlzaWJsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlciBRdWV1ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5iaW5kVmlld0hhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZpZXcud2F0Y2goJ3RpdGxlRm9yQ2FsZW5kYXInLCBbJ3RpdGxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3ID09PSBfdGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUb29sYmFyc1RpdGxlKGRlcHMudGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlldy53YXRjaCgnZGF0ZVByb2ZpbGVGb3JDYWxlbmRhcicsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcgPT09IF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnREYXRlID0gZGVwcy5kYXRlUHJvZmlsZS5kYXRlOyAvLyBtaWdodCBoYXZlIGJlZW4gY29uc3RyYWluZWQgYnkgdmlldyBkYXRlc1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVG9vbGJhckJ1dHRvbnMoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudW5iaW5kVmlld0hhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ3RpdGxlRm9yQ2FsZW5kYXInKTtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ2RhdGVQcm9maWxlRm9yQ2FsZW5kYXInKTtcclxuICAgIH07XHJcbiAgICAvLyBWaWV3IFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aWV3IGJlY2F1c2Ugb2YgYSBkYXRlIGNoYW5nZSwgdmlldy10eXBlIGNoYW5nZSwgb3IgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAgLy8gSWYgbm90IGdpdmVuIGEgdmlld1R5cGUsIGtlZXAgdGhlIGN1cnJlbnQgdmlldyBidXQgcmVuZGVyIGRpZmZlcmVudCBkYXRlcy5cclxuICAgIC8vIEFjY2VwdHMgYW4gb3B0aW9uYWwgc2Nyb2xsIHN0YXRlIHRvIHJlc3RvcmUgdG8uXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXdWaWV3O1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIGlmIChvbGRWaWV3ICYmIHZpZXdUeXBlICYmIG9sZFZpZXcudHlwZSAhPT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdmlld1R5cGUgY2hhbmdlZCwgb3IgdGhlIHZpZXcgd2FzIG5ldmVyIGNyZWF0ZWQsIGNyZWF0ZSBhIGZyZXNoIHZpZXdcclxuICAgICAgICBpZiAoIXRoaXMudmlldyAmJiB2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBuZXdWaWV3ID0gdGhpcy52aWV3ID1cclxuICAgICAgICAgICAgICAgIHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdID0gdGhpcy5pbnN0YW50aWF0ZVZpZXcodmlld1R5cGUpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kVmlld0hhbmRsZXJzKG5ld1ZpZXcpO1xyXG4gICAgICAgICAgICBuZXdWaWV3LnN0YXJ0QmF0Y2hSZW5kZXIoKTsgLy8gc28gdGhhdCBzZXRFbGVtZW50K3NldERhdGUgcmVuZGVyaW5nIGFyZSBqb2luZWRcclxuICAgICAgICAgICAgbmV3Vmlldy5zZXRFbGVtZW50KCQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3IGZjLVwiICsgdmlld1R5cGUgKyBcIi12aWV3JyAvPlwiKS5hcHBlbmRUbyh0aGlzLmNvbnRlbnRFbCkpO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2FjdGl2YXRlQnV0dG9uJywgdmlld1R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIHByZXZlbnQgdW5uZWNlc3NhcnkgY2hhbmdlIGZpcmluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmdldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJykgIT09IHRoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InLCB0aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aWV3LnNldERhdGUodGhpcy5jdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3LnN0b3BCYXRjaFJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhd0NvbnRlbnRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGN1cnJlbnQgdmlldyBhbmQgcmVmbGVjdHMgdGhpcyBjaGFuZ2UgaW4gdGhlIEhlYWRlci5cclxuICAgIC8vIFVucmVnc2l0ZXJzIHRoZSBgdmlld2AsIGJ1dCBkb2VzIG5vdCByZW1vdmUgZnJvbSB2aWV3QnlUeXBlIGhhc2guXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2xlYXJWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50VmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2RlYWN0aXZhdGVCdXR0b24nLCBjdXJyZW50Vmlldy50eXBlKTtcclxuICAgICAgICB0aGlzLnVuYmluZFZpZXdIYW5kbGVycyhjdXJyZW50Vmlldyk7XHJcbiAgICAgICAgY3VycmVudFZpZXcucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIGN1cnJlbnRWaWV3LnVuc2V0RGF0ZSgpOyAvLyBzbyBiaW5kVmlld0hhbmRsZXJzIGRvZXNuJ3QgZmlyZSB3aXRoIG9sZCB2YWx1ZXMgbmV4dCB0aW1lXHJcbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBEZXN0cm95cyB0aGUgdmlldywgaW5jbHVkaW5nIHRoZSB2aWV3IG9iamVjdC4gVGhlbiwgcmUtaW5zdGFudGlhdGVzIGl0IGFuZCByZW5kZXJzIGl0LlxyXG4gICAgLy8gTWFpbnRhaW5zIHRoZSBzYW1lIHNjcm9sbCBzdGF0ZS5cclxuICAgIC8vIFRPRE86IG1haW50YWluIGFueSBvdGhlciB1c2VyLW1hbmlwdWxhdGVkIHN0YXRlLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlaW5pdFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9sZFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IG9sZFZpZXcucXVlcnlTY3JvbGwoKTsgLy8gd291bGRuJ3QgYmUgc28gY29tcGxpY2F0ZWQgaWYgQ2FsZW5kYXIgb3duZWQgdGhlIHNjcm9sbFxyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyhvbGRWaWV3LnR5cGUpOyAvLyBuZWVkcyB0aGUgdHlwZSB0byBmcmVzaGx5IHJlbmRlclxyXG4gICAgICAgIHRoaXMudmlldy5hcHBseVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgIHRoaXMudGhhd0NvbnRlbnRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmlzSGVpZ2h0QXV0byA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKSA9PT0gJ2F1dG8nIHx8IHRoaXMub3B0KCdoZWlnaHQnKSA9PT0gJ2F1dG8nO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVWaWV3U2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgIGlmIChpc1Jlc2l6ZSA9PT0gdm9pZCAwKSB7IGlzUmVzaXplID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgc2Nyb2xsO1xyXG4gICAgICAgIGlmICghdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSAmJiB2aWV3KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gdmlldy5xdWVyeVNjcm9sbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUrKztcclxuICAgICAgICAgICAgdmlldy51cGRhdGVTaXplKHRoaXMuZ2V0U3VnZ2VzdGVkVmlld0hlaWdodCgpLCB0aGlzLmlzSGVpZ2h0QXV0bygpLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUtLTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmFwcGx5U2Nyb2xsKHNjcm9sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHNpZ25hbCBzdWNjZXNzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jYWxjU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGNTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5fY2FsY1NpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHRJbnB1dCA9IHRoaXMub3B0KCdjb250ZW50SGVpZ2h0Jyk7XHJcbiAgICAgICAgdmFyIGhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2hlaWdodCcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0SW5wdXQgPT09ICdwYXJlbnQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IHRoaXMuZWwucGFyZW50KCkuaGVpZ2h0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5jb250ZW50RWwud2lkdGgoKSAvXHJcbiAgICAgICAgICAgICAgICBNYXRoLm1heCh0aGlzLm9wdCgnYXNwZWN0UmF0aW8nKSwgLjUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLndpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyB0aGUgcHVycG9zZTogc28gd2UgZG9uJ3QgcHJvY2VzcyBqcXVpIFwicmVzaXplXCIgZXZlbnRzIHRoYXQgaGF2ZSBidWJibGVkIHVwXHJcbiAgICAgICAgLy8gY2FzdCB0byBhbnkgYmVjYXVzZSAudGFyZ2V0LCB3aGljaCBpcyBFbGVtZW50LCBjYW4ndCBiZSBjb21wYXJlZCB0byB3aW5kb3cgZm9yIHNvbWUgcmVhc29uLlxyXG4gICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93ICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldyAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZVZpZXdTaXplKHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignd2luZG93UmVzaXplJywgW3RoaXMudmlld10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhlaWdodCBcIkZyZWV6aW5nXCJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mcmVlemVDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRlbnRFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnRoYXdDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoLS07XHJcbiAgICAgICAgLy8gYWx3YXlzIGJyaW5nIGJhY2sgdG8gbmF0dXJhbCBoZWlnaHRcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5jc3Moe1xyXG4gICAgICAgICAgICB3aWR0aDogJycsXHJcbiAgICAgICAgICAgIGhlaWdodDogJycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJ1dCBpZiB0aGVyZSBhcmUgZnV0dXJlIHRoYXdzLCByZS1mcmVlemVcclxuICAgICAgICBpZiAodGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVG9vbGJhclxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0VG9vbGJhcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgVG9vbGJhcl8xLmRlZmF1bHQodGhpcywgdGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBUb29sYmFyXzEuZGVmYXVsdCh0aGlzLCB0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyID0gbmV3IEl0ZXJhdG9yXzEuZGVmYXVsdChbdGhpcy5oZWFkZXIsIHRoaXMuZm9vdGVyXSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVIZWFkZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NlczogJ2ZjLWhlYWRlci10b29sYmFyJyxcclxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLm9wdCgnaGVhZGVyJylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlRm9vdGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHRyYUNsYXNzZXM6ICdmYy1mb290ZXItdG9vbGJhcicsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5vcHQoJ2Zvb3RlcicpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIEhlYWRlciB3aWxsIHJlcmVuZGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcjtcclxuICAgICAgICBoZWFkZXIuc2V0VG9vbGJhck9wdGlvbnModGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICBoZWFkZXIucmVuZGVyKCk7XHJcbiAgICAgICAgaWYgKGhlYWRlci5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnByZXBlbmQoaGVhZGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBGb290ZXIgd2lsbCByZXJlbmRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckZvb3RlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9vdGVyID0gdGhpcy5mb290ZXI7XHJcbiAgICAgICAgZm9vdGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUZvb3Rlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgZm9vdGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGlmIChmb290ZXIuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmQoZm9vdGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldFRvb2xiYXJzVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3VwZGF0ZVRpdGxlJywgdGl0bGUpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVUb29sYmFyQnV0dG9ucyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBub3cgPSB0aGlzLmdldE5vdygpO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciB0b2RheUluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdyk7XHJcbiAgICAgICAgdmFyIHByZXZJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoKHRvZGF5SW5mby5pc1ZhbGlkICYmICFkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShub3cpKSA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAndG9kYXknKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwocHJldkluZm8uaXNWYWxpZCA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAncHJldicpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbChuZXh0SW5mby5pc1ZhbGlkID9cclxuICAgICAgICAgICAgJ2VuYWJsZUJ1dHRvbicgOlxyXG4gICAgICAgICAgICAnZGlzYWJsZUJ1dHRvbicsICduZXh0Jyk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnF1ZXJ5VG9vbGJhcnNIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhcnNNYW5hZ2VyLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIHRvb2xiYXIpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2xiYXJIZWlnaHQgPSB0b29sYmFyLmVsID8gdG9vbGJhci5lbC5vdXRlckhlaWdodCh0cnVlKSA6IDA7IC8vIGluY2x1ZGVzIG1hcmdpblxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyB0b29sYmFySGVpZ2h0O1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuICAgIC8vIFNlbGVjdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHRoaXMgcHVibGljIG1ldGhvZCByZWNlaXZlcyBzdGFydC9lbmQgZGF0ZXMgaW4gYW55IGZvcm1hdCwgd2l0aCBhbnkgdGltZXpvbmVcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnNlbGVjdCh0aGlzLmJ1aWxkU2VsZWN0Rm9vdHByaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy51bnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhcmd1bWVudHMgdG8gdGhlIHNlbGVjdCBtZXRob2QgaW4gdGhlIEFQSSwgcmV0dXJucyBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBpbmZvKVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkU2VsZWN0Rm9vdHByaW50ID0gZnVuY3Rpb24gKHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubW9tZW50KHpvbmVkU3RhcnRJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudCh6b25lZEVuZElucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCAhc3RhcnQuaGFzVGltZSgpKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluaXRNb21lbnRJbnRlcm5hbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbicpKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24nKSk7XHJcbiAgICAgICAgLy8gQ2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgd2hlbiBhbnkgb2YgdGhlIG9wdGlvbnMgY2hhbmdlLlxyXG4gICAgICAgIC8vIEhhcHBlbnMgYmVmb3JlIGFueSBpbnRlcm5hbCBvYmplY3RzIHJlYnVpbGQgb3IgcmVyZW5kZXIsIGJlY2F1c2UgdGhpcyBpcyB2ZXJ5IGNvcmUuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYnVpbGRpbmdNb21lbnRMb2NhbGUnLCBbXHJcbiAgICAgICAgICAgICc/bG9jYWxlJywgJz9tb250aE5hbWVzJywgJz9tb250aE5hbWVzU2hvcnQnLCAnP2RheU5hbWVzJywgJz9kYXlOYW1lc1Nob3J0JyxcclxuICAgICAgICAgICAgJz9maXJzdERheScsICc/d2Vla051bWJlckNhbGN1bGF0aW9uJ1xyXG4gICAgICAgIF0sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSBvcHRzLndlZWtOdW1iZXJDYWxjdWxhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RGF5ID0gb3B0cy5maXJzdERheTtcclxuICAgICAgICAgICAgdmFyIF93ZWVrO1xyXG4gICAgICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2lzbycpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdJU08nOyAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG9jYWxlRGF0YSA9IE9iamVjdC5jcmVhdGUoLy8gbWFrZSBhIGNoZWFwIGNvcHlcclxuICAgICAgICAgICAgbG9jYWxlXzEuZ2V0TW9tZW50TG9jYWxlRGF0YShvcHRzLmxvY2FsZSkgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG9wdHMubW9udGhOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzID0gb3B0cy5tb250aE5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm1vbnRoTmFtZXNTaG9ydCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzU2hvcnQgPSBvcHRzLm1vbnRoTmFtZXNTaG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5kYXlOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fd2Vla2RheXMgPSBvcHRzLmRheU5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmRheU5hbWVzU2hvcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWtkYXlzU2hvcnQgPSBvcHRzLmRheU5hbWVzU2hvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0RGF5ID09IG51bGwgJiYgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3REYXkgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERheSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfd2VlayA9IE9iamVjdC5jcmVhdGUobG9jYWxlRGF0YS5fd2Vlayk7IC8vIF93ZWVrOiB7IGRvdzogIyB9XHJcbiAgICAgICAgICAgICAgICBfd2Vlay5kb3cgPSBmaXJzdERheTtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWsgPSBfd2VlaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJyB8fFxyXG4gICAgICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnbG9jYWwnIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPSB3ZWVrTnVtYmVyQ2FsY3VsYXRpb247IC8vIG1vbWVudC1leHQgd2lsbCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJuYWwgY3VycmVudCBkYXRlIG9iamVjdCBhbHJlYWR5IGV4aXN0cywgbW92ZSB0byBuZXcgbG9jYWxlLlxyXG4gICAgICAgICAgICAvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9jYWxpemVNb21lbnQoX3RoaXMuY3VycmVudERhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIG1vbWVudCB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXI6IHRpbWV6b25lIGFuZCBsb2NhbGUuXHJcbiAgICAvLyBBY2NlcHRzIGFueXRoaW5nIHRoZSB2YW5pbGxhIG1vbWVudCgpIGNvbnN0cnVjdG9yIGFjY2VwdHMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9tZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9tO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG1vbWVudCB0byBiZSBsb2NhbCwgYmVjYXVzZSBtb21lbnRFeHQgZG9lc24ndCBndWFyYW50ZWUgaXQuXHJcbiAgICAgICAgICAgIGlmIChtb20uaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtb20ubG9jYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBwcm9jZXNzIGFzIFVUQ1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQucGFyc2Vab25lLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBsZXQgdGhlIGlucHV0IGRlY2lkZSB0aGUgem9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7IC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSB0aGlzLmFwcGx5VGltZXpvbmUobW9tKTsgLy8gbWF5IG9yIG1heSBub3QgYXBwbHkgbG9jYWxlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvVXRjTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIGdpdmVuIG1vbWVudCdzIGxvY2FsZSBzZXR0aW5ncyB0byB0aGUgY3VycmVudCBjYWxlbmRhciBsb2NhbGUgc2V0dGluZ3MuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubG9jYWxpemVNb21lbnQgPSBmdW5jdGlvbiAobW9tKSB7XHJcbiAgICAgICAgbW9tLl9sb2NhbGUgPSB0aGlzLmxvY2FsZURhdGE7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciBvciBub3QgdGhlIGNhbGVuZGFyIGtub3dzIGhvdyB0byBjYWxjdWxhdGVcclxuICAgIC8vIHRoZSB0aW1lem9uZSBvZmZzZXQgb2YgYXJiaXRyYXJ5IGRhdGVzIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldElzQW1iaWdUaW1lem9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdsb2NhbCcgJiYgdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdVVEMnO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLiBIYXMgbm8gZWZmZWN0IG9uIGRhdGVzIHdpdGhvdXQgdGltZXMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYXBwbHlUaW1lem9uZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgaWYgKCFkYXRlLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgem9uZWREYXRlID0gdGhpcy5tb21lbnQoZGF0ZS50b0FycmF5KCkpO1xyXG4gICAgICAgIHZhciB0aW1lQWRqdXN0ID0gZGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSAtIHpvbmVkRGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICB2YXIgYWRqdXN0ZWRab25lZERhdGU7XHJcbiAgICAgICAgLy8gU2FmYXJpIHNvbWV0aW1lcyBoYXMgcHJvYmxlbXMgd2l0aCB0aGlzIGNvZXJzaW9uIHdoZW4gbmVhciBEU1QuIEFkanVzdCBpZiBuZWNlc3NhcnkuIChidWcgIzIzOTYpXHJcbiAgICAgICAgaWYgKHRpbWVBZGp1c3QpIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRab25lZERhdGUgPSB6b25lZERhdGUuY2xvbmUoKS5hZGQodGltZUFkanVzdCk7IC8vIGFkZCBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgaWYgKGRhdGUudGltZSgpLmFzTWlsbGlzZWNvbmRzKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgem9uZWREYXRlID0gYWRqdXN0ZWRab25lZERhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHpvbmVkRGF0ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQXNzdW1lcyB0aGUgZm9vdHByaW50IGlzIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgKi9cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb290cHJpbnRUb0RhdGVQcm9maWxlID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCwgaWdub3JlRW5kKSB7XHJcbiAgICAgICAgaWYgKGlnbm9yZUVuZCA9PT0gdm9pZCAwKSB7IGlnbm9yZUVuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcyk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoIWlnbm9yZUVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmFwcGx5VGltZXpvbmUoZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBtb21lbnQgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvbi5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGFuIG1vbWVudCB3aXRoIGFuIGFtYmlndW91cyB0aW1lem9uZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXROb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMub3B0KCdub3cnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG5vdyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBub3cgPSBub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KG5vdykuc3RyaXBab25lKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUHJvZHVjZXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICAgIC8vIFNpZGUtZWZmZWN0OiBjaGFuZ2VzIHRoZSBsb2NhbGUgb2YgdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmh1bWFuaXplRHVyYXRpb24gPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZHVyYXRpb24ubG9jYWxlKHRoaXMub3B0KCdsb2NhbGUnKSkuaHVtYW5pemUoKTtcclxuICAgIH07XHJcbiAgICAvLyB3aWxsIHJldHVybiBgbnVsbGAgaWYgaW52YWxpZCByYW5nZVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBhcnNlVW56b25lZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5tb21lbnQocmFuZ2VJbnB1dC5zdGFydCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LmVuZCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RhcnQgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQuaXNCZWZvcmUoc3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQtRGF0ZSBVdGlsaXRpZXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzKTtcclxuICAgICAgICB2YXIgcmF3U291cmNlcyA9IHRoaXMub3B0KCdldmVudFNvdXJjZXMnKSB8fCBbXTtcclxuICAgICAgICB2YXIgc2luZ2xlUmF3U291cmNlID0gdGhpcy5vcHQoJ2V2ZW50cycpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIGlmIChzaW5nbGVSYXdTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHNpbmdsZVJhd1NvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci5vbigncmVsZWFzZScsIGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ2V2ZW50c1Jlc2V0JywgZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIHJhd1NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocmF3U291cmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3U291cmNlLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5hZGRTb3VyY2Uoc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcXVlc3RFdmVudHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5yZXF1ZXN0RXZlbnRzKHN0YXJ0LCBlbmQsIHRoaXMub3B0KCd0aW1lem9uZScpLCAhdGhpcy5vcHQoJ2xhenlGZXRjaGluZycpKTtcclxuICAgIH07XHJcbiAgICAvLyBHZXQgYW4gZXZlbnQncyBub3JtYWxpemVkIGVuZCBkYXRlLiBJZiBub3QgcHJlc2VudCwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGRlZmF1bHRzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZnVuY3Rpb24gKGFsbERheSwgem9uZWRTdGFydCkge1xyXG4gICAgICAgIHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgaWYgKGFsbERheSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCkuYWRkKHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBab25lKCk7IC8vIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgdHpvIHNob3VsZCBiZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgfTtcclxuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlldy5mbGFzaCgnZGlzcGxheWluZ0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlZmV0Y2hBbGxTb3VyY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uIChldmVudElucHV0cywgaXNTdGlja3kpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnQoZXZlbnRJbnB1dHNbaV0sIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSA9PT0gdm9pZCAwKSB7IGlzU3RpY2t5ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIGV2ZW50SW5wdXQuc291cmNlIHx8IGV2ZW50TWFuYWdlci5zdGlja3lTb3VyY2UpO1xyXG4gICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoZXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZE1hcCA9IHt9O1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlQWxsRXZlbnREZWZzKCk7IC8vIHBlcnNpc3Q9dHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGVnYWN5SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlZ2FjeUluc3RhbmNlcyA9IGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUluc3RhbmNlcywgbGVnYWN5UXVlcnkpO1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHVuaXF1ZSBJRHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlZ2FjeUluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWYgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudERlZkJ5VWlkKGxlZ2FjeUluc3RhbmNlc1tpXS5faWQpO1xyXG4gICAgICAgICAgICAgICAgaWRNYXBbZXZlbnREZWYuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBpZE1hcCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZUV2ZW50RGVmc0J5SWQoaSk7IC8vIHBlcnNpc3Q9dHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGxlZ2FjeVF1ZXJ5IG9wZXJhdGVzIG9uIGxlZ2FjeSBldmVudCBpbnN0YW5jZSBvYmplY3RzXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2xpZW50RXZlbnRzID0gZnVuY3Rpb24gKGxlZ2FjeVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5RXZlbnRJbnN0YW5jZXMsIGxlZ2FjeVF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50UHJvcHNBcnJheSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRQcm9wc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXZlbnQoZXZlbnRQcm9wc0FycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVFdmVudCA9IGZ1bmN0aW9uIChldmVudFByb3BzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnREZWZCeVVpZChldmVudFByb3BzLl9pZCk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmIGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UgPSBldmVudERlZi5idWlsZEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdC5jcmVhdGVGcm9tUmF3UHJvcHMoZXZlbnRJbnN0YW5jZSwgZXZlbnRQcm9wcywgLy8gcmF3IHByb3BzXHJcbiAgICAgICAgICAgIG51bGwgLy8gbGFyZ2VVbml0IC0tIHdobyB1c2VzIGl0P1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnREZWYuaWQsIGV2ZW50RGVmTXV0YXRpb24pOyAvLyB3aWxsIHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUHVibGljIEV2ZW50IFNvdXJjZXMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLm90aGVyU291cmNlcy5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuZ2V0U291cmNlQnlJZChFdmVudFNvdXJjZV8xLmRlZmF1bHQubm9ybWFsaXplSWQoaWQpKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKHNvdXJjZUlucHV0LCB0aGlzKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZU11bHRpUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNvdXJjZU11bHRpUXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5yZW1vdmVBbGxTb3VyY2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLm11bHRpUXVlcnlTb3VyY2VzKHNvdXJjZU11bHRpUXVlcnkpO1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcyA9IGV2ZW50TWFuYWdlci5xdWVyeVNvdXJjZXMoc291cmNlUXVlcnkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWZldGNoRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZU11bHRpUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBldmVudE1hbmFnZXIubXVsdGlRdWVyeVNvdXJjZXMoc291cmNlTXVsdGlRdWVyeSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZWZldGNoU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIC8vIG5vdCBmb3IgaW50ZXJuYWwgdXNlLiB1c2Ugb3B0aW9ucyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cclxuICAgIENhbGVuZGFyLmRlZmF1bHRzID0gb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzO1xyXG4gICAgQ2FsZW5kYXIuZW5nbGlzaERlZmF1bHRzID0gb3B0aW9uc18xLmVuZ2xpc2hEZWZhdWx0cztcclxuICAgIENhbGVuZGFyLnJ0bERlZmF1bHRzID0gb3B0aW9uc18xLnJ0bERlZmF1bHRzO1xyXG4gICAgcmV0dXJuIENhbGVuZGFyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDYWxlbmRhcjtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKENhbGVuZGFyKTtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhDYWxlbmRhcik7XHJcbmZ1bmN0aW9uIGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUV2ZW50SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSkge1xyXG4gICAgaWYgKGxlZ2FjeVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24obGVnYWN5UXVlcnkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLmZpbHRlcihsZWdhY3lRdWVyeSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZWdhY3lRdWVyeSArPSAnJzsgLy8gbm9ybWFsaXplIHRvIHN0cmluZ1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGxlZ2FjeUV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgLy8gc29mdCBjb21wYXJpc29uIGJlY2F1c2UgaWQgbm90IGJlIG5vcm1hbGl6ZWQgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZS5pZCA9PSBsZWdhY3lRdWVyeSB8fFxyXG4gICAgICAgICAgICAgICAgbGVnYWN5RXZlbnRJbnN0YW5jZS5faWQgPT09IGxlZ2FjeVF1ZXJ5OyAvLyBjYW4gc3BlY2lmeSBpbnRlcm5hbCBpZCwgYnV0IG11c3QgZXhhY3RseSBtYXRjaFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IoX3ZpZXcpIHtcclxuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XHJcbiAgICB9XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnRyaW1IaWRkZW5EYXlzKHVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLm1zVG9VdGNNb21lbnQgPSBmdW5jdGlvbiAobXMsIGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuY2FsZW5kYXIubXNUb1V0Y01vbWVudChtcywgZm9yY2VBbGxEYXkpO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHByZXZEYXRlID0gY3VycmVudERhdGVQcm9maWxlLmRhdGUuY2xvbmUoKVxyXG4gICAgICAgICAgICAuc3RhcnRPZihjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdClcclxuICAgICAgICAgICAgLnN1YnRyYWN0KGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgbmV4dERhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuYWRkKGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXHJcbiAgICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQgPT09IHZvaWQgMCkgeyBmb3JjZVRvVmFsaWQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpc0RhdGVBbGxEYXkgPSAhZGF0ZS5oYXNUaW1lKCk7XHJcbiAgICAgICAgdmFyIHZhbGlkVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBtaW5UaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgbWF4VGltZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xyXG4gICAgICAgIHZhciBpc1JhbmdlQWxsRGF5O1xyXG4gICAgICAgIHZhciByZW5kZXJVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgaXNWYWxpZDtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XHJcbiAgICAgICAgdmFsaWRVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQodmFsaWRVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gcmVuZGVyVW56b25lZFJhbmdlLmNsb25lKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdCgnc2hvd05vbkN1cnJlbnREYXRlcycpKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QoY3VycmVudEluZm8udW56b25lZFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnbWluVGltZScpKTtcclxuICAgICAgICBtYXhUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtYXhUaW1lJykpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlVW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSBhY3RpdmVVbnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHZhbGlkVW56b25lZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcclxuICAgICAgICBpZiAoYWN0aXZlVW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQoYWN0aXZlVW56b25lZFJhbmdlLmNvbnN0cmFpbkRhdGUoZGF0ZSksIC8vIHJldHVybnMgTVNcclxuICAgICAgICAgICAgaXNEYXRlQWxsRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXHJcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXHJcbiAgICAgICAgaXNWYWxpZCA9IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZS5pbnRlcnNlY3RzV2l0aCh2YWxpZFVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cclxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICB2YWxpZFVuem9uZWRSYW5nZTogdmFsaWRVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXHJcbiAgICAgICAgICAgIGN1cnJlbnRVbnpvbmVkUmFuZ2U6IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxyXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxyXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xyXG4gICAgICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2U6IGFjdGl2ZVVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cclxuICAgICAgICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXHJcbiAgICAgICAgICAgIHJlbmRlclVuem9uZWRSYW5nZTogcmVuZGVyVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxyXG4gICAgICAgICAgICBtaW5UaW1lOiBtaW5UaW1lLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBleGNsdXNpdmUgdmlzaWJsZSBlbmQgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1heFRpbWU6IG1heFRpbWUsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXHJcbiAgICAgICAgICAgIC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxyXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcclxuICAgICAgICAgICAgLy8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXHJcbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxyXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFZhbGlkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2YWxpZFJhbmdlJywgdGhpcy5fdmlldy5jYWxlbmRhci5nZXROb3coKSkgfHxcclxuICAgICAgICAgICAgbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoKTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXHJcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxyXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1cnJlbnRSYW5nZUluZm8gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gdGhpcy5fdmlldy52aWV3U3BlYztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gbnVsbDtcclxuICAgICAgICB2YXIgZGF5Q291bnQ7XHJcbiAgICAgICAgaWYgKHZpZXdTcGVjLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdmlld1NwZWMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHVuaXQgPSB2aWV3U3BlYy5kdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5vcHQoJ2RheUNvdW50JykpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodW56b25lZFJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KHVuem9uZWRSYW5nZS5nZXRTdGFydCgpLCB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHVuem9uZWRSYW5nZTogdW56b25lZFJhbmdlIH07XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVVbnpvbmVkUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxyXG4gICAgLy8gbWluVGltZSBvciBtYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBlbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcudXNlc01pbk1heFRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKG1pblRpbWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApLmFkZChtaW5UaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4VGltZSA+IDI0ICogNjAgKiA2MCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKG1heFRpbWUgLSAoMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxyXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGNvbXB1dGVHcmVhdGVzdFVuaXQgdmFsdWUgb2YgZHVyYXRpb24uXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xyXG4gICAgICAgIHZhciBhbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpO1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQ7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxyXG4gICAgICAgIGlmICghYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50RHVyYXRpb24gPCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZGF0ZUluY3JlbWVudER1cmF0aW9uLCBkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcclxuICAgICAgICBpZiAoZHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWV3LmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBkYXRlLmNsb25lKCkuc3RhcnRPZihhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZChkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJlcyA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXHJcbiAgICAgICAgaWYgKCF0aGlzLnRyaW1IaWRkZW5EYXlzKHJlcykpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EYXlDb3VudCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XHJcbiAgICAgICAgdmFyIGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XHJcbiAgICAgICAgdmFyIHJ1bm5pbmdDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKGN1c3RvbUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICBzdGFydC5zdGFydE9mKGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZW5kLmFkZCgxLCAnZGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmlldy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcclxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFVuem9uZWRSYW5nZSBhbmQgYWN0aXZlVW56b25lZFJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZVVuem9uZWRSYW5nZSA9IHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2aXNpYmxlUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoZGF0ZSkgLy8gY29ycmVjdCB6b25lLiBhbHNvIGdlbmVyYXRlcyBuZXcgb2JqIHRoYXQgYXZvaWRzIG11dGF0aW9uc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHZpc2libGVVbnpvbmVkUmFuZ2UgJiYgKHZpc2libGVVbnpvbmVkUmFuZ2Uuc3RhcnRNcyA9PSBudWxsIHx8IHZpc2libGVVbnpvbmVkUmFuZ2UuZW5kTXMgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlVW56b25lZFJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcclxuICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cclxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXHJcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRGF0ZUluY3JlbWVudCA9IGZ1bmN0aW9uIChmYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xyXG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXh0ZXJuYWxEcm9wcGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV4dGVybmFsRHJvcHBpbmcoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlOyAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGVtZW50czpcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgIC0gaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgIC0gcmVuZGVyRHJhZ1xyXG4gICAgICAtIHVucmVuZGVyRHJhZ1xyXG4gICAgKi9cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuYmluZFRvRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBzb3J0c3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0IC8vIGpxdWlcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS51bmJpbmRGcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgaXMgaW5pdGlhdGVkIGFueXdoZXJlIGluIHRoZSBET01cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldiwgdWkpIHtcclxuICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgdmFyIGFjY2VwdDtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ2Ryb3BwYWJsZScpKSB7XHJcbiAgICAgICAgICAgIGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXHJcbiAgICAgICAgICAgIGFjY2VwdCA9IHRoaXMub3B0KCdkcm9wQWNjZXB0Jyk7XHJcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG9FeHRlcm5hbERyYWcoZWwsIGV2LCB1aSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBzdGFydHMgYW5kIGl0IG5lZWRzIHRvIGJlIG1vbml0b3JlZCBmb3IgZHJvcHBpbmdcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmxpc3RlblRvRXh0ZXJuYWxEcmFnID0gZnVuY3Rpb24gKGVsLCBldiwgdWkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbWV0YSA9IGdldERyYWdnZWRFbE1ldGEoZWwpOyAvLyBleHRyYSBkYXRhIGFib3V0IGV2ZW50IGRyb3AsIGluY2x1ZGluZyBwb3NzaWJsZSBldmVudCB0byBjcmVhdGVcclxuICAgICAgICB2YXIgc2luZ2xlRXZlbnREZWY7IC8vIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIHVuc3VjY2Vzc2Z1bCBkcmFnXHJcbiAgICAgICAgLy8gbGlzdGVuZXIgdGhhdCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciBkYXRlLWFzc29jaWF0ZWQgcGl4ZWwgcmVnaW9uc1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50ID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7IC8vIGhpdCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBfdGhpcy5jb21wdXRlRXh0ZXJuYWxEcm9wKGhpdEZvb3RwcmludCwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdChzaW5nbGVFdmVudERlZi5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gbWV0YS5ldmVudFByb3BzID8gLy8gaXNFdmVudD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXJEcmFnKC8vIGNhbGxlZCB3aXRob3V0IGEgc2VnIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgdmlldy5jYWxlbmRhcikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7IC8vIHNpZ25hbCB1bnN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVucmVuZGVyRHJhZygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV4dGVybmFsRHJvcChzaW5nbGVFdmVudERlZiwgQm9vbGVhbihtZXRhLmV2ZW50UHJvcHMpLCAvLyBpc0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihtZXRhLnN0aWNrKSwgLy8gaXNTdGlja3lcclxuICAgICAgICAgICAgICAgICAgICBlbCwgZXYsIHVpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBoaXQgdG8gYmUgZHJvcHBlZCB1cG9uLCBhbmQgbWlzYyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUganF1aSBkcmFnIChndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0KSxcclxuICAgIC8vIHJldHVybnMgdGhlIHpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBmb3IgdGhlIGV2ZW50IHRoYXQgd291bGQgcmVzdWx0IGZyb20gdGhlIGh5cG90aGV0aWNhbCBkcm9wLiBlbmQgbWlnaHQgYmUgbnVsbC5cclxuICAgIC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuY29tcHV0ZUV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIG1ldGEpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICAvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcclxuICAgICAgICAgICAgaWYgKG1ldGEuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRhLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKG1ldGEuZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudERlZiA9IFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZSgkLmV4dGVuZCh7fSwgbWV0YS5ldmVudFByb3BzLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KSwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHJldHVybiBldmVudERlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXh0ZXJuYWxEcm9wcGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXh0ZXJuYWxEcm9wcGluZztcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFeHRlcm5hbERyb3BwaW5nKTtcclxuLyogRXh0ZXJuYWwtRHJhZ2dpbmctRWxlbWVudCBEYXRhXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXF1aXJlIGFsbCBIVE1MNSBkYXRhLSogYXR0cmlidXRlcyB1c2VkIGJ5IEZ1bGxDYWxlbmRhciB0byBoYXZlIHRoaXMgcHJlZml4LlxyXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxyXG5leHBvcnRIb29rcy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4vLyBHaXZlbiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgbWlnaHQgcmVwcmVzZW50IGEgZHJhZ2dlZCBGdWxsQ2FsZW5kYXIgZXZlbnQsIHJldHVybnMgYW4gaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlXHJcbi8vIHRvIGJlIHVzZWQgZm9yIEV2ZW50IE9iamVjdCBjcmVhdGlvbi5cclxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbmZ1bmN0aW9uIGdldERyYWdnZWRFbE1ldGEoZWwpIHtcclxuICAgIHZhciBwcmVmaXggPSBleHBvcnRIb29rcy5kYXRhQXR0clByZWZpeDtcclxuICAgIHZhciBldmVudFByb3BzOyAvLyBwcm9wZXJ0aWVzIGZvciBjcmVhdGluZyB0aGUgZXZlbnQsIG5vdCByZWxhdGVkIHRvIGRhdGUvdGltZVxyXG4gICAgdmFyIHN0YXJ0VGltZTsgLy8gYSBEdXJhdGlvblxyXG4gICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgdmFyIHN0aWNrO1xyXG4gICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgIHByZWZpeCArPSAnLSc7XHJcbiAgICB9XHJcbiAgICBldmVudFByb3BzID0gZWwuZGF0YShwcmVmaXggKyAnZXZlbnQnKSB8fCBudWxsO1xyXG4gICAgaWYgKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudFByb3BzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBsdWNrIHNwZWNpYWwtY2FzZWQgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgICAgICBkdXJhdGlvbiA9IGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgc3RpY2sgPSBldmVudFByb3BzLnN0aWNrO1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICB9XHJcbiAgICAvLyBmYWxsYmFjayB0byBzdGFuZGFsb25lIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGRhdGUvdGltZSBwcm9wZXJ0aWVzXHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICdzdGFydCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gZWwuZGF0YShwcmVmaXggKyAndGltZScpO1xyXG4gICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0aWNrID09IG51bGwpIHtcclxuICAgICAgICBzdGljayA9IGVsLmRhdGEocHJlZml4ICsgJ3N0aWNrJyk7XHJcbiAgICB9XHJcbiAgICAvLyBtYXNzYWdlIGludG8gY29ycmVjdCBkYXRhIHR5cGVzXHJcbiAgICBzdGFydFRpbWUgPSBzdGFydFRpbWUgIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihzdGFydFRpbWUpIDogbnVsbDtcclxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xyXG4gICAgc3RpY2sgPSBCb29sZWFuKHN0aWNrKTtcclxuICAgIHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50UmVzaXppbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFJlc2l6aW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBlbWVudHM6XHJcbiAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAgIC0gZGlmZkRhdGVzXHJcbiAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudFJlc2l6aW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyIGFzIHRoZXkgcmVzaXplIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKHNlZywgaXNTdGFydCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IGNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZWwgPSBzZWcuZWw7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgaXNEcmFnZ2luZztcclxuICAgICAgICB2YXIgcmVzaXplTXV0YXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllcy4gZmFsc3kgaWYgaW52YWxpZCByZXNpemVcclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKmdyaWQncyogY29vcmRpbmF0ZSBtYXBcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBzdWJqZWN0RWw6IGVsLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0YXJ0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdIaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IGlzU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRTdGFydFJlc2l6ZU11dGF0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCwgc2VnLmZvb3RwcmludCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRFbmRSZXNpemVNdXRhdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQsIHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgcmVzaXplTXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzaXplTXV0YXRpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlLiAoRllJLCBldmVudCBkYXRlcyBtaWdodCBoYXZlIHpvbmVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbmRlckV2ZW50UmVzaXplKGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgY2FsZW5kYXIpKSwgc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJFdmVudFJlc2l6ZShzZWcpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5zaG93RXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0b3Aoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHJlLXNob3cgb3JpZ2luYWwsIHdpbGwgcmVyZW5kZXIgYWxsIGFueXdheXMuIGVzcCBpbXBvcnRhbnQgaWYgZXZlbnRSZW5kZXJXYWl0XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZXBvcnRFdmVudFJlc2l6ZShldmVudEluc3RhbmNlLCByZXNpemVNdXRhdGlvbiwgZWwsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdGFydHNcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnNlZ1Jlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdG9wc1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuc2VnUmVzaXplU3RvcCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBuZXcgZGF0ZS1pbmZvcm1hdGlvbiBmb3IgYW4gZXZlbnQgc2VnbWVudCBiZWluZyByZXNpemVkIGZyb20gaXRzIHN0YXJ0XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnRTdGFydFJlc2l6ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIG9yaWdFdmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBvcmlnRXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgc3RhcnREZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCksIHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChvcmlnUmFuZ2UuZ2V0U3RhcnQoKS5hZGQoc3RhcnREZWx0YSkgPCBvcmlnUmFuZ2UuZ2V0RW5kKCkpIHtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24uc2V0U3RhcnREZWx0YShzdGFydERlbHRhKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbihkYXRlTXV0YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBlbmRcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudEVuZFJlc2l6ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIG9yaWdFdmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBvcmlnRXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgZW5kRGVsdGEgPSB0aGlzLmNvbXBvbmVudC5kaWZmRGF0ZXMoZW5kRm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRFbmQoKSwgc3RhcnRGb290cHJpbnQudW56b25lZFJhbmdlLmdldEVuZCgpKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChvcmlnUmFuZ2UuZ2V0RW5kKCkuYWRkKGVuZERlbHRhKSA+IG9yaWdSYW5nZS5nZXRTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uLnNldEVuZERlbHRhKGVuZERlbHRhKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbihkYXRlTXV0YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFJlc2l6aW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJlc2l6aW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbnZhciBEcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIE1vdXNlRm9sbG93ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ0KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudERyYWdnaW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBsZW1lbnRzOlxyXG4gICAgICAtIGJpbmRTZWdIYW5kbGVyVG9FbFxyXG4gICAgICAtIHB1YmxpY2x5VHJpZ2dlclxyXG4gICAgICAtIGRpZmZEYXRlc1xyXG4gICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgLSBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudERyYWdnaW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25EZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdCgnZXZlbnRMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY2FuU3RhcnREcmFnKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnKS5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBkZWxheTogdGhpcy52aWV3LmlzRXZlbnREZWZTZWxlY3RlZChzZWcuZm9vdHByaW50LmV2ZW50RGVmKSA/IC8vIGFscmVhZHkgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAwIDogdGhpcy5nZXRTZWxlY3Rpb25EZWxheSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50LmNhblN0YXJ0RHJhZyhzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQuY2FuU3RhcnRTZWxlY3Rpb24oc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFNlbGVjdExpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBzZWcgaXNuJ3QgZHJhZ2dhYmxlLCBidXQgbGV0J3MgdXNlIGEgZ2VuZXJpYyBEcmFnTGlzdGVuZXJcclxuICAgIC8vIHNpbXBseSBmb3IgdGhlIGRlbGF5LCBzbyBpdCBjYW4gYmUgc2VsZWN0ZWQuXHJcbiAgICAvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYGRyYWdMaXN0ZW5lcmBcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkU2VsZWN0TGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB0cmFjayB1c2VyLWRyYWdnaW5nIG9uIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgZHJhZ0xpc3RlbmVyYFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBlbCA9IHNlZy5lbDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmc7XHJcbiAgICAgICAgdmFyIG1vdXNlRm9sbG93ZXI7IC8vIEEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCB3aWxsIG1vdmUgd2l0aCB0aGUgbW91c2VcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKnZpZXcncyogY29vcmRpbmF0ZSBtYXAuIEFsbG93cyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgYmV0d2VlbiBzdWJjb21wb25lbnRzXHJcbiAgICAgICAgLy8gb2YgdGhlIHZpZXcuXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQodmlldywge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIHN1YmplY3RFbDogZWwsXHJcbiAgICAgICAgICAgIHN1YmplY3RDZW50ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgc2VnLmNvbXBvbmVudCA9IGNvbXBvbmVudDsgLy8gZm9yIHJlbmRlckRyYWdcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIgPSBuZXcgTW91c2VGb2xsb3dlcl8xLmRlZmF1bHQoc2VnLmVsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsOiB2aWV3LmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IF90aGlzLm9wdCgnZHJhZ09wYWNpdHknKSxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnREdXJhdGlvbjogX3RoaXMub3B0KCdkcmFnUmV2ZXJ0RHVyYXRpb24nKSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDIgLy8gb25lIGFib3ZlIHRoZSAuZmMtdmlld1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLmhpZGUoKTsgLy8gZG9uJ3Qgc2hvdyB1bnRpbCB3ZSBrbm93IHRoaXMgaXMgYSByZWFsIGRyYWdcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdGFydChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnRm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgaGl0IGNvdWxkIGJlIGZvcmNlZCAoRGF5R3JpZC5saW1pdClcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0hpdCA9IHNlZy5oaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWQsIHNvIHF1ZXJ5IG9yaWdpbiBncmlkXHJcbiAgICAgICAgICAgICAgICBvcmlnRm9vdHByaW50ID0gb3JpZ0hpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIGZvb3RwcmludCA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdGb290cHJpbnQgJiYgZm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IF90aGlzLmNvbXB1dGVFdmVudERyb3BNdXRhdGlvbihvcmlnRm9vdHByaW50LCBmb290cHJpbnQsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgZXZlbnREZWZNdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdmFsaWQgZHJvcCBsb2NhdGlvbiwgaGF2ZSB0aGUgc3ViY2xhc3MgcmVuZGVyIGEgdmlzdWFsIGluZGljYXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJEcmFnKC8vIHRydXRoeSBpZiByZW5kZXJlZCBzb21ldGhpbmdcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIGNhbGVuZGFyKSksIHNlZywgZHJhZ0xpc3RlbmVyLmlzVG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGlmIHRoZSBzdWJjbGFzcyBpcyBhbHJlYWR5IHVzaW5nIGEgbW9jayBldmVudCBcImhlbHBlclwiLCBoaWRlIG91ciBvd25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBvdGhlcndpc2UsIGhhdmUgdGhlIGhlbHBlciBmb2xsb3cgdGhlIG1vdXNlIChubyBzbmFwcGluZylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBoYXZlIG1vdmVkIGhpdHMgdG8gYmUgYSB2YWxpZCBkcm9wXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckRyYWcoc2VnKTsgLy8gdW5yZW5kZXIgd2hhdGV2ZXIgd2FzIGRvbmUgaW4gcmVuZGVyRHJhZ1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zaG93KCk7IC8vIHNob3cgaW4gY2FzZSB3ZSBhcmUgbW92aW5nIG91dCBvZiBhbGwgaGl0c1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlZy5jb21wb25lbnQ7IC8vIHByZXZlbnQgc2lkZSBlZmZlY3RzXHJcbiAgICAgICAgICAgICAgICAvLyBkbyByZXZlcnQgYW5pbWF0aW9uIGlmIGhhc24ndCBjaGFuZ2VkLiBjYWxscyBhIGNhbGxiYWNrIHdoZW4gZmluaXNoZWQgKHdoZXRoZXIgYW5pbWF0aW9uIG9yIG5vdClcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RvcCghZXZlbnREZWZNdXRhdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJEcmFnKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdG9wKHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNob3dFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV2ZW50RHJvcChldmVudEluc3RhbmNlLCBldmVudERlZk11dGF0aW9uLCBlbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0YXJ0c1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuc2VnRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnNlZ0RyYWdTdG9wID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREcm9wTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKHRoaXMuY29tcHV0ZUV2ZW50RGF0ZU11dGF0aW9uKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQpKTtcclxuICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREYXRlTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBkYXRlMCA9IHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBkYXRlMSA9IGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkYXRlRGVsdGE7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICBpZiAoc3RhcnRGb290cHJpbnQuaXNBbGxEYXkgIT09IGVuZEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBjbGVhckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChlbmRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlQWxsRGF5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRhdGUwLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VUaW1lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZURlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGRhdGUxLCBkYXRlMCk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5jbGVhckVuZCA9IGNsZWFyRW5kO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBkYXRlTXV0YXRpb24uZm9yY2VBbGxEYXkgPSBmb3JjZUFsbERheTtcclxuICAgICAgICBkYXRlTXV0YXRpb24uc2V0RGF0ZURlbHRhKGRhdGVEZWx0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREcmFnZ2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREcmFnZ2luZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRGF0ZVNlbGVjdGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVTZWxlY3RpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAtIGJpbmREYXRlSGFuZGxlclRvRWxcclxuICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgIC0gcmVuZGVySGlnaGxpZ2h0XHJcbiAgICAgIC0gdW5yZW5kZXJIaWdobGlnaHRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRlU2VsZWN0aW5nKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBfdGhpcy5idWlsZERyYWdMaXN0ZW5lcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmdldERlbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0KCdzZWxlY3RMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH07XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCdzZWxlY3RhYmxlJykgJiYgIWNvbXBvbmVudC5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBfdGhpcy5vcHQoJ3NlbGVjdE1pbkRpc3RhbmNlJylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3NlbGVjdGFibGUnKSAmJiAhY29tcG9uZW50LnNob3VsZElnbm9yZVRvdWNoKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IF90aGlzLmdldERlbGF5KClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXRpbF8xLnByZXZlbnRTZWxlY3Rpb24oZWwpO1xyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlcidzIGRyYWcgYWNyb3NzIGRheSBlbGVtZW50cywgZm9yIGRheSBzZWxlY3RpbmcuXHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgc2VsZWN0aW9uRm9vdHByaW50OyAvLyBudWxsIGlmIGludmFsaWQgc2VsZWN0aW9uXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnVuc2VsZWN0KGV2KTsgLy8gc2luY2Ugd2UgY291bGQgYmUgcmVuZGVyaW5nIGEgbmV3IHNlbGVjdGlvbiwgd2Ugd2FudCB0byBjbGVhciBhbnkgb2xkIG9uZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnSGl0Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0hpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KG9yaWdIaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdIaXRGb290cHJpbnQgJiYgaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IF90aGlzLmNvbXB1dGVTZWxlY3Rpb24ob3JpZ0hpdEZvb3RwcmludCwgaGl0Rm9vdHByaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Gb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChzZWxlY3Rpb25Gb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25Gb290cHJpbnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudW5yZW5kZXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCAmJiBzZWxlY3Rpb25Gb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gcmVuZGVyZWQuIGp1c3QgcmVwb3J0IGl0XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5yZXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uRm9vdHByaW50LCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHRoZSBmaXJzdCBhbmQgbGFzdCBkYXRlLXNwYW5zIG9mIGEgc2VsZWN0aW9uLCByZXR1cm5zIGFub3RoZXIgZGF0ZS1zcGFuIG9iamVjdC5cclxuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIGFuZCBwcm92aWRlIGFkZGl0aW9uYWwgZGF0YSBpbiB0aGUgc3BhbiBvYmplY3QuIFdpbGwgYmUgcGFzc2VkIHRvIHJlbmRlclNlbGVjdGlvbkZvb3RwcmludCgpLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIHNlbGVjdGlvbiBpcyBpbnZhbGlkIGFuZCB0aGlzIHNob3VsZCBiZSBpbmRpY2F0ZWQgdG8gdGhlIHVzZXIuXHJcbiAgICAvLyBXaWxsIHJldHVybiBudWxsL3VuZGVmaW5lZCBpZiBhIHNlbGVjdGlvbiBpbnZhbGlkIGJ1dCBubyBlcnJvciBzaG91bGQgYmUgcmVwb3J0ZWQuXHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5jb21wdXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICB2YXIgd2hvbGVGb290cHJpbnQgPSB0aGlzLmNvbXB1dGVTZWxlY3Rpb25Gb290cHJpbnQoZm9vdHByaW50MCwgZm9vdHByaW50MSk7XHJcbiAgICAgICAgaWYgKHdob2xlRm9vdHByaW50ICYmICF0aGlzLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZCh3aG9sZUZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2hvbGVGb290cHJpbnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdHdvIHNwYW5zLCBtdXN0IHJldHVybiB0aGUgY29tYmluYXRpb24gb2YgdGhlIHR3by5cclxuICAgIC8vIFRPRE86IGRvIHRoaXMgc2VwYXJhdGlvbiBvZiBjb25jZXJucyAoY29tYmluaW5nIFZTIHZhbGlkYXRpb24pIGZvciBldmVudCBkbmQvcmVzaXplIHRvby5cclxuICAgIC8vIEFzc3VtZXMgYm90aCBmb290cHJpbnRzIGFyZSBub24tb3Blbi1lbmRlZC5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmNvbXB1dGVTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHZhciBtcyA9IFtcclxuICAgICAgICAgICAgZm9vdHByaW50MC51bnpvbmVkUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgIGZvb3RwcmludDEudW56b25lZFJhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgIGZvb3RwcmludDEudW56b25lZFJhbmdlLmVuZE1zXHJcbiAgICAgICAgXTtcclxuICAgICAgICBtcy5zb3J0KHV0aWxfMS5jb21wYXJlTnVtYmVycyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KG1zWzBdLCBtc1szXSksIGZvb3RwcmludDAuaXNBbGxEYXkpO1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVTZWxlY3Rpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVTZWxlY3Rpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxudmFyIEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcclxudmFyIGFnZW5kYVRpbWVHcmlkTWV0aG9kcztcclxudmFyIGFnZW5kYURheUdyaWRNZXRob2RzO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIGFnZW5kYS1yZWxhdGVkIHZpZXdzLiBEaXNwbGF5cyBvbmUgbW9yZSBjb2x1bW5zIHdpdGggdGltZSBzbG90cyBydW5uaW5nIHZlcnRpY2FsbHkuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJcyBhIG1hbmFnZXIgZm9yIHRoZSBUaW1lR3JpZCBzdWJjb21wb25lbnQgYW5kIHBvc3NpYmx5IHRoZSBEYXlHcmlkIHN1YmNvbXBvbmVudCAoaWYgYWxsRGF5U2xvdCBpcyBvbikuXHJcbi8vIFJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXHJcbnZhciBBZ2VuZGFWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWdlbmRhVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFnZW5kYVZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIsIHZpZXdTcGVjKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVzZXNNaW5NYXhUaW1lID0gdHJ1ZTsgLy8gaW5kaWNhdGVzIHRoYXQgbWluVGltZS9tYXhUaW1lIGFmZmVjdHMgcmVuZGVyaW5nXHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZVRpbWVHcmlkKCk7XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMudGltZUdyaWQpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ2FsbERheVNsb3QnKSkge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7IC8vIHRoZSBhbGwtZGF5IHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcclxuICAgICAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBUaW1lR3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMudGltZUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVUaW1lR3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWQgPSBuZXcgdGhpcy50aW1lR3JpZENsYXNzKHRoaXMpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMoYWdlbmRhVGltZUdyaWRNZXRob2RzLCB0aW1lR3JpZCk7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVHcmlkO1xyXG4gICAgfTtcclxuICAgIC8vIEluc3RhbnRpYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG1pZ2h0IG5lZWQuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3NcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF5R3JpZCA9IG5ldyB0aGlzLmRheUdyaWRDbGFzcyh0aGlzKTtcclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKGFnZW5kYURheUdyaWRNZXRob2RzLCBkYXlHcmlkKTtcclxuICAgICAgICByZXR1cm4gZGF5R3JpZDtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWRXcmFwRWw7XHJcbiAgICAgICAgdmFyIHRpbWVHcmlkRWw7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtYWdlbmRhLXZpZXcnKS5odG1sKHRoaXMucmVuZGVyU2tlbGV0b25IdG1sKCkpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGltZUdyaWRXcmFwRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy10aW1lLWdyaWQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGltZUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy10aW1lLWdyaWRcIiAvPicpLmFwcGVuZFRvKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZCh0aW1lR3JpZFdyYXBFbCk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5oZWFkQ29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQuc2V0RWxlbWVudCh0aW1lR3JpZEVsKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KHRoaXMuZWwuZmluZCgnLmZjLWRheS1ncmlkJykpO1xyXG4gICAgICAgICAgICAvLyBoYXZlIHRoZSBkYXktZ3JpZCBleHRlbmQgaXQncyBjb29yZGluYXRlIGFyZWEgb3ZlciB0aGUgPGhyPiBkaXZpZGluZyB0aGUgdHdvIGdyaWRzXHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSB0aGlzLmRheUdyaWQuZWwubmV4dCgnaHInKS5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgIC8vIFRoZSBkYXktZ3JpZCBhbmQgdGltZS1ncmlkIGNvbXBvbmVudHMgd2lsbCByZW5kZXIgaW5zaWRlIGNvbnRhaW5lcnMgZGVmaW5lZCBieSB0aGlzIEhUTUwuXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbkh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAnPC90Ym9keT4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgYXhpcywgaWYgaXQgaXMga25vd25cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmF4aXNTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXhpc1dpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLmF4aXNXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVHcmlkLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0O1xyXG4gICAgICAgIHZhciBzY3JvbGxlckhlaWdodDtcclxuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGhzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICAvLyBtYWtlIGFsbCBheGlzIGNlbGxzIGxpbmUgdXAsIGFuZCByZWNvcmQgdGhlIHdpZHRoIHNvIG5ld2x5IGNyZWF0ZWQgYXhpcyBjZWxscyB3aWxsIGhhdmUgaXRcclxuICAgICAgICB0aGlzLmF4aXNXaWR0aCA9IHV0aWxfMS5tYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtYXhpcycpKTtcclxuICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gdGltZUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyB0aW1lR3JpZC5cclxuICAgICAgICBpZiAoIXRoaXMudGltZUdyaWQuY29sRWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50cyB0aGF0IG11c3QgY29tcGVuc2F0ZSB3aGVuIHNjcm9sbGVyIGhhcyBzY3JvbGxiYXJzXHJcbiAgICAgICAgdmFyIG5vU2Nyb2xsUm93RWxzID0gdGhpcy5lbC5maW5kKCcuZmMtcm93Om5vdCguZmMtc2Nyb2xsZXIgKiknKTtcclxuICAgICAgICAvLyByZXNldCBhbGwgZGltZW5zaW9ucyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLmhpZGUoKTsgLy8gLnNob3coKSB3aWxsIGJlIGNhbGxlZCBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwobm9TY3JvbGxSb3dFbHMpO1xyXG4gICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRMaW1pdCA9IEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgYWxsLWRheSBhbmQgaGVhZGVyIHJvd3MgbGluZXMgdXBcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5jb21wZW5zYXRlU2Nyb2xsKG5vU2Nyb2xsUm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRleHQgZmxvdywgd2hpY2ggbWlnaHQgYWZmZWN0IGhlaWdodCwgc28gcmVjYWxjdWxhdGVcclxuICAgICAgICAgICAgICAgIC8vIGFuZCByZWFwcGx5IHRoZSBkZXNpcmVkIGhlaWdodCB0byB0aGUgc2Nyb2xsZXIuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgc3BhY2UgYmVsb3cgdGhlIHNsYXRzLCBzaG93IHRoZSBob3Jpem9udGFsIHJ1bGUuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgd29uJ3QgY2F1c2UgYW55IG5ldyBvdmVyZmxvdywgYmVjYXVzZSBsb2NrT3ZlcmZsb3cgYWxyZWFkeSBjYWxsZWQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVHcmlkLmdldFRvdGFsU2xhdEhlaWdodCgpIDwgc2Nyb2xsZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJIZWlnaHQgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQgLVxyXG4gICAgICAgICAgICB1dGlsXzEuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICB9O1xyXG4gICAgLyogU2Nyb2xsXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGluaXRpYWwgcHJlLWNvbmZpZ3VyZWQgc2Nyb2xsIHN0YXRlIHByaW9yIHRvIGFsbG93aW5nIHRoZSB1c2VyIHRvIGNoYW5nZSBpdFxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY3JvbGxUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdzY3JvbGxUaW1lJykpO1xyXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRpbWVHcmlkLmNvbXB1dGVUaW1lVG9wKHNjcm9sbFRpbWUpO1xyXG4gICAgICAgIC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXHJcbiAgICAgICAgdG9wID0gTWF0aC5jZWlsKHRvcCk7XHJcbiAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgICB0b3ArKzsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHRvcDogdG9wIH07XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKSB9O1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIaXQgQXJlYXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gdGhlIGdyaWRzIChkYXlHcmlkIG1pZ2h0IG5vdCBiZSBkZWZpbmVkKVxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxyXG4gICAgICAgIHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxyXG4gICAgICAgIHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdEVsKGhpdCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50UmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgZGF5RXZlbnRzUGF5bG9hZCA9IHt9O1xyXG4gICAgICAgIHZhciB0aW1lZEV2ZW50c1BheWxvYWQgPSB7fTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAvLyBzZXBhcmF0ZSB0aGUgZXZlbnRzIGludG8gYWxsLWRheSBhbmQgdGltZWRcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRzUGF5bG9hZFtpZF07XHJcbiAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXAuZ2V0RXZlbnREZWYoKS5pc0FsbERheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlFdmVudHNQYXlsb2FkW2lkXSA9IGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpbWVkRXZlbnRzUGF5bG9hZFtpZF0gPSBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5leGVjdXRlRXZlbnRSZW5kZXIodGltZWRFdmVudHNQYXlsb2FkKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5leGVjdXRlRXZlbnRSZW5kZXIoZGF5RXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERyYWdnaW5nL1Jlc2l6aW5nIFJvdXRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB2YXIgcmVuZGVyZWRIZWxwZXIgPSBmYWxzZTtcclxuICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRoaXMudGltZUdyaWQucmVuZGVyRHJhZyhncm91cHMudGltZWQsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGdyb3Vwcy5hbGxEYXksIHNlZywgaXNUb3VjaCkgfHwgcmVuZGVyZWRIZWxwZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZEhlbHBlcjtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBncm91cHMgPSBncm91cEV2ZW50Rm9vdHByaW50c0J5QWxsRGF5KGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5yZW5kZXJFdmVudFJlc2l6ZShncm91cHMudGltZWQsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVuZGVyRXZlbnRSZXNpemUoZ3JvdXBzLmFsbERheSwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFnZW5kYVZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQWdlbmRhVmlldztcclxuQWdlbmRhVmlldy5wcm90b3R5cGUudGltZUdyaWRDbGFzcyA9IFRpbWVHcmlkXzEuZGVmYXVsdDtcclxuQWdlbmRhVmlldy5wcm90b3R5cGUuZGF5R3JpZENsYXNzID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbi8vIFdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyB0aW1lR3JpZFxyXG5hZ2VuZGFUaW1lR3JpZE1ldGhvZHMgPSB7XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICByZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0aGlzLmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgd2Vla1RleHQ7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd3ZWVrTnVtYmVycycpKSB7XHJcbiAgICAgICAgICAgIHdlZWtUZXh0ID0gd2Vla1N0YXJ0LmZvcm1hdCh0aGlzLm9wdCgnc21hbGxXZWVrRm9ybWF0JykpO1xyXG4gICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLWF4aXMgZmMtd2Vlay1udW1iZXIgJyArIGNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA+IDEgfSwgdXRpbF8xLmh0bWxFc2NhcGUod2Vla1RleHQpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHRoIGNsYXNzPVwiZmMtYXhpcyAnICsgY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90aD4nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYmcgb2YgdGhlIFRpbWVHcmlkIHNsb3QgYXJlYS4gTG9uZyB2ZXJ0aWNhbCBjb2x1bW4uXHJcbiAgICByZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgfSxcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgIC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXHJcbiAgICByZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgIH1cclxufTtcclxuLy8gV2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIGRheUdyaWRcclxuYWdlbmRhRGF5R3JpZE1ldGhvZHMgPSB7XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYWxsLWRheSBjZWxsc1xyXG4gICAgcmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgdmlldy5nZXRBbGxEYXlIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgfSxcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgIC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXHJcbiAgICByZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpIHtcclxuICAgIHZhciBhbGxEYXkgPSBbXTtcclxuICAgIHZhciB0aW1lZCA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgYWxsRGF5LnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpbWVkLnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhbGxEYXk6IGFsbERheSwgdGltZWQ6IHRpbWVkIH07XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgVGltZUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Nik7XHJcbnZhciBUaW1lR3JpZEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Nyk7XHJcbnZhciBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDgpO1xyXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBXZSBtaXhpbiBEYXlUYWJsZSwgZXZlbiB0aG91Z2ggdGhlcmUgaXMgb25seSBhIHNpbmdsZSByb3cgb2YgZGF5c1xyXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxyXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcclxudmFyIEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TID0gW1xyXG4gICAgeyBob3VyczogMSB9LFxyXG4gICAgeyBtaW51dGVzOiAzMCB9LFxyXG4gICAgeyBtaW51dGVzOiAxNSB9LFxyXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxyXG4gICAgeyBzZWNvbmRzOiAxNSB9XHJcbl07XHJcbnZhciBUaW1lR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZUdyaWQodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucHJvY2Vzc09wdGlvbnMoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlUaW1lcyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5jb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NbaV0uY29sID0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIEhhbmRsaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVRpbWVzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHNlZ1JhbmdlO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCB0aGlzLmRheXNQZXJSb3c7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSB1bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHRoaXMuZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1zOiBzZWdSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1zOiBzZWdSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5pc0VuZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleDogZGF5SW5kZXhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIE9wdGlvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBQYXJzZXMgdmFyaW91cyBvcHRpb25zIGludG8gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzbG90RHVyYXRpb24gPSB0aGlzLm9wdCgnc2xvdER1cmF0aW9uJyk7XHJcbiAgICAgICAgdmFyIHNuYXBEdXJhdGlvbiA9IHRoaXMub3B0KCdzbmFwRHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgaW5wdXQ7XHJcbiAgICAgICAgc2xvdER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gbW9tZW50LmR1cmF0aW9uKHNuYXBEdXJhdGlvbikgOiBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbG90RHVyYXRpb24gPSBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwc1BlclNsb3QgPSBzbG90RHVyYXRpb24gLyBzbmFwRHVyYXRpb247IC8vIFRPRE86IGVuc3VyZSBhbiBpbnRlZ2VyIG11bHRpcGxlP1xyXG4gICAgICAgIC8vIG1pZ2h0IGJlIGFuIGFycmF5IHZhbHVlIChmb3IgVGltZWxpbmVWaWV3KS5cclxuICAgICAgICAvLyBpZiBzbywgZ2V0dGluZyB0aGUgbW9zdCBncmFudWxhciBlbnRyeSAodGhlIGxhc3Qgb25lIHByb2JhYmx5KS5cclxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0KCdzbG90TGFiZWxGb3JtYXQnKTtcclxuICAgICAgICBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0ID0gaW5wdXQgfHxcclxuICAgICAgICAgICAgdGhpcy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpOyAvLyB0aGUgY29tcHV0ZWQgZGVmYXVsdFxyXG4gICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xyXG4gICAgICAgICAgICBtb21lbnQuZHVyYXRpb24oaW5wdXQpIDpcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlTGFiZWxJbnRlcnZhbCA9IGZ1bmN0aW9uIChzbG90RHVyYXRpb24pIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICB2YXIgc2xvdHNQZXJMYWJlbDtcclxuICAgICAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdG9jayBsYWJlbCBpbnRlcnZhbCB0aGF0IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSBzbG90cy1wZXItbGFiZWxcclxuICAgICAgICBmb3IgKGkgPSBBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcclxuICAgICAgICAgICAgc2xvdHNQZXJMYWJlbCA9IHV0aWxfMS5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pOyAvLyBmYWxsIGJhY2suIGNsb25lXHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2xhdHMoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckNvbHVtbnMoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB0aGlzLnVucmVuZGVyU2xhdHMoKTsgLy8gZG9uJ3QgbmVlZCB0aGlzIGJlY2F1c2UgcmVwZWF0ZWQgLmh0bWwoKSBjYWxscyBjbGVhclxyXG4gICAgICAgIHRoaXMudW5yZW5kZXJDb2x1bW5zKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLmVsLmh0bWwoJzxkaXYgY2xhc3M9XCJmYy1iZ1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXNsYXRzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiAvPicpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUnVsZUVsID0gdGhpcy5lbC5maW5kKCdocicpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTbGF0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJz4gLmZjLXNsYXRzJylcclxuICAgICAgICAgICAgLmh0bWwoLy8gYXZvaWRzIG5lZWRpbmcgOjp1bnJlbmRlclNsYXRzKClcclxuICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTbGF0Um93SHRtbCgpICtcclxuICAgICAgICAgICAgJzwvdGFibGU+Jyk7XHJcbiAgICAgICAgdGhpcy5zbGF0RWxzID0gdGhpcy5zbGF0Q29udGFpbmVyRWwuZmluZCgndHInKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLnNsYXRFbHMsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTbGF0Um93SHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBpc1JUTCA9IHRoaXMuaXNSVEw7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBzbG90VGltZSA9IG1vbWVudC5kdXJhdGlvbigrZGF0ZVByb2ZpbGUubWluVGltZSk7IC8vIHdpc2ggdGhlcmUgd2FzIC5jbG9uZSgpIGZvciBkdXJhdGlvbnNcclxuICAgICAgICB2YXIgc2xvdEl0ZXJhdG9yID0gbW9tZW50LmR1cmF0aW9uKDApO1xyXG4gICAgICAgIHZhciBzbG90RGF0ZTsgLy8gd2lsbCBiZSBvbiB0aGUgdmlldydzIGZpcnN0IGRheSwgYnV0IHdlIG9ubHkgY2FyZSBhYm91dCBpdHMgdGltZVxyXG4gICAgICAgIHZhciBpc0xhYmVsZWQ7XHJcbiAgICAgICAgdmFyIGF4aXNIdG1sO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGltZSBmb3IgZWFjaCBzbG90XHJcbiAgICAgICAgd2hpbGUgKHNsb3RUaW1lIDwgZGF0ZVByb2ZpbGUubWF4VGltZSkge1xyXG4gICAgICAgICAgICBzbG90RGF0ZSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQoZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMpLnRpbWUoc2xvdFRpbWUpO1xyXG4gICAgICAgICAgICBpc0xhYmVsZWQgPSB1dGlsXzEuaXNJbnQodXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihzbG90SXRlcmF0b3IsIHRoaXMubGFiZWxJbnRlcnZhbCkpO1xyXG4gICAgICAgICAgICBheGlzSHRtbCA9XHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyBmYy10aW1lICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzTGFiZWxlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoc2xvdERhdGUuZm9ybWF0KHRoaXMubGFiZWxGb3JtYXQpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgICAgIGh0bWwgKz1cclxuICAgICAgICAgICAgICAgICc8dHIgZGF0YS10aW1lPVwiJyArIHNsb3REYXRlLmZvcm1hdCgnSEg6bW06c3MnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc0xhYmVsZWQgPyAnJyA6ICcgY2xhc3M9XCJmYy1taW5vclwiJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKCFpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgICAgICBzbG90VGltZS5hZGQodGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBzbG90SXRlcmF0b3IuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSB0aGlzLmRheURhdGVzLm1hcChmdW5jdGlvbiAoZGF5RGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5taW5UaW1lKSwgZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5tYXhUaW1lKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZENvbnRhaW5lckVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZENvbnRhaW5lckVsLmh0bWwodGhpcy5yZW5kZXJIZWFkSHRtbCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCc+IC5mYy1iZycpLmh0bWwoJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdUckh0bWwoMCkgKyAvLyByb3c9MFxyXG4gICAgICAgICAgICAnPC90YWJsZT4nKTtcclxuICAgICAgICB0aGlzLmNvbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5jb2xFbHMsXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyogQ29udGVudCBTa2VsZXRvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgdGhlIERPTSB0aGF0IHRoZSB2aWV3J3MgY29udGVudCB3aWxsIGxpdmUgaW5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJDb250ZW50U2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNlbGxIdG1sID0gJyc7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcclxuICAgICAgICAgICAgY2VsbEh0bWwgKz1cclxuICAgICAgICAgICAgICAgICc8dGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LWNvbFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyIGZjLWhlbHBlci1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtaGlnaGxpZ2h0LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBza2VsZXRvbkVsID0gdGhpcy5jb250ZW50U2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xyXG4gICAgICAgIHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmJvb2tlbmRDZWxscyhza2VsZXRvbkVsLmZpbmQoJ3RyJykpOyAvLyBUT0RPOiBkbyB0aGlzIG9uIHN0cmluZyBsZXZlbFxyXG4gICAgICAgIHRoaXMuZWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckNvbnRlbnRTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50U2tlbGV0b25FbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyBjb2xcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5ncm91cFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeUNvbCA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Vnc0J5Q29sO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIGdyb3VwZWQgYnkgY29sdW1uLCBpbnNlcnQgdGhlIHNlZ21lbnRzJyBlbGVtZW50cyBpbnRvIGEgcGFyYWxsZWwgYXJyYXkgb2YgY29udGFpbmVyXHJcbiAgICAvLyBlbGVtZW50cywgZWFjaCBsaXZpbmcgd2l0aGluIGEgY29sdW1uLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmF0dGFjaFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgc2VncyA9IHNlZ3NCeUNvbFtjb2xdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxzLmVxKGNvbCkuYXBwZW5kKHNlZ3NbaV0uZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ21pbnV0ZSc7IC8vIHdpbGwgcmVmcmVzaCBvbiB0aGUgbWludXRlXHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgLy8gSEFDSzogaWYgZGF0ZSBjb2x1bW5zIG5vdCByZWFkeSBmb3Igc29tZSByZWFzb24gKHNjaGVkdWxlcilcclxuICAgICAgICBpZiAoIXRoaXMuY29sQ29udGFpbmVyRWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2VnIHN5c3RlbSBtaWdodCBiZSBvdmVya2lsbCwgYnV0IGl0IGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgbGluZSBuZWVkcyB0byBiZSByZW5kZXJlZFxyXG4gICAgICAgIC8vICBtb3JlIHRoYW4gb25jZSBiZWNhdXNlIG9mIGNvbHVtbnMgd2l0aCB0aGUgc2FtZSBkYXRlIChyZXNvdXJjZXMgY29sdW1ucyBmb3IgZXhhbXBsZSlcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRhdGUsIGRhdGUudmFsdWVPZigpICsgMSksIC8vIHByb3RlY3QgYWdhaW5zdCBudWxsIHJhbmdlXHJcbiAgICAgICAgZmFsc2UgLy8gYWxsLWRheVxyXG4gICAgICAgICkpO1xyXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKGRhdGUsIGRhdGUpO1xyXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlbmRlciBsaW5lcyB3aXRoaW4gdGhlIGNvbHVtbnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKCQoJzxkaXYgY2xhc3M9XCJmYy1ub3ctaW5kaWNhdG9yIGZjLW5vdy1pbmRpY2F0b3ItbGluZVwiPjwvZGl2PicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCd0b3AnLCB0b3ApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5jb2xDb250YWluZXJFbHMuZXEoc2Vnc1tpXS5jb2wpKVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlciBhbiBhcnJvdyBvdmVyIHRoZSBheGlzXHJcbiAgICAgICAgaWYgKHNlZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKCQoJzxkaXYgY2xhc3M9XCJmYy1ub3ctaW5kaWNhdG9yIGZjLW5vdy1pbmRpY2F0b3ItYXJyb3dcIj48L2Rpdj4nKVxyXG4gICAgICAgICAgICAgICAgLmNzcygndG9wJywgdG9wKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24nKSlbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscyA9ICQobm9kZXMpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JFbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogQ29vcmRpbmF0ZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VnVmVydGljYWxzKFtdLmNvbmNhdCh0aGlzLmV2ZW50UmVuZGVyZXIuZ2V0U2VncygpLCB0aGlzLmJ1c2luZXNzU2VncyB8fCBbXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0VG90YWxTbGF0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsYXRDb250YWluZXJFbC5vdXRlckhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgbXNgIGNhbiBiZSBhIG1pbGxpc2Vjb25kIFVUQyB0aW1lIE9SIGEgVVRDIG1vbWVudC5cclxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZURhdGVUb3AgPSBmdW5jdGlvbiAobXMsIHN0YXJ0T2ZEYXlEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVRpbWVUb3AobW9tZW50LmR1cmF0aW9uKG1zIC0gc3RhcnRPZkRheURhdGUuY2xvbmUoKS5zdHJpcFRpbWUoKSkpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVUaW1lVG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5zbGF0RWxzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAodGltZSAtIGRhdGVQcm9maWxlLm1pblRpbWUpIC8gdGhpcy5zbG90RHVyYXRpb247IC8vIGZsb2F0aW5nLXBvaW50IHZhbHVlIG9mICMgb2Ygc2xvdHMgY292ZXJlZFxyXG4gICAgICAgIHZhciBzbGF0SW5kZXg7XHJcbiAgICAgICAgdmFyIHNsYXRSZW1haW5kZXI7XHJcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cclxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXHJcbiAgICAgICAgLy8gY29uc3RyYWluZWQgYmVjYXVzZSBtaW5UaW1lL21heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cclxuICAgICAgICBzbGF0Q292ZXJhZ2UgPSBNYXRoLm1heCgwLCBzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XHJcbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBzbGF0cyAoKmV4Y2x1c2l2ZSosIHNvIGxlbi0xKVxyXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcclxuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xyXG4gICAgICAgIC8vIGhvdyBtdWNoIGZ1cnRoZXIgdGhyb3VnaCB0aGUgc2xhdEluZGV4IHNsYXQgKGZyb20gMC4wLTEuMCkgbXVzdCBiZSBjb3ZlcmVkIGluIGFkZGl0aW9uLlxyXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXHJcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRUb3BQb3NpdGlvbihzbGF0SW5kZXgpICtcclxuICAgICAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBDU1MgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWdtZW50IGVsZW1lbnQuXHJcbiAgICAvLyBXb3JrcyB3aGVuIGNhbGxlZCBhZnRlciBpbml0aWFsIHJlbmRlciwgYWZ0ZXIgYSB3aW5kb3cgcmVzaXplL3pvb20gZm9yIGV4YW1wbGUuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudXBkYXRlU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGhpcy5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCBpbiBhbiBhcnJheSwgY29tcHV0ZXMgYW5kIGFzc2lnbnMgaXRzIHRvcCBhbmQgYm90dG9tIHByb3BlcnRpZXNcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgZXZlbnRNaW5IZWlnaHQgPSB0aGlzLm9wdCgnYWdlbmRhRXZlbnRNaW5IZWlnaHQnKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBkYXlEYXRlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGRheURhdGUgPSB0aGlzLmRheURhdGVzW3NlZy5kYXlJbmRleF07XHJcbiAgICAgICAgICAgIHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydE1zLCBkYXlEYXRlKTtcclxuICAgICAgICAgICAgc2VnLmJvdHRvbSA9IE1hdGgubWF4KHNlZy50b3AgKyBldmVudE1pbkhlaWdodCwgdGhpcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kTXMsIGRheURhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhbHJlYWR5IGhhdmUgdGhlaXIgdG9wL2JvdHRvbSBwcm9wZXJ0aWVzIGNvbXB1dGVkLCBhcHBsaWVzIHRob3NlIHZhbHVlcyB0b1xyXG4gICAgLy8gdGhlIHNlZ21lbnRzJyBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5hc3NpZ25TZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2VnLmVsLmNzcyh0aGlzLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcyBmb3IgdGhlIHRvcC9ib3R0b20gY29vcmRpbmF0ZXMgb2YgYSBzZWdtZW50IGVsZW1lbnRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDogc2VnLnRvcCxcclxuICAgICAgICAgICAgYm90dG9tOiAtc2VnLmJvdHRvbSAvLyBmbGlwcGVkIGJlY2F1c2UgbmVlZHMgdG8gYmUgc3BhY2UgYmV5b25kIGJvdHRvbSBlZGdlIG9mIGV2ZW50IGNvbnRhaW5lclxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIC8vIE5PVEU6IGRvbid0IGNsZWFyIHNsYXRDb29yZENhY2hlIGJlY2F1c2Ugd2UgcmVseSBvbiBpdCBmb3IgY29tcHV0ZVRpbWVUb3BcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHNuYXBzUGVyU2xvdCA9IHRoaXMuc25hcHNQZXJTbG90O1xyXG4gICAgICAgIHZhciBjb2xDb29yZENhY2hlID0gdGhpcy5jb2xDb29yZENhY2hlO1xyXG4gICAgICAgIHZhciBzbGF0Q29vcmRDYWNoZSA9IHRoaXMuc2xhdENvb3JkQ2FjaGU7XHJcbiAgICAgICAgaWYgKGNvbENvb3JkQ2FjaGUuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgc2xhdENvb3JkQ2FjaGUuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xJbmRleCA9IGNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xyXG4gICAgICAgICAgICB2YXIgc2xhdEluZGV4ID0gc2xhdENvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsYXRUb3AgPSBzbGF0Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQoc2xhdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGF0SGVpZ2h0ID0gc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9ICh0b3BPZmZzZXQgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBJbmRleCA9IHNsYXRJbmRleCAqIHNuYXBzUGVyU2xvdCArIGxvY2FsU25hcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBUb3AgPSBzbGF0VG9wICsgKGxvY2FsU25hcEluZGV4IC8gc25hcHNQZXJTbG90KSAqIHNsYXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcEJvdHRvbSA9IHNsYXRUb3AgKyAoKGxvY2FsU25hcEluZGV4ICsgMSkgLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2xJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBzbmFwOiBzbmFwSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2xJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3JkQ2FjaGUuZ2V0UmlnaHRPZmZzZXQoY29sSW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc25hcFRvcCxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHNuYXBCb3R0b21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKDAsIGhpdC5jb2wpOyAvLyByb3c9MFxyXG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5jb21wdXRlU25hcFRpbWUoaGl0LnNuYXApOyAvLyBwYXNzIGluIHRoZSBzbmFwLWluZGV4XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBzdGFydC50aW1lKHRpbWUpO1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuc25hcER1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCksIGZhbHNlIC8vIGFsbC1kYXk/XHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIHJvdyBudW1iZXIgb2YgdGhlIGdyaWQsIHJlcHJlc2VudGluZyBhIFwic25hcFwiLCByZXR1cm5zIGEgdGltZSAoRHVyYXRpb24pIGZyb20gaXRzIHN0YXJ0LW9mLWRheVxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVTbmFwVGltZSA9IGZ1bmN0aW9uIChzbmFwSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHRoaXMuZGF0ZVByb2ZpbGUubWluVGltZSArIHRoaXMuc25hcER1cmF0aW9uICogc25hcEluZGV4KTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sRWxzLmVxKGhpdC5jb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkIG92ZXIgdGhlIHNwZWNpZmllZCBkYXRlKHMpLlxyXG4gICAgLy8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudEZvb3RwcmludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnJlbmRlckV2ZW50RHJhZ2dpbmdGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGEgaGVscGVyIGhhcyBiZWVuIHJlbmRlcmVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uLiBPdmVycmlkZXMgdGhlIGRlZmF1bHQsIHdoaWNoIHdhcyB0byBzaW1wbHkgcmVuZGVyIGEgaGlnaGxpZ2h0LlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3NlbGVjdEhlbHBlcicpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyQ29tcG9uZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWQ7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZDtcclxuVGltZUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuZmlsbFJlbmRlcmVyQ2xhc3MgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGltZUdyaWQpO1xyXG5EYXlUYWJsZU1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRpbWVHcmlkKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIxKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpOyAvLyBhbiBVbnpvbmVkUmFuZ2VcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLmVuZE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignd2VlaycpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmIChlbmQud2Vla2RheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKDEsICd3ZWVrJykuc3RhcnRPZignd2VlaycpOyAvLyBleGNsdXNpdmVseSBtb3ZlIGJhY2t3YXJkc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbnZhciBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTMpO1xyXG4vKiBBIG1vbnRoIHZpZXcgd2l0aCBkYXkgY2VsbHMgcnVubmluZyBpbiByb3dzIChvbmUtcGVyLXdlZWspIGFuZCBjb2x1bW5zXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgTW9udGhWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9udGhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9udGhWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcclxuICAgIE1vbnRoVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIC8vIGlmIGF1dG8sIG1ha2UgdGhlIGhlaWdodCBvZiBlYWNoIHJvdyB0aGUgaGVpZ2h0IHRoYXQgaXQgd291bGQgYmUgaWYgdGhlcmUgd2VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5kYXlHcmlkLnJvd0NudCAvIDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3NcclxuICAgIH07XHJcbiAgICBNb250aFZpZXcucHJvdG90eXBlLmlzRGF0ZUluT3RoZXJNb250aCA9IGZ1bmN0aW9uIChkYXRlLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRlLm1vbnRoKCkgIT09IG1vbWVudC51dGMoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5zdGFydE1zKS5tb250aCgpOyAvLyBUT0RPOiBvcHRpbWl6ZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXc7XHJcbn0oQmFzaWNWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb250aFZpZXc7XHJcbk1vbnRoVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogMjMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBMaXN0RXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTQpO1xyXG52YXIgTGlzdEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjU1KTtcclxuLypcclxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxyXG4qL1xyXG52YXIgTGlzdFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0VmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zZWdTZWxlY3RvciA9ICcuZmMtbGlzdC1pdGVtJzsgLy8gd2hpY2ggZWxlbWVudHMgYWNjZXB0IGV2ZW50IGFjdGlvbnNcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1saXN0LXZpZXcgJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ2xpc3RWaWV3JykpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5lbC5hcHBlbmRUbyh0aGlzLmVsKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMuc2Nyb2xsZXIuc2Nyb2xsRWw7IC8vIHNob3J0Y3V0XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBHcmlkIHRvb1xyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTsgLy8gc2V0cyBoZWlnaHQgdG8gJ2F1dG8nIGFuZCBjbGVhcnMgb3ZlcmZsb3dcclxuICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodCh0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRheVN0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHZpZXdFbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcclxuICAgICAgICAgICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZGF5UmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5U3RhcnQsIGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXknKSkpO1xyXG4gICAgICAgICAgICBkYXlTdGFydC5hZGQoMSwgJ2RheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRheURhdGVzID0gZGF5RGF0ZXM7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSBkYXlSYW5nZXM7XHJcbiAgICAgICAgLy8gYWxsIHJlYWwgcmVuZGVyaW5nIGhhcHBlbnMgaW4gRXZlbnRSZW5kZXJlclxyXG4gICAgfTtcclxuICAgIC8vIHNsaWNlcyBieSBkYXlcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoZm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IHRoaXMuZGF5UmFuZ2VzO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSBmb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNczogc2VnUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRNczogc2VnUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2UuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg6IGRheUluZGV4XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3Qgd2hlbiBmb290cHJpbnQgd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbXV0YXRlIHRoZSBsYXRlc3Qgc2VnIHRvIHRoZSBiZSB0aGUgZW5kLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWZvb3RwcmludC5pc0FsbERheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zIDwgZGF5UmFuZ2VzW2RheUluZGV4ICsgMV0uc3RhcnRNcyArIHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbmRNcyA9IGZvb3RwcmludC51bnpvbmVkUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyRW1wdHlNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmh0bWwoJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAyXCI+JyArIC8vIFRPRE86IHRyeSBsZXNzIHdyYXBzXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMVwiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHlcIj4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ25vRXZlbnRzTWVzc2FnZScpKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gcmVuZGVyIHRoZSBldmVudCBzZWdtZW50cyBpbiB0aGUgdmlld1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlclNlZ0xpc3QgPSBmdW5jdGlvbiAoYWxsU2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlEYXkgPSB0aGlzLmdyb3VwU2Vnc0J5RGF5KGFsbFNlZ3MpOyAvLyBzcGFyc2UgYXJyYXlcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgdmFyIGRheVNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhYmxlRWwgPSAkKCc8dGFibGUgY2xhc3M9XCJmYy1saXN0LXRhYmxlICcgKyB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0YWJsZUxpc3QnKSArICdcIj48dGJvZHkvPjwvdGFibGU+Jyk7XHJcbiAgICAgICAgdmFyIHRib2R5RWwgPSB0YWJsZUVsLmZpbmQoJ3Rib2R5Jyk7XHJcbiAgICAgICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgc2Vnc0J5RGF5Lmxlbmd0aDsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGRheVNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcclxuICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKHRoaXMuZGF5SGVhZGVySHRtbCh0aGlzLmRheURhdGVzW2RheUluZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNvcnRFdmVudFNlZ3MoZGF5U2Vncyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF5U2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKGRheVNlZ3NbaV0uZWwpOyAvLyBhcHBlbmQgZXZlbnQgcm93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKS5hcHBlbmQodGFibGVFbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmdyb3VwU2Vnc0J5RGF5ID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gW107IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdIHx8IChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSA9IFtdKSlcclxuICAgICAgICAgICAgICAgIC5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzQnlEYXk7XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMgdGhhdCBsaXZlIGFtb25nc3QgdGhlIGV2ZW50IHJvd3NcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5kYXlIZWFkZXJIdG1sID0gZnVuY3Rpb24gKGRheURhdGUpIHtcclxuICAgICAgICB2YXIgbWFpbkZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5Rm9ybWF0Jyk7XHJcbiAgICAgICAgdmFyIGFsdEZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5QWx0Rm9ybWF0Jyk7XHJcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJmYy1saXN0LWhlYWRpbmdcIiBkYXRhLWRhdGU9XCInICsgZGF5RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyAodGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndGFibGVMaXN0SGVhZGluZycpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpKSArICdcIiBjb2xzcGFuPVwiM1wiPicgK1xyXG4gICAgICAgICAgICAobWFpbkZvcm1hdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkR290b0FuY2hvckh0bWwoZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLW1haW4nIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KG1haW5Gb3JtYXQpKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChhbHRGb3JtYXQgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEdvdG9BbmNob3JIdG1sKGRheURhdGUsIHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1hbHQnIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KGFsdEZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RWaWV3O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gTGlzdEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gTGlzdEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzEgKi8sXG4vKiAyMzIgKi8sXG4vKiAyMzMgKi8sXG4vKiAyMzQgKi8sXG4vKiAyMzUgKi8sXG4vKiAyMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDYWxlbmRhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjApO1xyXG4vLyBmb3IgaW50ZW50aW9uYWwgc2lkZS1lZmZlY3RzXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNTYpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1Nyk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjEpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2Mik7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYzKTtcclxuJC5mdWxsQ2FsZW5kYXIgPSBleHBvcnRIb29rcztcclxuJC5mbi5mdWxsQ2FsZW5kYXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3IgYSBwb3NzaWJsZSBtZXRob2QgY2FsbFxyXG4gICAgdmFyIHJlcyA9IHRoaXM7IC8vIHdoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiAodGhpcyBqUXVlcnkgb2JqZWN0IGJ5IGRlZmF1bHQpXHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIF9lbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKF9lbGVtZW50KTtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicpOyAvLyBnZXQgdGhlIGV4aXN0aW5nIGNhbGVuZGFyIG9iamVjdCAoaWYgYW55KVxyXG4gICAgICAgIHZhciBzaW5nbGVSZXM7IC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBvZiB0aGlzIHNpbmdsZSBtZXRob2QgY2FsbFxyXG4gICAgICAgIC8vIGEgbWV0aG9kIGNhbGxcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZ2V0Q2FsZW5kYXInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oJ0F0dGVtcHRpbmcgdG8gY2FsbCBhIEZ1bGxDYWxlbmRhciBtZXRob2Qgb24gYW4gZWxlbWVudCB3aXRoIG5vIGNhbGVuZGFyLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihjYWxlbmRhcltvcHRpb25zXSkpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZVJlcyA9IGNhbGVuZGFyW29wdGlvbnNdLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oXCInXCIgKyBvcHRpb25zICsgXCInIGlzIGFuIHVua25vd24gRnVsbENhbGVuZGFyIG1ldGhvZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyID0gbmV3IENhbGVuZGFyXzEuZGVmYXVsdChlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRIb29rcztcclxuXG5cbi8qKiovIH0pLFxuLyogMjM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2tlbGV0b24oKTtcclxuICAgICAgICB0aGlzLnNldCgnaXNJbkRvbScsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdpc0luRG9tJyk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlclNrZWxldG9uKCk7XHJcbiAgICAgICAgdGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBpbiBjYXNlIHRoZSBWaWV3IHdhcyBkZXN0cm95ZWQgd2l0aGluIGFuIEFQSSBjYWxsYmFjay5cclxuICAgICAgICAvLyBXZSBkb24ndCBudWxsLW91dCB0aGUgVmlldydzIG90aGVyIGpRdWVyeSBlbGVtZW50IHJlZmVyZW5jZXMgdXBvbiBkZXN0cm95LFxyXG4gICAgICAgIC8vICBzbyB3ZSBzaG91bGRuJ3Qga2lsbCB0aGlzLmVsIGVpdGhlci5cclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTk9URTogQ2FuJ3QgaGF2ZSBhIGByZW5kZXJgIG1ldGhvZC4gUmVhZCB0aGUgZGVwcmVjYXRpb24gbm90aWNlIGluIFZpZXc6OmV4ZWN1dGVEYXRlUmVuZGVyXHJcbiAgICAqL1xyXG4gICAgLy8gUmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3IGJlZm9yZSBhbnkgY29udGVudCBpcyByZW5kZXJlZFxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlld1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wb25lbnQ7XHJcbn0oTW9kZWxfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbXBvbmVudDtcclxuXG5cbi8qKiovIH0pLFxuLyogMjM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3IoaXRlbXMpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXMgfHwgW107XHJcbiAgICB9XHJcbiAgICAvKiBDYWxscyBhIG1ldGhvZCBvbiBldmVyeSBpdGVtIHBhc3NpbmcgdGhlIGFyZ3VtZW50cyB0aHJvdWdoICovXHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUucHJveHlDYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtW21ldGhvZE5hbWVdLmFwcGx5KGl0ZW0sIGFyZ3MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gSXRlcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEl0ZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBUb29sYmFyIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbGJhcihjYWxlbmRhciwgdG9vbGJhck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVsID0gbnVsbDsgLy8gbWlycm9ycyBsb2NhbCBgZWxgXHJcbiAgICAgICAgdGhpcy52aWV3c1dpdGhCdXR0b25zID0gW107XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSB0b29sYmFyT3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIG1ldGhvZCB0byB1cGRhdGUgdG9vbGJhci1zcGVjaWZpYyBvcHRpb25zLCBub3QgY2FsZW5kYXItd2lkZSBvcHRpb25zXHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5zZXRUb29sYmFyT3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdUb29sYmFyT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSBuZXdUb29sYmFyT3B0aW9ucztcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIHdpbGwgcmVyZW5kZXJcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VjdGlvbnMgPSB0aGlzLnRvb2xiYXJPcHRpb25zLmxheW91dDtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgIGlmIChzZWN0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhciBcIiArIHRoaXMudG9vbGJhck9wdGlvbnMuZXh0cmFDbGFzc2VzICsgXCInLz5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbC5lbXB0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2xlZnQnKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5yZW5kZXJTZWN0aW9uKCdyaWdodCcpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gY2FsZW5kYXIub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjTWFuYWdlciA9IGNhbGVuZGFyLnZpZXdTcGVjTWFuYWdlcjtcclxuICAgICAgICB2YXIgc2VjdGlvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBwb3NpdGlvbiArICdcIi8+Jyk7XHJcbiAgICAgICAgdmFyIGJ1dHRvblN0ciA9IHRoaXMudG9vbGJhck9wdGlvbnMubGF5b3V0W3Bvc2l0aW9uXTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gb3B0aW9uc01hbmFnZXIuZ2V0KCdjdXN0b21CdXR0b25zJykgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBvcHRpb25zTWFuYWdlci5nZXQoJ2J1dHRvblRleHQnKSB8fCB7fTtcclxuICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24gKGksIGJ1dHRvbkdyb3VwU3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEVsO1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChqLCBidXR0b25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3U3BlYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQ7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklubmVySHRtbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkFyaWFBdHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZCgkKCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGJ1dHRvbkVsWzBdLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyhidXR0b25OYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJbYnV0dG9uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBeIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdidXR0b24nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygnc3RhdGVEZWZhdWx0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nXCIgKyBidXR0b25JY29uICsgXCInPjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25BcmlhQXR0ciA9ICcgYXJpYS1sYWJlbD1cIicgKyBidXR0b25OYW1lICsgJ1wiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsID0gJCgvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIicgKyBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicgKyBidXR0b25Jbm5lckh0bWwgKyAnPC9idXR0b24+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBjbGlja3MgZm9yIGRpc2FibGVkIGJ1dHRvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGNsaWNrIGFjdGlvbiwgaWYgdGhlIGJ1dHRvbiBiZWNvbWVzIHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBuZXZlciBoYXZlIGEgaG92ZXIgY2xhc3MsIHNvIHJlbW92ZSBpdCBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25FbC5oYXNDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlICpkb3duKiBlZmZlY3QgKG1vdXNlIHByZXNzZWQgaW4pLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb3VzZXVwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRvIHRoZSAqZG93biogZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhvdmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgKmhvdmVyKiBlZmZlY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kbyB0aGUgKmhvdmVyKiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7IC8vIGlmIG1vdXNlbGVhdmUgaGFwcGVucyBiZWZvcmUgbW91c2V1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoYnV0dG9uRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbmx5QnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpcnN0KCkuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2Nvcm5lckxlZnQnKSkuZW5kKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxhc3QoKS5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnY29ybmVyUmlnaHQnKSkuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbCA9ICQoJzxkaXYvPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09ubHlCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBncm91cEVsLmFwcGVuZChncm91cENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kKGdyb3VwRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkVsLmFwcGVuZChncm91cENoaWxkcmVuKTsgLy8gMSBvciAwIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VjdGlvbkVsO1xyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJ2gyJykudGV4dCh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuYWN0aXZhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kZWFjdGl2YXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZGlzYWJsZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmVuYWJsZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5nZXRWaWV3c1dpdGhCdXR0b25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzV2l0aEJ1dHRvbnM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRvb2xiYXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIE1vZGVsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcclxudmFyIE9wdGlvbnNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3B0aW9uc01hbmFnZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBPcHRpb25zTWFuYWdlcihfY2FsZW5kYXIsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLm92ZXJyaWRlcyA9ICQuZXh0ZW5kKHt9LCBvdmVycmlkZXMpOyAvLyBtYWtlIGEgY29weVxyXG4gICAgICAgIF90aGlzLmR5bmFtaWNPdmVycmlkZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5jb21wdXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbkNudCA9IDA7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRPdmVycmlkZXMobmV3T3B0aW9uSGFzaCk7IC8vIHdpbGwgdHJpZ2dlciB0aGlzIG1vZGVsJ3Mgd2F0Y2hlcnNcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICBvcHRpb25DbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHNpbmdsZSBvcHRpb24gY2hhbmdlLlxyXG4gICAgICAgIC8vIGlmIG9ubHkgb25lIG9wdGlvbiBjaGFuZ2UsIGBvcHRpb25OYW1lYCB3aWxsIGJlIGl0cyBuYW1lLlxyXG4gICAgICAgIGlmIChvcHRpb25DbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdoZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdjb250ZW50SGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnYXNwZWN0UmF0aW8nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci51cGRhdGVWaWV3U2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdkZWZhdWx0RGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY2FuJ3QgY2hhbmdlIGRhdGUgdGhpcyB3YXkuIHVzZSBnb3RvRGF0ZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRoaXMgbW9kZWwgYWxyZWFkeSByZWFjdHMgdG8gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKC9eKGV2ZW50fHNlbGVjdCkoT3ZlcmxhcHxDb25zdHJhaW50fEFsbG93KSQvLnRlc3Qob3B0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG9lc24ndCBhZmZlY3QgcmVuZGVyaW5nLiBvbmx5IGludGVyYWN0aW9ucy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAndGltZXpvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3LmZsYXNoKCdpbml0aWFsRXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2F0Y2gtYWxsLiByZXJlbmRlciB0aGUgaGVhZGVyIGFuZCBmb290ZXIgYW5kIHJlYnVpbGQvcmVyZW5kZXIgdGhlIGN1cnJlbnQgdmlld1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIC8vIGV2ZW4gbm9uLWN1cnJlbnQgdmlld3Mgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbiBjaGFuZ2UuIGRvIGJlZm9yZSByZXJlbmRlclxyXG4gICAgICAgIC8vIFRPRE86IGRldGFuZ2xlXHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci5yZWluaXRWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cclxuICAgIC8vIEFzc3VtZXMgdGhpcy5vdmVycmlkZXMgYW5kIHRoaXMuZHluYW1pY092ZXJyaWRlcyBoYXZlIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cclxuICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2NhbGU7XHJcbiAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHZhciBpc1JUTDtcclxuICAgICAgICB2YXIgZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIHJhd09wdGlvbnM7XHJcbiAgICAgICAgbG9jYWxlID0gdXRpbF8xLmZpcnN0RGVmaW5lZCgvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIGdpdmVuP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5sb2NhbGUsIHRoaXMub3ZlcnJpZGVzLmxvY2FsZSk7XHJcbiAgICAgICAgbG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVfMS5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZV07XHJcbiAgICAgICAgaWYgKCFsb2NhbGVEZWZhdWx0cykge1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMubG9jYWxlO1xyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXSB8fCB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNSVEwgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5pc1JUTCwgdGhpcy5vdmVycmlkZXMuaXNSVEwsIGxvY2FsZURlZmF1bHRzLmlzUlRMLCBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMuaXNSVEwpO1xyXG4gICAgICAgIGRpckRlZmF1bHRzID0gaXNSVEwgPyBvcHRpb25zXzEucnRsRGVmYXVsdHMgOiB7fTtcclxuICAgICAgICB0aGlzLmRpckRlZmF1bHRzID0gZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdGhpcy5sb2NhbGVEZWZhdWx0cyA9IGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHJhd09wdGlvbnMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtcclxuICAgICAgICAgICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLFxyXG4gICAgICAgICAgICBkaXJEZWZhdWx0cyxcclxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNcclxuICAgICAgICBdKTtcclxuICAgICAgICBsb2NhbGVfMS5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMocmF3T3B0aW9ucyk7IC8vIGZpbGwgaW4gZ2FwcyB3aXRoIGNvbXB1dGVkIG9wdGlvbnNcclxuICAgICAgICB0aGlzLnJlc2V0KHJhd09wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIC8vIHN0b3JlcyB0aGUgbmV3IG9wdGlvbnMgaW50ZXJuYWxseSwgYnV0IGRvZXMgbm90IHJlcmVuZGVyIGFueXRoaW5nLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnJlY29yZE92ZXJyaWRlcyA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgZm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzW29wdGlvbk5hbWVdID0gbmV3T3B0aW9uSGFzaFtvcHRpb25OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld1NwZWNNYW5hZ2VyLmNsZWFyQ2FjaGUoKTsgLy8gdGhlIGR5bmFtaWMgb3ZlcnJpZGUgaW52YWxpZGF0ZXMgdGhlIG9wdGlvbnMgaW4gdGhpcyBjYWNoZSwgc28ganVzdCBjbGVhciBpdFxyXG4gICAgICAgIHRoaXMuY29tcHV0ZSgpOyAvLyB0aGlzLm9wdGlvbnMgbmVlZHMgdG8gYmUgcmVjb21wdXRlZCBhZnRlciB0aGUgZHluYW1pYyBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPcHRpb25zTWFuYWdlcjtcclxufShNb2RlbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3B0aW9uc01hbmFnZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIFZpZXdTcGVjTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdTcGVjTWFuYWdlcihvcHRpb25zTWFuYWdlciwgX2NhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgfVxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNDYWNoZSA9IHt9O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIGNyZWF0ZSBhIHZpZXcuIFdpbGwgdXNlIGEgY2FjaGUuXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmdldFZpZXdTcGVjID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy52aWV3U3BlY0NhY2hlO1xyXG4gICAgICAgIHJldHVybiBjYWNoZVt2aWV3VHlwZV0gfHwgKGNhY2hlW3ZpZXdUeXBlXSA9IHRoaXMuYnVpbGRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICB2YXIgdmlld1R5cGVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzcGVjO1xyXG4gICAgICAgIGlmICgkLmluQXJyYXkodW5pdCwgdXRpbF8xLnVuaXRzRGVzYykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2ggd2VsbFxyXG4gICAgICAgICAgICB2aWV3VHlwZXMgPSB0aGlzLl9jYWxlbmRhci5oZWFkZXIuZ2V0Vmlld3NXaXRoQnV0dG9ucygpOyAvLyBUT0RPOiBpbmNsdWRlIGZvb3RlciBhcyB3ZWxsP1xyXG4gICAgICAgICAgICAkLmVhY2goVmlld1JlZ2lzdHJ5XzEudmlld0hhc2gsIGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcGVjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIG9uIGhvdyB0byBjcmVhdGUgYSBnaXZlbiB2aWV3XHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWMgPSBmdW5jdGlvbiAocmVxdWVzdGVkVmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgdmlld092ZXJyaWRlcyA9IHRoaXMub3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLnZpZXdzIHx8IHt9O1xyXG4gICAgICAgIHZhciBzcGVjQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciBkZWZhdWx0c0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciB2aWV3VHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIHZhciBzcGVjOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgZHVyYXRpb25JbnB1dDtcclxuICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgLy8gaXRlcmF0ZSBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3IGRlZmluaXRpb24gdG8gYSBtb3JlIGdlbmVyYWwgb25lIHVudGlsIHdlIGhpdCBhbiBhY3R1YWwgVmlldyBjbGFzc1xyXG4gICAgICAgIHdoaWxlICh2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBzcGVjID0gVmlld1JlZ2lzdHJ5XzEudmlld0hhc2hbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICBvdmVycmlkZXMgPSB2aWV3T3ZlcnJpZGVzW3ZpZXdUeXBlXTtcclxuICAgICAgICAgICAgdmlld1R5cGUgPSBudWxsOyAvLyBjbGVhci4gbWlnaHQgcmVwb3B1bGF0ZSBmb3IgYW5vdGhlciBpdGVyYXRpb25cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHNDaGFpbi51bnNoaWZ0KHNwZWMuZGVmYXVsdHMgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgc3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBvdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMgPSB1dGlsXzEubWVyZ2VQcm9wcyhzcGVjQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMudHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIGlmICghc3BlY1snY2xhc3MnXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0b3AtbGV2ZWwgYGR1cmF0aW9uYCBvcHRpb25cclxuICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbi52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSB1dGlsXzEuY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGR1cmF0aW9uLCBkdXJhdGlvbklucHV0KTtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb25Vbml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIC8vIHZpZXcgaXMgYSBzaW5nbGUtdW5pdCBkdXJhdGlvbiwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvcnBvcmF0ZSBvcHRpb25zIGZvciB0aGlzLiBsb3dlc3QgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbi5hcyh1bml0KSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWMuc2luZ2xlVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzQ2hhaW4udW5zaGlmdCh2aWV3T3ZlcnJpZGVzW3VuaXRdIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzcGVjLmRlZmF1bHRzID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhkZWZhdWx0c0NoYWluKTtcclxuICAgICAgICBzcGVjLm92ZXJyaWRlcyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMob3ZlcnJpZGVzQ2hhaW4pO1xyXG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY09wdGlvbnMoc3BlYyk7XHJcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuZCBhc3NpZ25zIGEgdmlldyBzcGVjJ3Mgb3B0aW9ucyBvYmplY3QgZnJvbSBpdHMgYWxyZWFkeS1hc3NpZ25lZCBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWNPcHRpb25zID0gZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uc01hbmFnZXIgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHNwZWMub3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICBzcGVjLm92ZXJyaWRlcyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcyAvLyBkeW5hbWljYWxseSBzZXQgdmlhIHNldHRlci4gaGlnaGVzdCBwcmVjZWRlbmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbG9jYWxlXzEucG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHNwZWMub3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBidXR0b25UZXh0LXJlbGF0ZWQgb3B0aW9uc1xyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dCA9IGZ1bmN0aW9uIChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IHRoaXMub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgLy8gZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIHBvc3NpYmxlIGBidXR0b25UZXh0YCBoYXNoLCBsb29rdXAgdGhlIGJ1dHRvblRleHQgZm9yIHRoZVxyXG4gICAgICAgIC8vIHJlcXVlc3RlZCB2aWV3LCBmYWxsaW5nIGJhY2sgdG8gYSBnZW5lcmljIHVuaXQgZW50cnkgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgZnVuY3Rpb24gcXVlcnlCdXR0b25UZXh0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0W3JlcXVlc3RlZFZpZXdUeXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gdmlldyBjYW4gZGVjaWRlIHRvIGxvb2sgdXAgYSBjZXJ0YWluIGtleVxyXG4gICAgICAgICAgICAgICAgKHNwZWMuYnV0dG9uVGV4dEtleSA/IGJ1dHRvblRleHRbc3BlYy5idXR0b25UZXh0S2V5XSA6IG51bGwpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBhIGtleSBsaWtlIFwibW9udGhcIlxyXG4gICAgICAgICAgICAgICAgKHNwZWMuc2luZ2xlVW5pdCA/IGJ1dHRvblRleHRbc3BlYy5zaW5nbGVVbml0XSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgICAgIHNwZWMuYnV0dG9uVGV4dE92ZXJyaWRlID1cclxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXHJcbiAgICAgICAgICAgICAgICBzcGVjLm92ZXJyaWRlcy5idXR0b25UZXh0OyAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xyXG4gICAgICAgIC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5LiBtaXJyb3JzIGJ1aWxkVmlld1NwZWNPcHRpb25zXHJcbiAgICAgICAgc3BlYy5idXR0b25UZXh0RGVmYXVsdCA9XHJcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5kaXJEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fCAvLyBhIHNpbmdsZSBzdHJpbmcuIGZyb20gVmlld1N1YmNsYXNzLmRlZmF1bHRzXHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc18xLmdsb2JhbERlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNwZWMuZHVyYXRpb24gPyB0aGlzLl9jYWxlbmRhci5odW1hbml6ZUR1cmF0aW9uKHNwZWMuZHVyYXRpb24pIDogbnVsbCkgfHwgLy8gbGlrZSBcIjMgZGF5c1wiXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWaWV3VHlwZTsgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3U3BlY01hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFZpZXdTcGVjTWFuYWdlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UGVyaW9kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Myk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuc3RpY2t5U291cmNlID0gbmV3IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lLCBmb3JjZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5jdXJyZW50UGVyaW9kIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QuaXNXaXRoaW5SYW5nZShzdGFydCwgZW5kKSB8fFxyXG4gICAgICAgICAgICB0aW1lem9uZSAhPT0gdGhpcy5jdXJyZW50UGVyaW9kLnRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyaW9kKC8vIHdpbGwgY2hhbmdlIHRoaXMuY3VycmVudFBlcmlvZFxyXG4gICAgICAgICAgICBuZXcgRXZlbnRQZXJpb2RfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRpbWV6b25lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2Qud2hlblJlbGVhc2VkKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIEFkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkU291cmNlID0gZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMucHVzaChldmVudFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVxdWVzdFNvdXJjZShldmVudFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZG9vbWVkU291cmNlKSB7XHJcbiAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KHRoaXMub3RoZXJTb3VyY2VzLCBkb29tZWRTb3VyY2UpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGRvb21lZFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VBbGxTb3VyY2VzKCk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIFJlZmV0Y2hpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaEFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQZXJpb2QgPSB0aGlzLmN1cnJlbnRQZXJpb2Q7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5mcmVlemUoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUXVlcnlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0aWNreVNvdXJjZV0uY29uY2F0KHRoaXMub3RoZXJTb3VyY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIHF1ZXJ5U291cmNlcywgYnV0IGFjY2VwdHMgbXVsdHBsZSBtYXRjaCBjcml0ZXJpYSAobGlrZSBtdWx0aXBsZSBJRHMpXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLm11bHRpUXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgLy8gY29lcmNlIGludG8gYW4gYXJyYXlcclxuICAgICAgICBpZiAoIW1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEkLmlzQXJyYXkobWF0Y2hJbnB1dHMpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW21hdGNoSW5wdXRzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU291cmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBtYXRjaGluZ1NvdXJjZXMsIHRoaXMucXVlcnlTb3VyY2VzKG1hdGNoSW5wdXRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ1NvdXJjZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cclxuICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgc291cmNlIG9iamVjdHMuXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnF1ZXJ5U291cmNlcyA9IGZ1bmN0aW9uIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLm90aGVyU291cmNlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgIC8vIGdpdmVuIGEgcHJvcGVyIGV2ZW50IHNvdXJjZSBvYmplY3RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gSUQgbWF0Y2hcclxuICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKG1hdGNoSW5wdXQpKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGFyc2UgYXMgYW4gZXZlbnQgc291cmNlXHJcbiAgICAgICAgbWF0Y2hJbnB1dCA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShtYXRjaElucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICBpZiAobWF0Y2hJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NvdXJjZXNFcXVpdmFsZW50KG1hdGNoSW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgSUQgYXNzdW1lZCB0byBhbHJlYWR5IGJlIG5vcm1hbGl6ZWRcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKHRoaXMub3RoZXJTb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuaWQgJiYgc291cmNlLmlkID09PSBpZDtcclxuICAgICAgICB9KVswXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1QZXJpb2RcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnNldFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRQZXJpb2QodGhpcy5jdXJyZW50UGVyaW9kKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gZXZlbnRQZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5iaW5kUGVyaW9kKGV2ZW50UGVyaW9kKTtcclxuICAgICAgICBldmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhldmVudFBlcmlvZCwgJ3JlbGVhc2UnLCBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKGV2ZW50UGVyaW9kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBHZXR0aW5nL0FkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZCeVVpZCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZCeVVpZCh1aWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0aWNreVNvdXJjZS5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnRJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUV2ZW50RGVmc0J5SWQoZXZlbnRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFNvdXJjZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICBldmVudFNvdXJjZS5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgTXV0YXRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXV0YXRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQsIGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciB1bmRvRnVuY3MgPSBbXTtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZnMgPSBjdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSBlc3AgYmVjYXVzZSBpZCBtaWdodCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmNzLnB1c2goZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZXZlbnREZWYpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kb0Z1bmNzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGNvcGllcyBhbmQgdGhlbiBtdXRhdGVzXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZkNvcHk7XHJcbiAgICAgICAgdmFyIGFsbEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVmQ29weSA9IGV2ZW50RGVmc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVmQ29weSBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZGVmQ29weSk7XHJcbiAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXMucHVzaC5hcHBseShhbGxJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZGVmQ29weS5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoYWxsSW5zdGFuY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBGcmVlemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBtZXRob2RzIHRoYXQgc2ltcGx5IGZvcndhcmQgdG8gRXZlbnRQZXJpb2RcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudE1hbmFnZXI7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudE1hbmFnZXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbmZ1bmN0aW9uIGlzU291cmNlc0VxdWl2YWxlbnQoc291cmNlMCwgc291cmNlMSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZTAuZ2V0UHJpbWl0aXZlKCkgPT09IHNvdXJjZTEuZ2V0UHJpbWl0aXZlKCk7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBFdmVudFBlcmlvZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UGVyaW9kKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ250ID0gMDtcclxuICAgICAgICB0aGlzLmZyZWV6ZURlcHRoID0gMDtcclxuICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLCBlbmQuY2xvbmUoKS5zdHJpcFpvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgIH1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5pc1dpdGhpblJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBUT0RPOiB1c2UgYSByYW5nZSB1dGlsIGZ1bmN0aW9uP1xyXG4gICAgICAgIHJldHVybiAhc3RhcnQuaXNCZWZvcmUodGhpcy5zdGFydCkgJiYgIWVuZC5pc0FmdGVyKHRoaXMuZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXF1ZXN0aW5nIGFuZCBQdXJnaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhdygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZXF1ZXN0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7IHNvdXJjZTogc291cmNlLCBzdGF0dXM6ICdwZW5kaW5nJywgZXZlbnREZWZzOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgKz0gMTtcclxuICAgICAgICBzb3VyY2UuZmV0Y2godGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMudGltZXpvbmUpLnRoZW4oZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ldmVudERlZnMgPSBldmVudERlZnM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRFdmVudERlZnMoZXZlbnREZWZzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5wdXJnZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNCeVVpZFtzb3VyY2UudWlkXTtcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcy5mb3JFYWNoKHRoaXMucmVtb3ZlRXZlbnREZWYuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdHNCeVVpZCA9IHRoaXMucmVxdWVzdHNCeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIHZhciByZXF1ZXN0O1xyXG4gICAgICAgIHZhciBjb21wbGV0ZWRDbnQgPSAwO1xyXG4gICAgICAgIGZvciAodWlkIGluIHJlcXVlc3RzQnlVaWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3RzQnlVaWRbdWlkXTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIGlmIChjb21wbGV0ZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEZWZpbml0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKGV2ZW50RGVmVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWZVaWRdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZXZlbnREZWZzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudERlZnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZklkID0gZXZlbnREZWYuaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gfHwgKGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gPSBbXSk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXModGhpcy51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkW2V2ZW50RGVmLnVpZF0gPSBldmVudERlZjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2VzW2ldLCBldmVudERlZklkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc0VtcHR5ID0gJC5pc0VtcHR5T2JqZWN0KHRoaXMuZXZlbnREZWZzQnlVaWQpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5SWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0ge307XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzQnlJZCA9IHRoaXMuZXZlbnREZWZzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXTtcclxuICAgICAgICBpZiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5yZW1vdmVFeGFjdChldmVudERlZnMsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgaWYgKCFldmVudERlZnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEluc3RhbmNlc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudEluc3RhbmNlR3JvdXBzQnlJZCkge1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IGV2ZW50RGVmSWQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nSW5zdGFuY2VzLnB1c2guYXBwbHkobWF0Y2hpbmdJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbaWRdLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdIHx8XHJcbiAgICAgICAgICAgIChldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXSA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICB2YXIgcmVtb3ZlQ250O1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmVtb3ZlQ250ID0gdXRpbF8xLnJlbW92ZU1hdGNoaW5nKGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcywgZnVuY3Rpb24gKGN1cnJlbnRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEV2ZW50SW5zdGFuY2UuZGVmID09PSBldmVudERlZjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlQ250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZWxlYXNpbmcgYW5kIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmZyZWV6ZURlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQrKztcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUud2hlblJlbGVhc2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZUNudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub25lKCdyZWxlYXNlJywgb25SZXNvbHZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5mcmVlemVEZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmZyZWV6ZURlcHRoKSAmJiB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ICYmICF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFBlcmlvZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQZXJpb2Q7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudFBlcmlvZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG4vKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZWxlbWVudCBhbmQgbGV0cyBpdCB0cmFjayB0aGUgbW91c2UgYXMgaXQgbW92ZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBNb3VzZUZvbGxvd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW91c2VGb2xsb3dlcihzb3VyY2VFbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyBkb2luZyB0aGUgcmV2ZXJ0IGFuaW1hdGlvbj9cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gc291cmNlRWw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRFbCA9IG9wdGlvbnMucGFyZW50RWwgPyAkKG9wdGlvbnMucGFyZW50RWwpIDogc291cmNlRWwucGFyZW50KCk7IC8vIGRlZmF1bHQgdG8gc291cmNlRWwncyBwYXJlbnRcclxuICAgIH1cclxuICAgIC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdGFydCBmb2xsb3dpbmcgdGhlIG1vdXNlXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0ZvbGxvd2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy55MCA9IHV0aWxfMS5nZXRFdlkoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLngwID0gdXRpbF8xLmdldEV2WChldik7XHJcbiAgICAgICAgICAgIHRoaXMudG9wRGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnREZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RvcCBmb2xsb3dpbmcgdGhlIG1vdXNlLiBJZiBzaG91bGRSZXZlcnQgaXMgdHJ1ZSwgd2lsbCBhbmltYXRlIGJhY2sgdG8gb3JpZ2luYWwgcG9zaXRpb24uXHJcbiAgICAvLyBgY2FsbGJhY2tgIGdldHMgaW52b2tlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGFuaW1hdGlvbiwgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseS5cclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoc2hvdWxkUmV2ZXJ0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJldmVydER1cmF0aW9uID0gdGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uO1xyXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBfdGhpcy50b3AwID0gX3RoaXMubGVmdDAgPSBudWxsOyAvLyByZXNldCBzdGF0ZSBmb3IgZnV0dXJlIHVwZGF0ZVBvc2l0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGb2xsb3dpbmcgJiYgIXRoaXMuaXNBbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXZlcnQgJiYgcmV2ZXJ0RHVyYXRpb24gJiYgIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHJldmVydER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRyYWNraW5nIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBuZWNlc3NhcnlcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmdldEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lKClcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5pc0hpZGRlbiA/ICdub25lJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc291cmNlRWwud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zb3VyY2VFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLm9wdGlvbnMuekluZGV4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxyXG4gICAgICAgICAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJyk7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIHZhciBvcmlnaW47XHJcbiAgICAgICAgdGhpcy5nZXRFbCgpOyAvLyBlbnN1cmUgdGhpcy5lbFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvcmlnaW4gaW5mbyB3YXMgY29tcHV0ZWRcclxuICAgICAgICBpZiAodGhpcy50b3AwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc291cmNlT2Zmc2V0ID0gdGhpcy5zb3VyY2VFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy50b3AwID0gc291cmNlT2Zmc2V0LnRvcCAtIG9yaWdpbi50b3A7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdDAgPSBzb3VyY2VPZmZzZXQubGVmdCAtIG9yaWdpbi5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AwICsgdGhpcy50b3BEZWx0YSxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRvcERlbHRhID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLnkwO1xyXG4gICAgICAgIHRoaXMubGVmdERlbHRhID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLngwO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRlbXBvcmFyaWx5IG1ha2VzIHRoZSB0cmFja2luZyBlbGVtZW50IGludmlzaWJsZS4gQ2FuIGJlIGNhbGxlZCBiZWZvcmUgZm9sbG93aW5nIHN0YXJ0c1xyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vdXNlRm9sbG93ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlRm9sbG93ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW91c2VGb2xsb3dlcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBEYXRlQ2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRlQ2xpY2tpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAtIGJpbmREYXRlSGFuZGxlclRvRWxcclxuICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgIC0gZ2V0SGl0RWxcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRlQ2xpY2tpbmcoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IF90aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZUNsaWNraW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuc2hvdWxkSWdub3JlVG91Y2goKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLCBmb3IgZGF5IGNsaWNraW5nLlxyXG4gICAgRGF0ZUNsaWNraW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgZGF5Q2xpY2tIaXQ7IC8vIG51bGwgaWYgaW52YWxpZCBkYXlDbGlja1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IGRyYWdMaXN0ZW5lci5vcmlnSGl0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZHJhZ2dlZCB0byBhbm90aGVyIGNlbGwgYXQgYW55IHBvaW50LCBpdCBjYW4gbm8gbG9uZ2VyIGJlIGEgZGF5Q2xpY2tcclxuICAgICAgICAgICAgICAgIGlmICghaXNPcmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkICYmIGRheUNsaWNrSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoZGF5Q2xpY2tIaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy50cmlnZ2VyRGF5Q2xpY2soY29tcG9uZW50Rm9vdHByaW50LCBjb21wb25lbnQuZ2V0SGl0RWwoZGF5Q2xpY2tIaXQpLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYmVjYXVzZSBkcmFnTGlzdGVuZXIgd29uJ3QgYmUgY2FsbGVkIHdpdGggYW55IHRpbWUgZGVsYXksIFwiZHJhZ2dpbmdcIiB3aWxsIGJlZ2luIGltbWVkaWF0ZWx5LFxyXG4gICAgICAgIC8vIHdoaWNoIHdpbGwga2lsbCBhbnkgdG91Y2htb3Zpbmcvc2Nyb2xsaW5nLiBQcmV2ZW50IHRoaXMuXHJcbiAgICAgICAgZHJhZ0xpc3RlbmVyLnNob3VsZENhbmNlbFRvdWNoU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgZHJhZ0xpc3RlbmVyLnNjcm9sbEFsd2F5c0tpbGxzID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlQ2xpY2tpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVDbGlja2luZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG4vKlxyXG5Pbmx5IGhhbmRsZXMgZm9yZWdyb3VuZCBzZWdzLlxyXG5Eb2VzIG5vdCBvd24gcmVuZGVyaW5nLiBVc2UgZm9yIGxvdy1sZXZlbCB1dGlsIG1ldGhvZHMgYnkgVGltZUdyaWQuXHJcbiovXHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEV2ZW50UmVuZGVyZXIodGltZUdyaWQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRpbWVHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLnRpbWVHcmlkLmZnQ29udGFpbmVyRWxzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBmb3JlZ3JvdW5kIHNlZ21lbnRzLCByZW5kZXIgYSBET00gZWxlbWVudCBmb3IgZWFjaCwgY29tcHV0ZXMgcG9zaXRpb24sXHJcbiAgICAvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzID0gZnVuY3Rpb24gKHNlZ3MsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBzZWdzQnlDb2w7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBzZWdzQnlDb2wgPSB0aGlzLnRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy50aW1lR3JpZC5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmdTZWdDb29yZHMoc2Vnc0J5Q29sW2NvbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmF0dGFjaFNlZ3NCeUNvbChzZWdzQnlDb2wsIGNvbnRhaW5lckVscyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5mZ1NlZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5mZ1NlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbm9NZXJpZGllbVRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjY6MzBcIiAobm8gQU0vUE0pXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgY29tcG9uZW50Rm9vdHByaW50ID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGlzQWxsRGF5ID0gY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RGVmRHJhZ2dhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XHJcbiAgICAgICAgdmFyIHNraW5Dc3MgPSB1dGlsXzEuY3NzVG9TdHIodGhpcy5nZXRTa2luQ3NzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIHRpbWVUZXh0O1xyXG4gICAgICAgIHZhciBmdWxsVGltZVRleHQ7IC8vIG1vcmUgdmVyYm9zZSB0aW1lIHRleHQuIGZvciB0aGUgcHJpbnQgc3R5bGVzaGVldFxyXG4gICAgICAgIHZhciBzdGFydFRpbWVUZXh0OyAvLyBqdXN0IHRoZSBzdGFydCB0aW1lIHRleHRcclxuICAgICAgICBjbGFzc2VzLnVuc2hpZnQoJ2ZjLXRpbWUtZ3JpZC1ldmVudCcsICdmYy12LWV2ZW50Jyk7XHJcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGFwcGVhcnMgdG8gc3BhbiBtb3JlIHRoYW4gb25lIGRheS4uLlxyXG4gICAgICAgIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxyXG4gICAgICAgICAgICAvLyBUaGF0IHdvdWxkIGFwcGVhciBhcyBtaWRuaWdodC1taWRuaWdodCBhbmQgd291bGQgbG9vayBkdW1iLlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRpc3BsYXkgdGhlIHRpbWUgdGV4dCBmb3IgdGhlICpzZWdtZW50J3MqIHRpbWVzIChsaWtlIDZwbS1taWRuaWdodCBvciBtaWRuaWdodC0xMGFtKVxyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZWRTdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLnN0YXJ0TXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvbmVkRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChzZWcuZW5kTXMpO1xyXG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXkpO1xyXG4gICAgICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQoem9uZWRTdGFydCwgem9uZWRFbmQsIGlzQWxsRGF5LCAnTFQnKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXksIG51bGwsIGZhbHNlKTsgLy8gZGlzcGxheUVuZD1mYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50LCAnTFQnKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoc2VnLmZvb3RwcmludCwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRpbWVUZXh0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLXN0YXJ0PVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKHN0YXJ0VGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLWZ1bGw9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZnVsbFRpbWVUZXh0KSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyB1dGlsXzEuaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChldmVudERlZi50aXRsZSA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIi8+JyArXHJcbiAgICAgICAgICAgIC8qIFRPRE86IHdyaXRlIENTUyBmb3IgdGhpc1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tRW5kID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhcmUgYXNzdW1lZCB0byBhbGwgbGl2ZSBpbiB0aGUgKnNhbWUgY29sdW1uKixcclxuICAgIC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZnU2VnQ29vcmRzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXHJcbiAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdIb3Jpem9udGFscyhzZWdzKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduRmdTZWdIb3Jpem9udGFscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cclxuICAgIC8vIE5PVEU6IEFsc28gcmVvcmRlcnMgdGhlIGdpdmVuIGFycmF5IGJ5IGRhdGUhXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzO1xyXG4gICAgICAgIHZhciBsZXZlbDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpOyAvLyBvcmRlciBieSBjZXJ0YWluIGNyaXRlcmlhXHJcbiAgICAgICAgbGV2ZWxzID0gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpO1xyXG4gICAgICAgIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKTtcclxuICAgICAgICBpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2VcclxuICAgIC8vIGZyb20gMCB0byAxLiBJZiB0aGUgY2FsZW5kYXIgaXMgbGVmdC10by1yaWdodCwgdGhlIHNlZy5iYWNrd2FyZENvb3JkIG1hcHMgdG8gXCJsZWZ0XCIgYW5kXHJcbiAgICAvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHNlZ21lbnQgbWlnaHQgYmUgcGFydCBvZiBhIFwic2VyaWVzXCIsIHdoaWNoIG1lYW5zIGNvbnNlY3V0aXZlIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgcHJlc3N1cmVcclxuICAgIC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXHJcbiAgICAvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xyXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3Qgc2VnbWVudCBpbiB0aGUgc2VyaWVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayA9IGZ1bmN0aW9uIChzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcclxuICAgICAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZy5mb3J3YXJkQ29vcmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIWZvcndhcmRTZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaGlnaGVzdCBwcmVzc3VyZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Rm9yd2FyZFNlZ3MoZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaGlnaGVzdC1wcmVzc3VyZSBmb3J3YXJkIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gZm9yd2FyZFNlZ3NbMF0uYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgIHNlZy5iYWNrd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZCAtXHJcbiAgICAgICAgICAgICAgICAoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgLy8gdXNlIHRoaXMgc2VnbWVudCdzIGNvb3JkaW5hdGVzIHRvIGNvbXB1dGVkIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGVzcy1wcmVzc3VyaXplZFxyXG4gICAgICAgICAgICAvLyBmb3J3YXJkIHNlZ21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1tpXSwgMCwgc2VnLmZvcndhcmRDb29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0Rm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoZm9yd2FyZFNlZ3MpIHtcclxuICAgICAgICBmb3J3YXJkU2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUZvcndhcmRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBmb3J3YXJkIHNlZ21lbnQgdG8gcmVseSBvbiBtb3JlIHdoZW4gY29tcHV0aW5nIGNvb3JkaW5hdGVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIC8vIHB1dCBoaWdoZXItcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICByZXR1cm4gc2VnMi5mb3J3YXJkUHJlc3N1cmUgLSBzZWcxLmZvcndhcmRQcmVzc3VyZSB8fFxyXG4gICAgICAgICAgICAvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxyXG4gICAgICAgICAgICAoc2VnMS5iYWNrd2FyZENvb3JkIHx8IDApIC0gKHNlZzIuYmFja3dhcmRDb29yZCB8fCAwKSB8fFxyXG4gICAgICAgICAgICAvLyBkbyBub3JtYWwgc29ydGluZy4uLlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXHJcbiAgICAvLyBhc3NpZ25zIHBvc2l0aW9uLXJlbGF0ZWQgQ1NTIHZhbHVlcyB0byB0aGVpciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduRmdTZWdIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoZWlnaHQgaXMgc2hvcnQsIGFkZCBhIGNsYXNzTmFtZSBmb3IgYWx0ZXJuYXRlIHN0eWxpbmdcclxuICAgICAgICAgICAgaWYgKHNlZy5ib3R0b20gLSBzZWcudG9wIDwgMzApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2hvcnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMvdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgc2VnbWVudCBlbGVtZW50LlxyXG4gICAgLy8gQ29udGFpbnMgaW1wb3J0YW50IHBvc2l0aW9uaW5nLXJlbGF0ZWQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFueSBldmVudCBlbGVtZW50LCBjdXN0b21pemVkIG9yIG5vdC5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHNob3VsZE92ZXJsYXAgPSB0aGlzLm9wdCgnc2xvdEV2ZW50T3ZlcmxhcCcpO1xyXG4gICAgICAgIHZhciBiYWNrd2FyZENvb3JkID0gc2VnLmJhY2t3YXJkQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIGZvcndhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQ7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy50aW1lR3JpZC5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZyk7IC8vIGdldCB0b3AvYm90dG9tIGZpcnN0XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy50aW1lR3JpZC5pc1JUTDtcclxuICAgICAgICB2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgIHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxyXG4gICAgICAgICAgICBmb3J3YXJkQ29vcmQgPSBNYXRoLm1pbigxLCBiYWNrd2FyZENvb3JkICsgKGZvcndhcmRDb29yZCAtIGJhY2t3YXJkQ29vcmQpICogMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JUTCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICAgICAgcmlnaHQgPSBiYWNrd2FyZENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHMuekluZGV4ID0gc2VnLmxldmVsICsgMTsgLy8gY29udmVydCBmcm9tIDAtYmFzZSB0byAxLWJhc2VkXHJcbiAgICAgICAgcHJvcHMubGVmdCA9IGxlZnQgKiAxMDAgKyAnJSc7XHJcbiAgICAgICAgcHJvcHMucmlnaHQgPSByaWdodCAqIDEwMCArICclJztcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiBzZWcuZm9yd2FyZFByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cclxuICAgICAgICAgICAgcHJvcHNbaXNSVEwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnXSA9IDEwICogMjsgLy8gMTAgaXMgYSBndWVzc3RpbWF0ZSBvZiB0aGUgaWNvbidzIHdpZHRoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG59KEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xyXG4vLyBsZWZ0LXRvLXJpZ2h0LCBvciB0aGUgcmlnaHRtb3N0IGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LiBBc3N1bWVzIHRoZSBzZWdtZW50cyBhcmUgYWxyZWFkeSBvcmRlcmVkIGJ5IGRhdGUuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKSB7XHJcbiAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBzZWc7XHJcbiAgICB2YXIgajtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCB0aGUgbGV2ZWxzIGFuZCBzdG9wIG9uIHRoZSBmaXJzdCBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNbal0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2VnLmxldmVsID0gajtcclxuICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZXZlbHM7XHJcbn1cclxuLy8gRm9yIGV2ZXJ5IHNlZ21lbnQsIGZpZ3VyZSBvdXQgdGhlIG90aGVyIHNlZ21lbnRzIHRoYXQgYXJlIGluIHN1YnNlcXVlbnRcclxuLy8gbGV2ZWxzIHRoYXQgYWxzbyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2UuIEFjY3VtdWxhdGUgaW4gc2VnLmZvcndhcmRTZWdzXHJcbmZ1bmN0aW9uIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZXZlbDtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIHNlZztcclxuICAgIHZhciBrO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldmVsID0gbGV2ZWxzW2ldO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBzZWcgPSBsZXZlbFtqXTtcclxuICAgICAgICAgICAgc2VnLmZvcndhcmRTZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbGV2ZWxzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNba10sIHNlZy5mb3J3YXJkU2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxyXG4vLyB0aGUgZnVydGhlc3QgZWRnZSBpcyByZWFjaGVkLiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aCB3aWxsIGJlIHNlZy5mb3J3YXJkUHJlc3N1cmVcclxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoc2VnKSB7XHJcbiAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICB2YXIgZm9yd2FyZFByZXNzdXJlID0gMDtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGZvcndhcmRTZWc7XHJcbiAgICBpZiAoc2VnLmZvcndhcmRQcmVzc3VyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvcndhcmRTZWcgPSBmb3J3YXJkU2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgY2hpbGQncyBtYXhpbXVtIGZvcndhcmQgcGF0aFxyXG4gICAgICAgICAgICBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhmb3J3YXJkU2VnKTtcclxuICAgICAgICAgICAgLy8gZWl0aGVyIHVzZSB0aGUgZXhpc3RpbmcgbWF4aW11bSwgb3IgdXNlIHRoZSBjaGlsZCdzIGZvcndhcmQgcHJlc3N1cmVcclxuICAgICAgICAgICAgLy8gcGx1cyBvbmUgKGZvciB0aGUgZm9yd2FyZFNlZyBpdHNlbGYpXHJcbiAgICAgICAgICAgIGZvcndhcmRQcmVzc3VyZSA9IE1hdGgubWF4KGZvcndhcmRQcmVzc3VyZSwgMSArIGZvcndhcmRTZWcuZm9yd2FyZFByZXNzdXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VnLmZvcndhcmRQcmVzc3VyZSA9IGZvcndhcmRQcmVzc3VyZTtcclxuICAgIH1cclxufVxyXG4vLyBGaW5kIGFsbCB0aGUgc2VnbWVudHMgaW4gYG90aGVyU2Vnc2AgdGhhdCB2ZXJ0aWNhbGx5IGNvbGxpZGUgd2l0aCBgc2VnYC5cclxuLy8gQXBwZW5kIGludG8gYW4gb3B0aW9uYWxseS1zdXBwbGllZCBgcmVzdWx0c2AgYXJyYXkgYW5kIHJldHVybi5cclxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgb3RoZXJTZWdzLCByZXN1bHRzKSB7XHJcbiAgICBpZiAocmVzdWx0cyA9PT0gdm9pZCAwKSB7IHJlc3VsdHMgPSBbXTsgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNTbG90U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzW2ldKSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gob3RoZXJTZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG4vLyBEbyB0aGVzZSBzZWdtZW50cyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2U/XHJcbmZ1bmN0aW9uIGlzU2xvdFNlZ0NvbGxpc2lvbihzZWcxLCBzZWcyKSB7XHJcbiAgICByZXR1cm4gc2VnMS5ib3R0b20gPiBzZWcyLnRvcCAmJiBzZWcxLnRvcCA8IHNlZzIuYm90dG9tO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEhlbHBlclJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc291cmNlRWw7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzKHNlZ3MsIHRoaXMuY29tcG9uZW50LmhlbHBlckNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1ha2UgdGhlIHNlZ21lbnQgdGhhdCBpcyBpbiB0aGUgc2FtZSByb3cgYXMgc291cmNlU2VnIGxvb2sgdGhlIHNhbWVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5jb2wgPT09IHNlZy5jb2wpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc291cmNlRWwuY3NzKCdsZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNvdXJjZUVsLmNzcygncmlnaHQnKSxcclxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBzb3VyY2VFbC5jc3MoJ21hcmdpbi1sZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLXJpZ2h0JylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhlbHBlck5vZGVzLnB1c2goc2VnLmVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICQoaGVscGVyTm9kZXMpOyAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxudmFyIFRpbWVHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEZpbGxSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgY29udGFpbmVyRWxzO1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgZWZmaWNpZW50IGxvb2t1cFxyXG4gICAgICAgIGlmICh0eXBlID09PSAnYmdFdmVudCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuYmdDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5idXNpbmVzc0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2hpZ2hsaWdodCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuaGlnaGxpZ2h0Q29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lR3JpZC51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCBjb250YWluZXJFbHMpO1xyXG4gICAgICAgIHJldHVybiBzZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWcuZWxbMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkRmlsbFJlbmRlcmVyO1xyXG59KEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBBIHJlY3Rhbmd1bGFyIHBhbmVsIHRoYXQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG92ZXIgb3RoZXIgY29udGVudFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuT3B0aW9uczpcclxuICAtIGNsYXNzTmFtZSAoc3RyaW5nKVxyXG4gIC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxyXG4gIC0gcGFyZW50RWxcclxuICAtIHRvcFxyXG4gIC0gbGVmdFxyXG4gIC0gcmlnaHQgKHRoZSB4IGNvb3JkIG9mIHdoZXJlIHRoZSByaWdodCBlZGdlIHNob3VsZCBiZS4gbm90IGEgXCJDU1NcIiByaWdodClcclxuICAtIGF1dG9IaWRlIChib29sZWFuKVxyXG4gIC0gc2hvdyAoY2FsbGJhY2spXHJcbiAgLSBoaWRlIChjYWxsYmFjaylcclxuKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIFBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3BvdmVyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1hcmdpbiA9IDEwOyAvLyB0aGUgc3BhY2UgcmVxdWlyZWQgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cclxuICAgIFBvcG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB0aGlzLmVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXBvcG92ZXJcIi8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKVxyXG4gICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gaW5pdGlhbGx5IHRvIHRoZSB0b3AgbGVmdCB0byBhdm9pZCBjcmVhdGluZyBzY3JvbGxiYXJzXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQob3B0aW9ucy5jb250ZW50KVxyXG4gICAgICAgICAgICAuYXBwZW5kVG8ob3B0aW9ucy5wYXJlbnRFbCk7XHJcbiAgICAgICAgLy8gd2hlbiBhIGNsaWNrIGhhcHBlbnMgb24gYW55dGhpbmcgaW5zaWRlIHdpdGggYSAnZmMtY2xvc2UnIGNsYXNzTmFtZSwgaGlkZSB0aGUgcG9wb3ZlclxyXG4gICAgICAgIHRoaXMuZWwub24oJ2NsaWNrJywgJy5mYy1jbG9zZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLmRvY3VtZW50TW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgISQoZXYudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWwpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlkZXMgYW5kIHVucmVnaXN0ZXJzIGFueSBoYW5kbGVyc1xyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nKTtcclxuICAgIH07XHJcbiAgICAvLyBQb3NpdGlvbnMgdGhlIHBvcG92ZXIgb3B0aW1hbGx5LCB1c2luZyB0aGUgdG9wL2xlZnQvcmlnaHQgb3B0aW9uc1xyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuZWwub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5lbC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZWwub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICB2YXIgd2luZG93RWwgPSAkKHdpbmRvdyk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0RWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWwpO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydFRvcDtcclxuICAgICAgICB2YXIgdmlld3BvcnRMZWZ0O1xyXG4gICAgICAgIHZhciB2aWV3cG9ydE9mZnNldDtcclxuICAgICAgICB2YXIgdG9wOyAvLyB0aGUgXCJwb3NpdGlvblwiIChub3QgXCJvZmZzZXRcIikgdmFsdWVzIGZvciB0aGUgcG9wb3ZlclxyXG4gICAgICAgIHZhciBsZWZ0OyAvL1xyXG4gICAgICAgIC8vIGNvbXB1dGUgdG9wIGFuZCBsZWZ0XHJcbiAgICAgICAgdG9wID0gb3B0aW9ucy50b3AgfHwgMDtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnJpZ2h0IC0gd2lkdGg7IC8vIGRlcml2ZSB0aGUgbGVmdCB2YWx1ZSBmcm9tIHRoZSByaWdodCB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3cG9ydEVsLmlzKHdpbmRvdykgfHwgdmlld3BvcnRFbC5pcyhkb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgdmlld3BvcnRFbCA9IHdpbmRvd0VsO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCA9IDA7IC8vIHRoZSB3aW5kb3cgaXMgYWx3YXlzIGF0IHRoZSB0b3AgbGVmdFxyXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSAwOyAvLyAoYW5kIC5vZmZzZXQoKSB3b24ndCB3b3JrIGlmIGNhbGxlZCBoZXJlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmlld3BvcnRPZmZzZXQgPSB2aWV3cG9ydEVsLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCA9IHZpZXdwb3J0T2Zmc2V0LnRvcDtcclxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gdmlld3BvcnRPZmZzZXQubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHdpbmRvdyBpcyBzY3JvbGxlZCwgaXQgY2F1c2VzIHRoZSB2aXNpYmxlIGFyZWEgdG8gYmUgZnVydGhlciBkb3duXHJcbiAgICAgICAgdmlld3BvcnRUb3AgKz0gd2luZG93RWwuc2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgdmlld3BvcnRMZWZ0ICs9IHdpbmRvd0VsLnNjcm9sbExlZnQoKTtcclxuICAgICAgICAvLyBjb25zdHJhaW4gdG8gdGhlIHZpZXcgcG9ydC4gaWYgY29uc3RyYWluZWQgYnkgdHdvIGVkZ2VzLCBnaXZlIHByZWNlZGVuY2UgdG8gdG9wL2xlZnRcclxuICAgICAgICBpZiAob3B0aW9ucy52aWV3cG9ydENvbnN0cmFpbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCB2aWV3cG9ydFRvcCArIHZpZXdwb3J0RWwub3V0ZXJIZWlnaHQoKSAtIGhlaWdodCAtIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCB2aWV3cG9ydFRvcCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIHZpZXdwb3J0TGVmdCArIHZpZXdwb3J0RWwub3V0ZXJXaWR0aCgpIC0gd2lkdGggLSB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCB2aWV3cG9ydExlZnQgKyB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiB0b3AgLSBvcmlnaW4udG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb3JpZ2luLmxlZnRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICAvLyBUT0RPOiBiZXR0ZXIgY29kZSByZXVzZSBmb3IgdGhpcy4gUmVwZWF0IGNvZGVcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9wb3ZlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUG9wb3ZlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhQb3BvdmVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcbi8qIEV2ZW50LXJlbmRlcmluZyBtZXRob2RzIGZvciB0aGUgRGF5R3JpZCBjbGFzc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkRXZlbnRSZW5kZXJlcihkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IGRheUdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgZXZlbnRSYW5nZXMgPSAkLmdyZXAoZXZlbnRSYW5nZXMsIGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJCZ1Jhbmdlcy5jYWxsKHRoaXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cclxuICAgICAgICB0aGlzLmRheUdyaWQucm93RWxzLmVhY2goZnVuY3Rpb24gKGksIHJvd05vZGUpIHtcclxuICAgICAgICAgICAgJChyb3dOb2RlKS5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiA+IHRhYmxlJykuYXBwZW5kKHJvd1N0cnVjdHNbaV0udGJvZHlFbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3Q7XHJcbiAgICAgICAgd2hpbGUgKChyb3dTdHJ1Y3QgPSByb3dTdHJ1Y3RzLnBvcCgpKSkge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QudGJvZHlFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXHJcbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXHJcbiAgICAvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdSb3dzO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgc2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcclxuICAgICAgICAvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBzZWdSb3dzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93U3RydWN0cy5wdXNoKHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3dTdHJ1Y3RzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXHJcbiAgICAvLyB0aGUgc2VnbWVudHMuIFJldHVybnMgb2JqZWN0IHdpdGggYSBidW5jaCBvZiBpbnRlcm5hbCBkYXRhIGFib3V0IGhvdyB0aGUgcmVuZGVyIHdhcyBjYWxjdWxhdGVkLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1JvdyA9IGZ1bmN0aW9uIChyb3csIHJvd1NlZ3MpIHtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5kYXlHcmlkLmNvbENudDtcclxuICAgICAgICB2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xyXG4gICAgICAgIHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXHJcbiAgICAgICAgdmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKTtcclxuICAgICAgICB2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciBhbGwgPHRkPiBlbGVtZW50cyBvZiB0aGUgbGV2ZWwrY29sIG1hdHJpeFxyXG4gICAgICAgIHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxldmVsU2VncztcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciB0cjtcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciB0ZDtcclxuICAgICAgICAvLyBwb3B1bGF0ZXMgZW1wdHkgY2VsbHMgZnJvbSB0aGUgY3VycmVudCBjb2x1bW4gKGBjb2xgKSB0byBgZW5kQ29sYFxyXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdyYWIgYSBjZWxsIGZyb20gdGhlIGxldmVsIGFib3ZlIGFuZCBleHRlbmQgaXRzIHJvd3NwYW4uIG90aGVyd2lzZSwgY3JlYXRlIGEgZnJlc2ggY2VsbFxyXG4gICAgICAgICAgICAgICAgdGQgPSAobG9uZUNlbGxNYXRyaXhbaSAtIDFdIHx8IFtdKVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYXR0cigncm93c3BhbicsIHBhcnNlSW50KHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxLCAxMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRkID0gJCgnPHRkLz4nKTtcclxuICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSBzZWdMZXZlbHNbaV07XHJcbiAgICAgICAgICAgIGNvbCA9IDA7XHJcbiAgICAgICAgICAgIHRyID0gJCgnPHRyLz4nKTtcclxuICAgICAgICAgICAgc2VnTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgLy8gbGV2ZWxDbnQgbWlnaHQgYmUgMSBldmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gYWN0dWFsIGxldmVscy4gcHJvdGVjdCBhZ2FpbnN0IHRoaXMuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXHJcbiAgICAgICAgICAgIGlmIChsZXZlbFNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3Nbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb250YWluZXIgdGhhdCBvY2N1cGllcyBvciBtb3JlIGNvbHVtbnMuIGFwcGVuZCB0aGUgZXZlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICB0ZCA9ICQoJzx0ZCBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiLz4nKS5hcHBlbmQoc2VnLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmxlZnRDb2wgIT09IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdjb2xzcGFuJywgc2VnLnJpZ2h0Q29sIC0gc2VnLmxlZnRDb2wgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01hdHJpeFtpXVtjb2xdID0gc2VnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib29rZW5kQ2VsbHModHIpO1xyXG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgdGJvZHlFbDogdGJvZHksXHJcbiAgICAgICAgICAgIGNlbGxNYXRyaXg6IGNlbGxNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ01hdHJpeDogc2VnTWF0cml4LFxyXG4gICAgICAgICAgICBzZWdMZXZlbHM6IHNlZ0xldmVscyxcclxuICAgICAgICAgICAgc2Vnczogcm93U2Vnc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgc2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnTGV2ZWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cclxuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RheVNlZ0NvbGxpc2lvbihzZWcsIGxldmVsc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxyXG4gICAgICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcclxuICAgICAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGV2ZWxzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ3JvdXBTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2VnUm93cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRheUdyaWQucm93Q250OyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93cy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ1Jvd3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXh0cmFTbWFsbFRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjZwXCIgb3IgXCI2OjMwcFwiXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheUdyaWQuY29sQ250ID09PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpc0FsbERheSA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERlZkRyYWdnYWJsZShldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBpc0FsbERheSAmJlxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xyXG4gICAgICAgIHZhciBza2luQ3NzID0gdXRpbF8xLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICB2YXIgdGl0bGVIdG1sO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xyXG4gICAgICAgIC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XHJcbiAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgdXRpbF8xLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpdGxlSHRtbCA9XHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAodXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZC5pc1JUTCA/XHJcbiAgICAgICAgICAgICAgICB0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgLy9cclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2E+JztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbi8vIENvbXB1dGVzIHdoZXRoZXIgdHdvIHNlZ21lbnRzJyBjb2x1bW5zIGNvbGxpZGUuIFRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LlxyXG5mdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3RoZXJTZWc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3RoZXJTZWcgPSBvdGhlclNlZ3NbaV07XHJcbiAgICAgICAgaWYgKG90aGVyU2VnLmxlZnRDb2wgPD0gc2VnLnJpZ2h0Q29sICYmXHJcbiAgICAgICAgICAgIG90aGVyU2VnLnJpZ2h0Q29sID49IHNlZy5sZWZ0Q29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XHJcbmZ1bmN0aW9uIGNvbXBhcmVEYXlTZWdDb2xzKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmxlZnRDb2wgLSBiLmxlZnRDb2w7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbnZhciBEYXlHcmlkSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkSGVscGVyUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgc2VnbWVudCBvYmplY3QuIEl0IGNhbiBiZSBudWxsLlxyXG4gICAgRGF5R3JpZEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIHZhciBoZWxwZXJOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzO1xyXG4gICAgICAgIC8vIFRPRE86IG5vdCBnb29kIHRvIGNhbGwgZXZlbnRSZW5kZXJlciB0aGlzIHdheVxyXG4gICAgICAgIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyU2VnUm93cyhzZWdzKTtcclxuICAgICAgICAvLyBpbmplY3QgZWFjaCBuZXcgZXZlbnQgc2tlbGV0b24gaW50byBlYWNoIGFzc29jaWF0ZWQgcm93XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVhY2goZnVuY3Rpb24gKHJvdywgcm93Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcm93RWwgPSAkKHJvd05vZGUpOyAvLyB0aGUgLmZjLXJvd1xyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWxwZXItc2tlbGV0b25cIj48dGFibGUvPjwvZGl2PicpOyAvLyB3aWxsIGJlIGFic29sdXRlbHkgcG9zaXRpb25lZFxyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3BFbDtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmlnaW5hbCBzZWdtZW50LCBtYXRjaCB0aGUgdG9wIHBvc2l0aW9uLiBPdGhlcndpc2UsIHB1dCBpdCBhdCB0aGUgcm93J3MgdG9wIGxldmVsXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNvdXJjZVNlZy5lbC5wb3NpdGlvbigpLnRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0Ym9keScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3AgPSBza2VsZXRvblRvcEVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwuY3NzKCd0b3AnLCBza2VsZXRvblRvcClcclxuICAgICAgICAgICAgICAgIC5maW5kKCd0YWJsZScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHJvd1N0cnVjdHNbcm93XS50Ym9keUVsKTtcclxuICAgICAgICAgICAgcm93RWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAkKGhlbHBlck5vZGVzKTsgLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRGaWxsUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZmlsbFNlZ1RhZyA9ICd0ZCc7IC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLnJlbmRlckZpbGxSb3codHlwZSwgc2VnKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVxKHNlZy5yb3cpLmFwcGVuZChza2VsZXRvbkVsKTtcclxuICAgICAgICAgICAgbm9kZXMucHVzaChza2VsZXRvbkVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSByb3cgb2YgYSBmaWxsLiBSZXF1aXJlcyB0aGUgc2VnJ3MgZWwgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGaWxsUm93ID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbXBvbmVudC5jb2xDbnQ7XHJcbiAgICAgICAgdmFyIHN0YXJ0Q29sID0gc2VnLmxlZnRDb2w7XHJcbiAgICAgICAgdmFyIGVuZENvbCA9IHNlZy5yaWdodENvbCArIDE7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdiZ2V2ZW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPjx0ci8+PC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHRyRWwgPSBza2VsZXRvbkVsLmZpbmQoJ3RyJyk7XHJcbiAgICAgICAgaWYgKHN0YXJ0Q29sID4gMCkge1xyXG4gICAgICAgICAgICB0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgc3RhcnRDb2wgKyAnXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ckVsLmFwcGVuZChzZWcuZWwuYXR0cignY29sc3BhbicsIGVuZENvbCAtIHN0YXJ0Q29sKSk7XHJcbiAgICAgICAgaWYgKGVuZENvbCA8IGNvbENudCkge1xyXG4gICAgICAgICAgICB0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgKGNvbENudCAtIGVuZENvbCkgKyAnXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5ib29rZW5kQ2VsbHModHJFbCk7XHJcbiAgICAgICAgcmV0dXJuIHNrZWxldG9uRWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRmlsbFJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjgpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZml4ZWRXZWVrQ291bnQnKSkge1xyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xyXG4gICAgICAgICAgICBlbmQuZGlmZihzdGFydCwgJ3dlZWtzJywgdHJ1ZSkgLy8gZG9udFJvdW5kPXRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZW5kLmFkZCg2IC0gcm93Q250LCAnd2Vla3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIExpc3RFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0RXZlbnRSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAoIXNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlbmRlckVtcHR5TWVzc2FnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyU2VnTGlzdChzZWdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCByb3dcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnQgPSBzZWcuZm9vdHByaW50O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50Rm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQgPSBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHVybCA9IGV2ZW50RGVmLnVybDtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFsnZmMtbGlzdC1pdGVtJ10uY29uY2F0KHRoaXMuZ2V0Q2xhc3NlcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciBiZ0NvbG9yID0gdGhpcy5nZXRCZ0NvbG9yKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgdGltZUh0bWw7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMuX2dldFRpbWVUZXh0KGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLnN0YXJ0TXMpLCBjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5lbmRNcyksIGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgPSB2aWV3LmdldEFsbERheUh0bWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgbm9ybWFsIHRpbWUgdGV4dCBmb3IgdGhlICpldmVudCdzKiB0aW1lc1xyXG4gICAgICAgICAgICB0aW1lSHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMuZ2V0VGltZVRleHQoZXZlbnRGb290cHJpbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWhhcy11cmwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgP1xyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aW1lICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICh0aW1lSHRtbCB8fCAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS1tYXJrZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLWV2ZW50LWRvdFwiJyArXHJcbiAgICAgICAgICAgIChiZ0NvbG9yID9cclxuICAgICAgICAgICAgICAgICcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBiZ0NvbG9yICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGl0bGUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8YScgKyAodXJsID8gJyBocmVmPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKHVybCkgKyAnXCInIDogJycpICsgJz4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgLy8gbGlrZSBcIjQ6MDBhbVwiXHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ21lZGl1bVRpbWVGb3JtYXQnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdEV2ZW50UmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcbnZhciBMaXN0RXZlbnRQb2ludGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExpc3RFdmVudFBvaW50aW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yIGV2ZW50cyB3aXRoIGEgdXJsLCB0aGUgd2hvbGUgPHRyPiBzaG91bGQgYmUgY2xpY2thYmxlLFxyXG4gICAgLy8gYnV0IGl0J3MgaW1wb3NzaWJsZSB0byB3cmFwIHdpdGggYW4gPGE+IHRhZy4gc2ltdWxhdGUgdGhpcy5cclxuICAgIExpc3RFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHVybDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgc2VnLCBldik7IC8vIG1pZ2h0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uXHJcbiAgICAgICAgLy8gbm90IGNsaWNraW5nIG9uIG9yIHdpdGhpbiBhbiA8YT4gd2l0aCBhbiBocmVmXHJcbiAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnYVtocmVmXScpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1cmwgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmLnVybDtcclxuICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBzaW11bGF0ZSBsaW5rIGNsaWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RFdmVudFBvaW50aW5nO1xyXG59KEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RFdmVudFBvaW50aW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE1KTtcclxudmFyIEpzb25GZWVkRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE2KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoQXJyYXlFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhGdW5jRXZlbnRTb3VyY2VfMS5kZWZhdWx0KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoSnNvbkZlZWRFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcbnZhciBTdGFuZGFyZFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMyk7XHJcbnZhciBKcXVlcnlVaVRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNCk7XHJcbnZhciBCb290c3RyYXAzVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjU4KTtcclxudmFyIEJvb3RzdHJhcDRUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTkpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ3N0YW5kYXJkJywgU3RhbmRhcmRUaGVtZV8xLmRlZmF1bHQpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ2pxdWVyeS11aScsIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtKCdib290c3RyYXAzJywgQm9vdHN0cmFwM1RoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnYm9vdHN0cmFwNCcsIEJvb3RzdHJhcDRUaGVtZV8xLmRlZmF1bHQpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBCb290c3RyYXAzVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCb290c3RyYXAzVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXAzVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvb3RzdHJhcDNUaGVtZTtcclxufShUaGVtZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm9vdHN0cmFwM1RoZW1lO1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXAzJyxcclxuICAgIHRhYmxlR3JpZDogJ3RhYmxlLWJvcmRlcmVkJyxcclxuICAgIHRhYmxlTGlzdDogJ3RhYmxlJyxcclxuICAgIHRhYmxlTGlzdEhlYWRpbmc6ICdhY3RpdmUnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXHJcbiAgICB0b2RheTogJ2FsZXJ0IGFsZXJ0LWluZm8nLFxyXG4gICAgcG9wb3ZlcjogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3BhbmVsLWhlYWRpbmcnLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICdwYW5lbC1ib2R5JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICAvLyBmb3IgbGVmdC9yaWdodCBib3JkZXIgY29sb3Igd2hlbiBib3JkZXIgaXMgaW5zZXQgZnJvbSBlZGdlcyAoYWxsLWRheSBpbiBhZ2VuZGEgdmlldylcclxuICAgIC8vIGF2b2lkIGBwYW5lbGAgY2xhc3MgYi9jIGRvbid0IHdhbnQgbWFyZ2lucy9yYWRpdXMuIG9ubHkgYm9yZGVyIGNvbG9yLlxyXG4gICAgaGVhZGVyUm93OiAncGFuZWwtZGVmYXVsdCcsXHJcbiAgICBkYXlSb3c6ICdwYW5lbC1kZWZhdWx0JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdwYW5lbCBwYW5lbC1kZWZhdWx0J1xyXG59O1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZ2x5cGhpY29uJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAnZ2x5cGhpY29uLXJlbW92ZScsXHJcbiAgICBwcmV2OiAnZ2x5cGhpY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICBuZXh0OiAnZ2x5cGhpY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgcHJldlllYXI6ICdnbHlwaGljb24tYmFja3dhcmQnLFxyXG4gICAgbmV4dFllYXI6ICdnbHlwaGljb24tZm9yd2FyZCdcclxufTtcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYm9vdHN0cmFwR2x5cGhpY29ucyc7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2Jvb3RzdHJhcEdseXBoaWNvbic7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2dseXBoaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBCb290c3RyYXA0VGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCb290c3RyYXA0VGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXA0VGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvb3RzdHJhcDRUaGVtZTtcclxufShUaGVtZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm9vdHN0cmFwNFRoZW1lO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXA0JyxcclxuICAgIHRhYmxlR3JpZDogJ3RhYmxlLWJvcmRlcmVkJyxcclxuICAgIHRhYmxlTGlzdDogJ3RhYmxlJyxcclxuICAgIHRhYmxlTGlzdEhlYWRpbmc6ICd0YWJsZS1hY3RpdmUnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi1wcmltYXJ5JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXHJcbiAgICB0b2RheTogJ2FsZXJ0IGFsZXJ0LWluZm8nLFxyXG4gICAgcG9wb3ZlcjogJ2NhcmQgY2FyZC1wcmltYXJ5JyxcclxuICAgIHBvcG92ZXJIZWFkZXI6ICdjYXJkLWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2NhcmQtYm9keScsXHJcbiAgICAvLyBkYXkgZ3JpZFxyXG4gICAgLy8gZm9yIGxlZnQvcmlnaHQgYm9yZGVyIGNvbG9yIHdoZW4gYm9yZGVyIGlzIGluc2V0IGZyb20gZWRnZXMgKGFsbC1kYXkgaW4gYWdlbmRhIHZpZXcpXHJcbiAgICAvLyBhdm9pZCBgdGFibGVgIGNsYXNzIGIvYyBkb24ndCB3YW50IG1hcmdpbnMvcGFkZGluZy9zdHJ1Y3R1cmUuIG9ubHkgYm9yZGVyIGNvbG9yLlxyXG4gICAgaGVhZGVyUm93OiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgZGF5Um93OiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ2NhcmQgY2FyZC1wcmltYXJ5J1xyXG59O1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZmEnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICdmYS10aW1lcycsXHJcbiAgICBwcmV2OiAnZmEtY2hldnJvbi1sZWZ0JyxcclxuICAgIG5leHQ6ICdmYS1jaGV2cm9uLXJpZ2h0JyxcclxuICAgIHByZXZZZWFyOiAnZmEtYW5nbGUtZG91YmxlLWxlZnQnLFxyXG4gICAgbmV4dFllYXI6ICdmYS1hbmdsZS1kb3VibGUtcmlnaHQnXHJcbn07XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2Jvb3RzdHJhcEZvbnRBd2Vzb21lJztcclxuQm9vdHN0cmFwNFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnYm9vdHN0cmFwRm9udEF3ZXNvbWUnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICdmYS0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVmlld1JlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbnZhciBNb250aFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI5KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYmFzaWMnLCB7XHJcbiAgICAnY2xhc3MnOiBCYXNpY1ZpZXdfMS5kZWZhdWx0XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdiYXNpY0RheScsIHtcclxuICAgIHR5cGU6ICdiYXNpYycsXHJcbiAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2Jhc2ljV2VlaycsIHtcclxuICAgIHR5cGU6ICdiYXNpYycsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdtb250aCcsIHtcclxuICAgICdjbGFzcyc6IE1vbnRoVmlld18xLmRlZmF1bHQsXHJcbiAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWVcclxuICAgIH1cclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjYpO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdhZ2VuZGEnLCB7XHJcbiAgICAnY2xhc3MnOiBBZ2VuZGFWaWV3XzEuZGVmYXVsdCxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcclxuICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXHJcbiAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSAvLyBhIGJhZCBuYW1lLiBjb25mdXNlZCB3aXRoIG92ZXJsYXAvY29uc3RyYWludCBzeXN0ZW1cclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYURheScsIHtcclxuICAgIHR5cGU6ICdhZ2VuZGEnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdhZ2VuZGFXZWVrJywge1xyXG4gICAgdHlwZTogJ2FnZW5kYScsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVmlld1JlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIExpc3RWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMCk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3QnLCB7XHJcbiAgICAnY2xhc3MnOiBMaXN0Vmlld18xLmRlZmF1bHQsXHJcbiAgICBidXR0b25UZXh0S2V5OiAnbGlzdCcsXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGJ1dHRvblRleHQ6ICdsaXN0JyxcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiAnTEwnLFxyXG4gICAgICAgIG5vRXZlbnRzTWVzc2FnZTogJ05vIGV2ZW50cyB0byBkaXNwbGF5J1xyXG4gICAgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnbGlzdERheScsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0V2VlaycsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdkZGRkJyxcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnTEwnXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0TW9udGgnLCB7XHJcbiAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICBkdXJhdGlvbjogeyBtb250aDogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0WWVhcicsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgfVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMjYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fullcalendar/dist/fullcalendar.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcz9lZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0c2NyaXB0WyBpIF0gPSBub2RlWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjMuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jLCBub2RlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblx0XHQpICk7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSB7XG5cblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF07XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxMCAyNiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-4cd3c980\",\"hasScoped\":false,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/Dashboard/Calendar/Calendar.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { attrs: { id: \"fullCalendar\" } })\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nif (true) {\n  module.hot.accept()\n  if (module.hot.data) {\n    __webpack_require__(\"./node_modules/vue-hot-reload-api/dist/index.js\")      .rerender(\"data-v-4cd3c980\", { render: render, staticRenderFns: staticRenderFns })\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXguanM/e1wiaWRcIjpcImRhdGEtdi00Y2QzYzk4MFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJvcHRpb25zSWRcIjpcIjBcIixcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3BhZ2VzL0Rhc2hib2FyZC9DYWxlbmRhci9DYWxlbmRhci52dWUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZT9hMDBjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJmdWxsQ2FsZW5kYXJcIiB9IH0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi00Y2QzYzk4MFwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00Y2QzYzk4MFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJvcHRpb25zSWRcIjpcIjBcIixcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3BhZ2VzL0Rhc2hib2FyZC9DYWxlbmRhci9DYWxlbmRhci52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtNGNkM2M5ODBcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwib3B0aW9uc0lkXCI6XCIwXCIsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMjYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-4cd3c980\",\"hasScoped\":false,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\n");

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?{\"shadowMode\":false,\"sourceMap\":false}!./node_modules/css-loader/index.js?{\"sourceMap\":false,\"minimize\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\"optionsId\":\"0\",\"vue\":true,\"scoped\":false,\"sourceMap\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue":
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"./node_modules/css-loader/index.js?{\\\"sourceMap\\\":false,\\\"minimize\\\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"./node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"205094d5\", content, false, {\"shadowMode\":false,\"sourceMap\":false});\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"./node_modules/css-loader/index.js?{\\\"sourceMap\\\":false,\\\"minimize\\\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\", function() {\n     var newContent = __webpack_require__(\"./node_modules/css-loader/index.js?{\\\"sourceMap\\\":false,\\\"minimize\\\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\");\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcz97XCJzaGFkb3dNb2RlXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XCJzb3VyY2VNYXBcIjpmYWxzZSxcIm1pbmltaXplXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcIm9wdGlvbnNJZFwiOlwiMFwiLFwidnVlXCI6dHJ1ZSxcInNjb3BlZFwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlP2QxNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZSxcXFwibWluaW1pemVcXFwiOmZhbHNlfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0NhbGVuZGFyLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIyMDUwOTRkNVwiLCBjb250ZW50LCBmYWxzZSwge1wic2hhZG93TW9kZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZSxcXFwibWluaW1pemVcXFwiOmZhbHNlfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0NhbGVuZGFyLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XFxcInNvdXJjZU1hcFxcXCI6ZmFsc2UsXFxcIm1pbmltaXplXFxcIjpmYWxzZX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9DYWxlbmRhci52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXI/e1wic2hhZG93TW9kZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/e1wic291cmNlTWFwXCI6ZmFsc2UsXCJtaW5pbWl6ZVwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJvcHRpb25zSWRcIjpcIjBcIixcInZ1ZVwiOnRydWUsXCJzY29wZWRcIjpmYWxzZSxcInNvdXJjZU1hcFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL3BhZ2VzL0Rhc2hib2FyZC9DYWxlbmRhci9DYWxlbmRhci52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanM/e1wic2hhZG93TW9kZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1wic291cmNlTWFwXCI6ZmFsc2UsXCJtaW5pbWl6ZVwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XCJvcHRpb25zSWRcIjpcIjBcIixcInZ1ZVwiOnRydWUsXCJzY29wZWRcIjpmYWxzZSxcInNvdXJjZU1hcFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL3BhZ2VzL0Rhc2hib2FyZC9DYWxlbmRhci9DYWxlbmRhci52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAyNiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-style-loader/index.js?{\"shadowMode\":false,\"sourceMap\":false}!./node_modules/css-loader/index.js?{\"sourceMap\":false,\"minimize\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\"optionsId\":\"0\",\"vue\":true,\"scoped\":false,\"sourceMap\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\n");

/***/ }),

/***/ "./src/pages/Dashboard/Calendar/Calendar.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cache_loader_cacheDirectory_home_ssalazar_Projects_vue_dashboard_metrics_node_modules_cache_cache_loader_babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Calendar_vue__ = __webpack_require__(\"./node_modules/cache-loader/dist/cjs.js?{\\\"cacheDirectory\\\":\\\"/home/ssalazar/Projects/vue-dashboard-metrics/node_modules/.cache/cache-loader\\\"}!./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\");\n/* empty harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4cd3c980_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Calendar_vue__ = __webpack_require__(\"./node_modules/vue-loader/lib/template-compiler/index.js?{\\\"id\\\":\\\"data-v-4cd3c980\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_runtime_component_normalizer__ = __webpack_require__(\"./node_modules/vue-loader/lib/runtime/component-normalizer.js\");\nvar disposed = false\nfunction injectStyle (context) {\n  if (disposed) return\n  __webpack_require__(\"./node_modules/vue-style-loader/index.js?{\\\"shadowMode\\\":false,\\\"sourceMap\\\":false}!./node_modules/css-loader/index.js?{\\\"sourceMap\\\":false,\\\"minimize\\\":false}!./node_modules/vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/pages/Dashboard/Calendar/Calendar.vue\")\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\n\nvar Component = Object(__WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_runtime_component_normalizer__[\"a\" /* default */])(\n  __WEBPACK_IMPORTED_MODULE_0__cache_loader_cacheDirectory_home_ssalazar_Projects_vue_dashboard_metrics_node_modules_cache_cache_loader_babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Calendar_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4cd3c980_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Calendar_vue__[\"a\" /* render */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4cd3c980_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Calendar_vue__[\"b\" /* staticRenderFns */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src/pages/Dashboard/Calendar/Calendar.vue\"\n\n/* hot reload */\nif (true) {(function () {\n  var hotAPI = __webpack_require__(\"./node_modules/vue-hot-reload-api/dist/index.js\")\n  hotAPI.install(__webpack_require__(\"./node_modules/vue/dist/vue.runtime.esm.js\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-4cd3c980\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-4cd3c980\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlPzIzOWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChjb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXI/e1xcXCJzaGFkb3dNb2RlXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hY3NzLWxvYWRlcj97XFxcInNvdXJjZU1hcFxcXCI6ZmFsc2UsXFxcIm1pbmltaXplXFxcIjpmYWxzZX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9DYWxlbmRhci52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhY2FjaGUtbG9hZGVyP3tcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOlxcXCIvaG9tZS9zc2FsYXphci9Qcm9qZWN0cy92dWUtZGFzaGJvYXJkLW1ldHJpY3Mvbm9kZV9tb2R1bGVzLy5jYWNoZS9jYWNoZS1sb2FkZXJcXFwifSFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9DYWxlbmRhci52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWNhY2hlLWxvYWRlcj97XFxcImNhY2hlRGlyZWN0b3J5XFxcIjpcXFwiL2hvbWUvc3NhbGF6YXIvUHJvamVjdHMvdnVlLWRhc2hib2FyZC1tZXRyaWNzL25vZGVfbW9kdWxlcy8uY2FjaGUvY2FjaGUtbG9hZGVyXFxcIn0hYmFiZWwtbG9hZGVyIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQ2FsZW5kYXIudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQge3JlbmRlciBhcyBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zIGFzIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX199IGZyb20gXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTRjZDNjOTgwXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0NhbGVuZGFyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9wYWdlcy9EYXNoYm9hcmQvQ2FsZW5kYXIvQ2FsZW5kYXIudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTRjZDNjOTgwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNGNkM2M5ODBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9zcmMvcGFnZXMvRGFzaGJvYXJkL0NhbGVuZGFyL0NhbGVuZGFyLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDI2Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/Dashboard/Calendar/Calendar.vue\n");

/***/ })

});